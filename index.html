<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="懒人小屋">
<meta property="og:url" content="http://mlazy.club/index.html">
<meta property="og:site_name" content="懒人小屋">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="懒人小屋">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: 'Y7WOEP5F21',
      apiKey: 'b381145e3b0e8b27fa7576de9cb620bb',
      indexName: 'mlazy.club',
      hits: {"per_page":10},
      labels: {"input_placeholder":"搜索文章","hits_empty":"未找到与 ${query} 相关的文章","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://mlazy.club/"/>





  <title>懒人小屋</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-111245807-1', 'auto');
  ga('send', 'pageview');
</script>











</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">懒人小屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">为了偷懒而使用工具</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mlazy.club/usage-of-kotlin-difference-with-java.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mluffy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人小屋">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/usage-of-kotlin-difference-with-java.html" itemprop="url">kotlin的进阶用法，不同于 java 的使用方式</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-28T11:21:18+08:00">
                2017-12-28
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/usage-of-kotlin-difference-with-java.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="usage-of-kotlin-difference-with-java.html" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          
             <span id="/usage-of-kotlin-difference-with-java.html" class="leancloud_visitors" data-flag-title="kotlin的进阶用法，不同于 java 的使用方式">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇主要是通过对比 java 与 kotlin 在语言上的一些细节，列举一些在 java 里过时的用法，以及对应 kotlin 中相对优雅的实现</p>
<h1 id="Listener-vs-Function"><a href="#Listener-vs-Function" class="headerlink" title="Listener vs Function"></a>Listener vs Function</h1><p>很多情况下，我们需要通过 listener 回调一些事件，比如 View.onClickListener，在 kotlin 中，使用 Function 会更优雅，特别是后面提到尾随闭包（借用 swift 的名词）下使用，更加优雅。</p>
<p>在 kotlin 中，如果使用传统的 interface 来定义一个 listener，然后再使用，会比在 java 中使用 java8的 lamba 表达式还要复杂一些。比如 View.onClickListener</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">view.setOnClickListener(View.OnClickListener(&#123;....&#125;))</div></pre></td></tr></table></figure>
<p>在 kotlin 中，使用 typealias + Function，会使得调用更加简洁优雅</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//单个参数，或者无参的回调</span></div><div class="line">typealias Callback&lt;T&gt; = T -&gt; <span class="built_in">Unit</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</div><div class="line">  <span class="keyword">val</span> callback: Callback&lt;<span class="built_in">Unit</span>&gt;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">val</span> a = SomeClass()</div><div class="line">a.callback = &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>interface 应该回归它原本的样子，它是一个抽象接口，代表了一类行为。类似 callback 的用法，在 kotlin 中应该改用 typealias + function 来实现。</p>
<h1 id="尾随闭包"><a href="#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h1><p>尾随闭包是 swift 的名词，意思就是说，如果函数的最后一个参数是一个方法，那么我们可以把这个方法的定义写在函数体外。比如</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//沿用上面 callback 的声明，这个函数的作用是通过回调返回传入的整数+1之后的结果</span></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">plus1</span><span class="params">(value: <span class="type">Int</span>, callback: <span class="type">Callback</span>&lt;<span class="type">Int</span>&gt;)</span></span> = callback(value+<span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="comment">//调用</span></div><div class="line">plus1(<span class="number">1</span>) &#123;</div><div class="line">  printlng(<span class="string">"result = <span class="variable">$it</span>"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种写法会让代码看起来更简洁，也使得方法本身看起来像是一个扩展方法，让一类代码写得比较紧凑易读。比如，android 应用初始化时，我们需要在 application 的 onCreate 里进行初始化，初始化的顺序是有要求的，比如先要初始化 Logger，然后再初始化 lib 相关的库，最后初始化业务相关的内容。</p>
<p>一般我们会这么写</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="comment">//初始化配置信息</span></div><div class="line">  initConfig()</div><div class="line">  <span class="comment">//lib 库初始化</span></div><div class="line">  initLib()</div><div class="line">  <span class="comment">//业务初始化</span></div><div class="line">  initBusiniess()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是有可能有的 config 要放在 initLib 之后，或者某些 Businiess 初始化之后，所以也不能简单的封装方法，这样就会造成 onCreate 里的方法很多，顺序不能乱调整。</p>
<p>利用尾随闭包可以让代码更加好看</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(callback: <span class="type">Callback</span>&lt;<span class="type">Unit</span>&gt;?)</span></span> &#123;</div><div class="line">  ...<span class="comment">//一些需要保证优先初始化的操作</span></div><div class="line">  callback?invoke()<span class="comment">//一些不需要保证顺序的初始化操作</span></div><div class="line">  ...<span class="comment">//一些需要在最后初始化的操作</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</div><div class="line">  init &#123;</div><div class="line">    <span class="comment">//一些不需要考虑顺序的初始化操作</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有一种比较典型的用法，就是异步方法调用。我们可以定义一个 UI 方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">UI</span><span class="params">(callback: <span class="type">Callback</span>&lt;<span class="type">Unit</span>&gt;)</span></span> &#123;</div><div class="line">  mainHandler.post(callback)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在调用的时候就可以很简单的写成</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">someFunction</span><span class="params">()</span></span> &#123;</div><div class="line">  ...<span class="comment">//doSomething</span></div><div class="line"></div><div class="line">  UI &#123;</div><div class="line">   ... <span class="comment">//UI Update</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="public-static-final-vs-top-level-function"><a href="#public-static-final-vs-top-level-function" class="headerlink" title="public static final vs top level function"></a>public static final vs top level function</h1><p>在 Java 时代，我们会定义很多工具类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemberCreator</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Member <span class="title">createMember</span><span class="params">(...)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对应在 kotlin 中的代码是</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemberCreator</span> </span>&#123;</div><div class="line">  <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">createMember</span><span class="params">(...)</span></span>: Member &#123;</div><div class="line">      ...</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种写法在 kotlin 中，实际上会生成一个 companion 的单例，在单例中实现 createMember 的成员方法。这就导致 createMember 变成了一个成员方法，在方法执行上会比 static 方法性能上要稍差。因此，在 kotlin，我们不需要再先定义一个 Utils class，而是直接使用 top level function</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//MemberCreator.kt</span></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createMember</span><span class="params">(...)</span></span>: Member &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="public-static-final-vs-extension"><a href="#public-static-final-vs-extension" class="headerlink" title="public static final vs extension"></a>public static final vs extension</h1><p>在更多情况下，Utils 类往往实现的是一个类的扩展，比如说</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DimenUtils</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="title">getDimenFromResource</span><span class="params">(Context context, @DimenRes <span class="keyword">int</span> dimenRes)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//使用</span></div><div class="line">DimenUtils.getDimenFromResoucce(context, R.dimen.xxx)</div></pre></td></tr></table></figure>
<p>而在 kotlin 中，我们可以使用 extension 实现更加优雅的使用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//定义</span></div><div class="line"><span class="function"><span class="keyword">fun</span> Context.<span class="title">dimen</span><span class="params">(<span class="meta">@DimenRes</span> resource: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = resources.getDimensionPixelSize(resource)</div><div class="line"></div><div class="line"><span class="comment">//使用</span></div><div class="line">context.dimen(R.dimen.xxx)</div></pre></td></tr></table></figure>
<h1 id="lateinit"><a href="#lateinit" class="headerlink" title="lateinit"></a>lateinit</h1><p>对于一个成员变量，在设计的过程中，我们认为他可能是非空的，但是不是在构造函数里初始化，而是某个方法调用之后初始化。例如context 的设置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;</div><div class="line">  <span class="comment">//在 java 中，只能通过注释等方式声明 context 肯定不为空</span></div><div class="line">  <span class="keyword">private</span> Context mContext;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">(Context conxt)</span> </span>&#123;</div><div class="line">    mContext = context</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//在 java 中，我们只能通过 assert 等方式来在 debug 时确保 setup 已经被调用了</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span>(<span class="string">"call setup before doSomething"</span>, mContext != <span class="keyword">null</span>)</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 kotlin 中，我们可以使用更为优雅的 lateinit 来实现</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;</div><div class="line">  <span class="keyword">lateinit</span> <span class="keyword">var</span> context: Context</div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">setup</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</div><div class="line">    <span class="keyword">this</span>.context = context</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过 lateinit 关键字，我们就可以通过函数声明了解到 context 肯定不为空，他必须在初始化后调用某些方法来初始化。额外的，在kotlin 1.2之后，还增加了 isInitialized 来动态判断 context 是否被初始化了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</div><div class="line">  assert(<span class="string">"call setup before doSomething"</span>, <span class="keyword">this</span>::context.isInitialized)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 dagger 中，所有的 inject 变量都不会为空，但是都是需要在调用 inject 方法之后才会赋值，因此所有的@Inject 变量都应该是 lateinit 变量，当然一些不支持 lateinit 的 primitive 变量除外。</p>
<h1 id="extends-vs-delegate"><a href="#extends-vs-delegate" class="headerlink" title="extends vs delegate"></a>extends vs delegate</h1><p>在 java 中，某些重复的方法我们会抽象到父类中来实现，出现很多 BaseActivity 之类的东西。但是随着项目的复杂，BaseActivity 里的代码会越来越多，继承一个 BaseActivity 的成本也会越来越大。比如可怕的 AppCompactActivity。kotlin 设计了一个叫做 delegate 的方案，解放了这种设计，让继承关系回归本源，父类就应该只包含针对业务的抽象。</p>
<p>比如我需要在 Activity 中实现RxJava的绑定机制，在 java 中可能就会出现一个 RxableActivity,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//RxableActivity.java</span></div><div class="line"><span class="keyword">public</span> abstarct <span class="class"><span class="keyword">class</span> <span class="title">RxableActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addBinder</span><span class="params">(...)</span> </span>&#123;</div><div class="line">    ...<span class="comment">//实现绑定配置</span></div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span> </span>&#123;</div><div class="line">    ...<span class="comment">//实现绑定</span></div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">unbind</span><span class="params">()</span> </span>&#123;</div><div class="line">    ...<span class="comment">//实现解绑</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是万一我又需要让 Activity 实现一些线程管理，比如有一个 ThreadActivity</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> abstarct <span class="class"><span class="keyword">class</span> <span class="title">ThreadActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">runOnWorkerThread</span><span class="params">(Runnable runnable)</span> </span>&#123;</div><div class="line">    ...<span class="comment">//在 worker 线程执行</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">unOnUIThread</span><span class="params">(Runnable runnable)</span> </span>&#123;</div><div class="line">    ...<span class="comment">//在 UI 线程执行</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这时候就尴尬了，要么就是修改 ThreadActivity 继承至 RxableActivity，或者反过来。但是无论怎么修改，都改变了父类的性质。</p>
<p>在 kotlin 中，我们可以利用 delegate 来实现这种需要多继承的场景</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">RxBinder</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">addBinder</span><span class="params">(...)</span></span></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">()</span></span></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">unbind</span><span class="params">()</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ThreadRunner</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">runOnWorkerThread</span><span class="params">(runnable: ()</span></span> -&gt; <span class="built_in">Unit</span>)</div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">runOnUIThread</span><span class="params">(runnable: ()</span></span> -&gt; <span class="built_in">Unit</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RxBinderImpl</span>: <span class="type">RxBinder &#123;</span></span></div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadRunnerImpl</span>: <span class="type">ThreadRunner &#123;</span></span></div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span>: <span class="type">ThreadRunner by ThreadRunnerImpl</span></span>(), RxBinder <span class="keyword">by</span> RxBinderImpl()</div></pre></td></tr></table></figure>
<h1 id="灵活运用-if-表达式"><a href="#灵活运用-if-表达式" class="headerlink" title="灵活运用 if 表达式"></a>灵活运用 if 表达式</h1><p>在 kotlin 中，if 可以作为一个表达式来使用，这在条件初始化的时候很有帮助。在 java 中，我们初始化一个局部变量可能是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">  String str;</div><div class="line">  <span class="keyword">if</span> (someCondition &gt; <span class="number">0</span>) &#123;</div><div class="line">    str = <span class="string">"condition &gt; 0"</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    str = <span class="string">"condition &lt;=0"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为 kotlin 中的 lateinit 不支持用在局部变量中，因此默认转化过来的代码会变成这样子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="keyword">var</span> str = <span class="string">""</span></div><div class="line">  <span class="keyword">if</span> (someCondition &gt; <span class="number">0</span>) &#123;</div><div class="line">    str = <span class="string">"condition &gt; 0"</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    str = <span class="string">"condition &lt;=0"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上我们不需要为 str 初始化一个空字符串，这个初始化完全没有意义。因此可以利用 if expression 来达到更优雅的初始化</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="comment">//甚至可以用到 val 来表明这个 str 不可变，增强了代码的健壮性</span></div><div class="line">  <span class="keyword">val</span> str = <span class="keyword">if</span> (somCondition &gt; <span class="number">0</span>) &#123; <span class="string">"condtion &gt; 0"</span> &#125; <span class="keyword">else</span> &#123; <span class="string">"condition &lt;=0"</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样的，如果 if else 条件太多，还可以用 when expression</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> str = <span class="keyword">when</span> &#123;</div><div class="line">  someCondition &gt; <span class="number">0</span> -&gt; <span class="string">"condtion &gt; 0"</span>,</div><div class="line">  someCondition = <span class="number">0</span> -&gt; <span class="string">"condtion == 0"</span>,</div><div class="line">  <span class="keyword">else</span> &#123; <span class="string">"condition &lt; 0"</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="优雅的使用-lamba-表达式"><a href="#优雅的使用-lamba-表达式" class="headerlink" title="优雅的使用 lamba 表达式"></a>优雅的使用 lamba 表达式</h1><p>kotlin 中，使用 lamba 表达式会使得方法的使用更为优雅得体。在 lamba 的使用中，如果只有一个参数，建议是不写，通过 it 来获取，让表达式看起来更简洁，比如</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//good:</span></div><div class="line"><span class="keyword">val</span> callback: Callback&lt;String&gt; = &#123;</div><div class="line">  println(<span class="string">"<span class="variable">$it</span>"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//bad:</span></div><div class="line"><span class="keyword">val</span> callback: Callback&lt;String&gt; = &#123; str -&gt;</div><div class="line">  println(<span class="string">"<span class="variable">$str</span>"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>省略的写法在 rxjava 中看起来更为简洁。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//只保留值为 true 的结果</span></div><div class="line">someBooleanObservable.filter(&#123; it &#125;).subscribe(...)</div></pre></td></tr></table></figure>
<p>当函数有两个以上的参数，但是我们只需要用到其中某些参数时，可以使用省略参数的写法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//good:</span></div><div class="line"><span class="keyword">val</span> callback: Callback&lt;String, <span class="built_in">Int</span>&gt; = &#123; _, value -&gt;</div><div class="line">  println(<span class="string">"<span class="variable">$value</span>"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//bad:</span></div><div class="line"><span class="keyword">val</span> callback: Callback&lt;String, <span class="built_in">Int</span>&gt; = &#123;ignore, value -&gt;</div><div class="line">  println(<span class="string">"<span class="variable">$value</span>"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mlazy.club/android-unit-test-with-jmocit-using-kotlin-in-practice.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mluffy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人小屋">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/android-unit-test-with-jmocit-using-kotlin-in-practice.html" itemprop="url">Android UnitTest with JMockit using Kotlin - In Practice</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-20T19:23:59+08:00">
                2017-12-20
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/android-unit-test-with-jmocit-using-kotlin-in-practice.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="android-unit-test-with-jmocit-using-kotlin-in-practice.html" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          
             <span id="/android-unit-test-with-jmocit-using-kotlin-in-practice.html" class="leancloud_visitors" data-flag-title="Android UnitTest with JMockit using Kotlin - In Practice">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上篇：<a href="/android-unit-test-with-jmocit-using-kotlin-api-guide.html" title="Android UnitTest with JMockit using Kotlin - API Guide">Android UnitTest with JMockit using Kotlin - API Guide</a> 里，我们列举了 JMockit 中一些常用的 api，及其用法，本篇主要是提出一些真实的项目场景，探讨如何利用上篇提到的 api 来实现单元测试。</p>
<h1 id="record-replay-verify"><a href="#record-replay-verify" class="headerlink" title="record-replay-verify"></a>record-replay-verify</h1><p>工欲善其事必先利其器，在开始编写单元测试前，我们需要先了解一般单元测试编写的基本规则，如何实现 APP 应用前先了解 MVC 架构是怎么回事，提前做好设计是一个道理。</p>
<p>通常来说，我们的一个 testcase 可以这么写：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">someTestMethod</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="comment">//1. 准备阶段：测试环境的初始化</span></div><div class="line">  ...</div><div class="line">  <span class="comment">//2. 执行阶段：测试代码的调用，一般是调用 public 方法</span></div><div class="line">  ...</div><div class="line">  <span class="comment">//3. 验证阶段：验证执行结果的正确性</span></div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这也是传说中的 Arrange, Act, Assert syntax（AAA）。<br>如同 MVC 一样，这只是一个指导思想。在实际的项目中，一个类的行为可能不只是单纯的输入输出，还有一些复杂的副作用（side-effect）。因此 JMockit 中，为了满足这样相对复杂的类，他提出了升级版的 AAA，利用 mock 实现基于行为的单元测试方法，即 record-replay-verify:</p>
<ol>
<li>record，在准备阶段，设定 mocked 对象的行为，以便代码执行可以达到预期的结果</li>
<li>replay，和 AAA 一致，执行需要测试的代码。</li>
<li>verify，在验证阶段，验证 mocked 对象是否已经执行了特定的方法，即被测试对象是否进行了某些动作，例如保存数据库等</li>
</ol>
<p>一个 record-replay-verify testcase 可以这么写：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">someTestMethod</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="comment">//1. record 阶段，使用 expectation 控制 mocked 对象的行为</span></div><div class="line">  <span class="keyword">object</span> : Expectations() &#123;</div><div class="line">    init &#123;</div><div class="line">      <span class="comment">//一些 mock 方法，相当于标记这些方法被 recorded，在执行的时候会匹配这些 recorded 方法，返回我们预期的结果</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//2. replay 阶段，执行需要测试的代码</span></div><div class="line"></div><div class="line">  <span class="comment">//3. verify 阶段，验证对象行为</span></div><div class="line">  <span class="keyword">object</span> : Verification() &#123;</div><div class="line">    init &#123;</div><div class="line">      <span class="comment">//验证 mocked 对象是否执行了某些方法，他们的顺序等等</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述testcase 中，1和3并不一定是必要的，他相当于 AAA 模式的补充。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>JMockit 基于传统的单元测试模式 AAA（准备-&gt;执行-&gt;验证），提出了 record-replay-verify 模式，他相当于 AAA 模式的增强。</li>
<li>其中 record 是对准备阶段的增强，使用 expectation 去控制 mocked 对象的行为，replay 阶段等价于执行阶段，verify 是对验证阶段的增强，通过 verification 去判断 mocked 对象的行为是否符合预期</li>
<li>record 和 verify 阶段并不是必须的，和具体的测试对象的实现有关</li>
<li>Expectations 的本质是<strong>记录方法，以及预期的结果</strong>。在 replay 阶段，会去匹配记录的方法，返回<strong>记录</strong>中的结果</li>
<li>Verification 的本质是<strong>验证mocked 对象的行为</strong>，检查 replay 阶段的执行过程是否符合预期</li>
</ol>
<h1 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h1><p>一般来说，单元测试是以 TDD（单元测试驱动）的方式进行的，用 TDD 的方式可以辅助我们思考整个功能的设计，明确类的边界和依赖。给已经写好的代码编写单元测试的投入产出比是不高的，一般适合给初次接触单元测试的新手来练练手。除非是当需要优化原有代码的时候，可以以此为契机补充单元测试，以此保证后续的修改不会引出其他问题。</p>
<h2 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h2><p>我们来模拟一遍 ServiceController 的设计及实现。在项目中，我们抽象了一个 service 层，用于实现相关的业务逻辑。因为不同的业务逻辑有其自己的生命周期，我们需要设计一套支持生命周期的业务层对象，以便业务层可以自由控制资源的持有和释放。</p>
<h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><p>基于以上的需求，我们可以抽象出一个 service 接口，他提供基本的生命周期<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IService</span> </span>&#123;</div><div class="line">  <span class="comment">//服务启动时调用，可以在这里初始化服务的各种资源</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span></div><div class="line">  <span class="comment">//服务器停止时调用，err 不为0时，说明是因为某些异常退出。比如账号在其他地点登录，和用户相关的服务需要停止</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">(err: <span class="type">Int</span>)</span></span></div><div class="line">  <span class="comment">//服务的优先级，因为处于同一周期里的服务可能会有多个，不同服务之间初始化可能有顺序要求，因此提供一个优先级的设定，以便满足此需求。在这里，我们提供默认的优先级，方便不需要设定顺序的实现类</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">priority</span><span class="params">()</span></span> = <span class="number">500</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接着，应该有个控制类，管理这些 service 的启动和释放，这个控制类本质上也属于一个 service，只是他的职责比较特殊，是控制其他业务模块的生命周期。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这里传入 set，是为了表明后续的服务调用顺序，和传入的 collection 顺序无关。</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceController</span></span>(serviceSet: Set&lt;IService&gt;): IService &#123;</div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span> &#123;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到这里，基本的服务层雏形就出来了。所有的业务模块，都实现 IService 的接口，以支持生命周期的管理。各自模块处理自己生命周期下的资源初始化和释放。另外，我们定义了 ServiceController，他是一个特殊的服务层模块，用于管理处于他管辖下的生命周期，外部通过管理 service controller 的生命周期，进而管理所有 service 的生命周期。</p>
<p>比如，用户登录后:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> userController = ServiceController(userServiceSet)</div><div class="line">userController.onStart()</div></pre></td></tr></table></figure></p>
<p>用户登出后：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">userController.onStop(<span class="number">0</span>)</div></pre></td></tr></table></figure></p>
<p>那么 ServiceController 的行为基本就可以明确下来：</p>
<ol>
<li>当服务启动时，调用自己所管辖的服务一起启动</li>
<li>当服务停止时，调用自己所管辖的服务一起停止</li>
<li>启动和停止的顺序依照 priority 来排序</li>
</ol>
<p>接下来就可以编写单元测试。先看 onStart 测试，当 controller.onStart()调用的时候，我们预期的行为是serviceSet 里的 service，按照优先级从高到低的顺序调用 onStart 方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">@RunWith(JMockit::class)</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceControllerTestExample</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">IService</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span></div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">(err: <span class="type">Int</span>)</span></span></div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">priority</span><span class="params">()</span></span> = <span class="number">500</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//待测试的 ServiceController</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ServiceController</span></span>(serviceSet: Set&lt;IService&gt;): IService &#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">val</span> orderSet: List&lt;IService&gt; = serviceSet.sortedByDescending &#123; it.priority() &#125;</div><div class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</div><div class="line">            orderSet.onEach &#123; it.onStart() &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">(err: <span class="type">Int</span>)</span></span> &#123;</div><div class="line">            orderSet.onEach &#123; it.onStop(err) &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> orderService: MutableList&lt;SimpleService&gt;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> controller: ServiceController</div><div class="line"></div><div class="line">    <span class="meta">@Before</span></div><div class="line">    <span class="comment">//测试准备阶段，准备好测试环境，待测试对象</span></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</div><div class="line">        orderService = ArrayList(<span class="number">10</span>)</div><div class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">10</span> downTo <span class="number">1</span>) &#123;</div><div class="line">            orderService.add(SimpleService(i))</div><div class="line">        &#125;</div><div class="line">        controller = ServiceController(orderService.toSet())</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onStartTest</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="comment">//record 阶段，定义 mocked 对象</span></div><div class="line">        <span class="keyword">val</span> anyService = SimpleService(<span class="number">0</span>)</div><div class="line">        <span class="comment">//让 SimpleService 变为 Partial Mocked 对象，使其方法调用可以被 recorded</span></div><div class="line">        <span class="keyword">object</span> : Expectations(SimpleService::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>) </span>&#123;</div><div class="line">            init &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//replay 阶段，执行测试代码</span></div><div class="line">        controller.onStart()</div><div class="line"></div><div class="line">        <span class="comment">//verify 阶段，验证输出</span></div><div class="line">        <span class="keyword">object</span> : VerificationsInOrder() &#123;</div><div class="line">            init &#123;</div><div class="line">                <span class="keyword">val</span> priorityList = ArrayList&lt;<span class="built_in">Int</span>&gt;(<span class="number">10</span>)</div><div class="line">                <span class="comment">//service 在 onStart 时，会调用 doSomething，参数是该 service 的 priority，我们把参数给 capture 下来，然后对比这个调用顺序是否符合预期</span></div><div class="line">                anyService.doSomething(withCapture(priorityList))</div><div class="line">                <span class="comment">//onStart 方法理应调用了10次，因为我们有10个 service</span></div><div class="line">                times = <span class="number">10</span></div><div class="line">                <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until <span class="number">10</span>) &#123;</div><div class="line">                    <span class="comment">//doSomething 参数调用的顺序应当符合10, 9, ..., 2, 1</span></div><div class="line">                    Assert.assertEquals(<span class="number">10</span> - i, priorityList[i])</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SimpleService</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> priority: <span class="built_in">Int</span>): IService &#123;</div><div class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</div><div class="line">            <span class="comment">//因为 verification 无法验证同一个方法的调用顺序，因此我们需要通过其他额外的手段验证</span></div><div class="line">            doSomething(priority())</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">(err: <span class="type">Int</span>)</span></span> &#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">priority</span><span class="params">()</span></span>: <span class="built_in">Int</span> = priority</div><div class="line"></div><div class="line">        <span class="comment">//这里 Int 必须是 option 的，因为 withCapture 返回的是一个 null</span></div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">(priority: <span class="type">Int</span>?)</span></span> &#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上述的例子中，用了一些小技巧。因为在 JMockit 中，同一个 class 的不同实例的同一方法，其 signature 是一样的，即 JMockit 是不能区分方法调用是不是来自不同的实例，也就是说，在<code>Verifications</code>中，我们是无法直接verify：<code>不同的 service 实例，按照特定的顺序调用了 onStart 方法</code>，即<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">object</span> : Verifications() &#123;</div><div class="line">  init &#123;</div><div class="line">    <span class="keyword">for</span> (s <span class="keyword">in</span> orderService) &#123;</div><div class="line">      s.onStart()</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样的实现是验证不到的，会提示 <code>unexpect method invoke</code></p>
<p>因此我们利用在 verify 中可以验证调用参数的特性，在 SimpleService 的 onStart 实现中，让其调用一个函数，参数为该 service 的 priority，然后通过 withCapture 捕获到所有的参数，对比参数的调用顺序，即能从侧面验证，service 是不是按照优先级去执行了。</p>
<p>至于 onStop 方法，原理都是类似的，这里就不再赘述。</p>
<p>另外，ServiceController 是在单元测试编写完之后才实现的，这里强调实现顺序，主要是想说明单元测试是一个辅助设计、保障质量的方法，保障质量总所周知，而辅助设计就是 TDD 的核心概念，通过先编写单元测试，你就能够明白实现类的输入和输出，边界条件，在先思考了这些之后，再去编写实现，自然事半功倍。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ol>
<li>写单元测试最好的时机是新功能或者是代码重构时，以 TDD 方式开发</li>
<li>record 实际上只能记录的是方法的调用，而不能区分是哪个实例执行的方法调用，因此需要验证不同实例对同一个方法的调用顺序时，需要另辟蹊径，利用 withCapture 或其他方式（比如自己写一个全局变量来记录调用顺序）来实现</li>
<li>单元测试是一个辅助设计、保障质量的方法，先编写单元测试，再写实现，可以让我们提前考虑好输入输出、边界条件，把以上信息想清楚后，编写效率自然有所提高。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mlazy.club/android-unit-test-with-jmocit-using-kotlin-api-guide.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mluffy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人小屋">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/android-unit-test-with-jmocit-using-kotlin-api-guide.html" itemprop="url">Android UnitTest with JMockit using Kotlin - API Guide</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-19T09:45:02+08:00">
                2017-12-19
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/android-unit-test-with-jmocit-using-kotlin-api-guide.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="android-unit-test-with-jmocit-using-kotlin-api-guide.html" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          
             <span id="/android-unit-test-with-jmocit-using-kotlin-api-guide.html" class="leancloud_visitors" data-flag-title="Android UnitTest with JMockit using Kotlin - API Guide">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是一篇有关 JMockit 常用API的介绍，以及在 kotlin 中的一些注意事项。此文章是基于 JMockit 1.37版本，Kotlin 1.2版本编写的。</p>
<p><a href="http://jmockit.org/tutorial" target="_blank" rel="external">JMockit tutorial</a>其实写得很详细了，这里只是把平常在项目中用到的方式列举出来详细说明，以及官网上没提到的 kotlin 下的一些坑。所以这里算是个导读，想要精通，还是建议把 <a href="http://jmockit.org/tutorial" target="_blank" rel="external">tutorial</a> 看完。</p>
<h1 id="Annoation"><a href="#Annoation" class="headerlink" title="Annoation"></a>Annoation</h1><h2 id="Mocked"><a href="#Mocked" class="headerlink" title="Mocked"></a>Mocked</h2><p>这个对象的实例是由 JMockit 生成的，标记了<code>@Mocked</code>之后，当前 context 下的所有该类的对象，都会被使用相同的对象，所有的方法调用都不会再执行原有的实现。</p>
<p><code>@Mocked</code>有两种使用，对用不同的生效周期</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith(JMockit::class)</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockScope</span> </span>&#123;</div><div class="line">    <span class="comment">//声明为成员变量，则所有 MockScope 下的 test case，其 SomeClass 的实例都是一个 mocked 实例，所有方法调用都不是我们自己的实现</span></div><div class="line"><span class="comment">//    @Mocked lateinit var anyInstance: SomeClass</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> = <span class="number">1</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="comment">//每一个 test case 都可以声明不定长的参数，这些参数可以声明为@Mocked，@Injectable 等。其生效的周期和该 test case 生命周期一致</span></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test1</span><span class="params">(<span class="meta">@Mocked</span> mockInstance: <span class="type">SomeClass</span>)</span></span> &#123;</div><div class="line">        <span class="comment">//一个 mocked 实例返回的 int 值永远是0</span></div><div class="line">        Assert.assertEquals(<span class="number">0</span>, mockInstance.doSomething())</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test2</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="comment">//如果没有取消成员变量 anyInstance 的注释，则测试通过，取消注释后，instance.doSomething 返回的是0</span></div><div class="line">        <span class="keyword">val</span> instance = SomeClass()</div><div class="line">        Assert.assertEquals(<span class="string">"should be fail when uncommon anyInstance declaration"</span>, <span class="number">1</span>, instance.doSomething())</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Tested"><a href="#Tested" class="headerlink" title="Tested"></a>Tested</h2><p>Tested 是标记了一个对象是测试对象，如果没有初始化，他会根据构造函数自动生成对应的实例。参数的注入通过 Injectable 来配合，需要类型和名称都一一匹配，Injectable 会生成一个 mock 对象，详情参见下一小节。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith(JMockit::class)</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestedExample</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">var</span> value: <span class="built_in">Int</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">var</span> value2: <span class="built_in">Int</span> = <span class="number">0</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">var</span> value3: <span class="built_in">Int</span> = <span class="number">0</span></div><div class="line">        <span class="keyword">constructor</span>() &#123;</div><div class="line">            value = <span class="number">0</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">constructor</span>(value: <span class="built_in">Int</span>, value2: <span class="built_in">Int</span>): <span class="keyword">this</span>() &#123;</div><div class="line">            <span class="keyword">this</span>.value = value</div><div class="line">            <span class="keyword">this</span>.value2 = value2</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">constructor</span>(value: <span class="built_in">Int</span>, value2: <span class="built_in">Int</span>, value3: <span class="built_in">Int</span>): <span class="keyword">this</span>(value, value2) &#123;</div><div class="line">            <span class="keyword">this</span>.value3 = value3</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> = value</div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doSomething2</span><span class="params">()</span></span> = value2</div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doSomething3</span><span class="params">()</span></span> = value3</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="comment">//调用无参构造函数</span></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testDoSomethingWithoutParams</span><span class="params">(<span class="meta">@Tested</span> testInstance: <span class="type">SomeClass</span>)</span></span> &#123;</div><div class="line">        Assert.assertEquals(<span class="number">0</span>, testInstance.doSomething())</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="comment">//调用有两个参数的构造函数</span></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testDoSomethingWith2Prams</span><span class="params">(<span class="meta">@Tested</span> testInstance: <span class="type">SomeClass</span>, <span class="meta">@Injectable(value = <span class="meta-string">"102"</span>)</span> value2:<span class="type">Int</span>, <span class="meta">@Injectable(value = <span class="meta-string">"100"</span>)</span> value: <span class="type">Int</span>)</span></span> &#123;</div><div class="line">        Assert.assertEquals(<span class="number">100</span>, testInstance.doSomething())</div><div class="line">        Assert.assertEquals(<span class="number">102</span>, testInstance.doSomething2())</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="comment">//调用有三个参数的构造函数</span></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testDoSomethingWith3Prams</span><span class="params">(<span class="meta">@Tested</span> testInstance: <span class="type">SomeClass</span>, <span class="meta">@Injectable(value = <span class="meta-string">"102"</span>)</span> value2:<span class="type">Int</span>, <span class="meta">@Injectable(value = <span class="meta-string">"100"</span>)</span> value: <span class="type">Int</span>, <span class="meta">@Injectable(value = <span class="meta-string">"103"</span>)</span> value3: <span class="type">Int</span>)</span></span> &#123;</div><div class="line">        Assert.assertEquals(<span class="number">100</span>, testInstance.doSomething())</div><div class="line">        Assert.assertEquals(<span class="number">102</span>, testInstance.doSomething2())</div><div class="line">        Assert.assertEquals(<span class="number">103</span>, testInstance.doSomething3())</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="comment">//把 value3改为 value4，实际上会匹配到接收两个参数的构造函数，等价于 testInstance = SomeClass(100, 102)，value4是没有用到的</span></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testDoSomethingWithDifferentName</span><span class="params">(<span class="meta">@Tested</span> testInstance: <span class="type">SomeClass</span>, <span class="meta">@Injectable(value = <span class="meta-string">"102"</span>)</span> value2:<span class="type">Int</span>, <span class="meta">@Injectable(value = <span class="meta-string">"100"</span>)</span> value: <span class="type">Int</span>, <span class="meta">@Injectable(value = <span class="meta-string">"103"</span>)</span> value4: <span class="type">Int</span>)</span></span> &#123;</div><div class="line">        Assert.assertEquals(<span class="number">100</span>, testInstance.doSomething())</div><div class="line">        Assert.assertEquals(<span class="number">102</span>, testInstance.doSomething2())</div><div class="line">        Assert.assertEquals(<span class="number">0</span>, testInstance.doSomething3())</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>重点看最后一个 case，我们声明了一个 value4，没有匹配上 constructor，所以框架只找到两个匹配参数，因此调用了两个参数的构造函数。</p>
<h2 id="Injectable"><a href="#Injectable" class="headerlink" title="Injectable"></a>Injectable</h2><p>Injectable 是一个 mocked 对象，声明 Injectable 不会像 Mocked 一样，他只会影响被标记的对象。一般和@Tested 配合使用，作为依赖注入的参数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith(JMockit::class)</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InjectableExample</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> a: DependencyA) &#123;</div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">plus1</span><span class="params">()</span></span> = a.value() + <span class="number">1</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DependencyA</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">value</span><span class="params">()</span></span> = <span class="number">1</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testPlus1</span><span class="params">(<span class="meta">@Tested</span> testInstance: <span class="type">SomeClass</span>, <span class="meta">@Injectable</span> a: <span class="type">DependencyA</span>)</span></span> &#123;</div><div class="line">        <span class="comment">//a 是一个 mocked 对象，int 返回必定是0</span></div><div class="line">        Assert.assertEquals(<span class="number">0</span>, a.value())</div><div class="line">        <span class="comment">//a 是一个 mocked 对象，可以修改 value 的返回值</span></div><div class="line">        <span class="keyword">object</span> : Expectations() &#123;</div><div class="line">            init &#123;</div><div class="line">                a.value()</div><div class="line">                result = <span class="number">2</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//修改了 a.value 的结果，所以预期的结果是 2 + 1 = 3</span></div><div class="line">        Assert.assertEquals(<span class="number">3</span>, testInstance.plus1())</div><div class="line"></div><div class="line">        <span class="comment">//因为 Injectable 只是标识对应的实例是 mocked，不影响其他实例，所以生成一个新的 a，a.value()返回的是1</span></div><div class="line">        Assert.assertEquals(<span class="number">1</span>, DependencyA().value())</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testPlus1WithCustomCreation</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">val</span> a = DependencyA()</div><div class="line">        <span class="comment">//Mock 失败，因为a 不是一个 mock 对象</span></div><div class="line">        <span class="keyword">object</span> : Expectations() &#123;</div><div class="line">            init &#123;</div><div class="line">                a.value()</div><div class="line">                result = <span class="number">2</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">val</span> testInstance = SomeClass(a)</div><div class="line">        Assert.assertEquals(<span class="number">2</span>, testInstance.plus1())</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Mock"><a href="#Mock" class="headerlink" title="Mock"></a>Mock</h2><p>用于标记一个方法，声明这个方法是一个 mock 方法，是被 mocked 对象对应方法的实现。具体使用参见下面的<a href="#Faking">Faking</a>一节</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeLib</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> = <span class="number">1</span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FakeLog</span>: <span class="type">MockUp</span>&lt;<span class="type">Log</span>&gt;</span>() &#123;</div><div class="line">  <span class="meta">@Mock</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> = <span class="number">2</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>Annotation 可以声明成员变量，会影响所有该 test suit 下的所有 testcase</li>
<li>Annotation 可以声明单个 testcase 的方法参数，他仅在该 testcase 下生效</li>
<li>Mocked 是用于标记class 的，被标记的 class 下的所有对象都会变为 mocked 对象，所有调用方法都不再调用原有的实现。其生效周期参见第2点</li>
<li>Tested 是给一个测试对象增加声明，在没有初始化时，框架会帮助我们自动生成对象，一般配合 injectable 使用，类型和名称需要一一匹配</li>
<li>Injectable 可以认为是一个特殊的 Mocked 对象，他不同于 Mocked，只会对被标记的对象生效，被标记的对象会变为一个 mocked 对象</li>
<li>Mock 需要配合 MockUp 使用，一般用于 Mock 第三方库的方法。可以认为是Partical Mock 的另一种实现，当然他们的适用范围不同</li>
</ol>
<h1 id="Mocking"><a href="#Mocking" class="headerlink" title="Mocking"></a>Mocking</h1><h2 id="Expectation"><a href="#Expectation" class="headerlink" title="Expectation"></a>Expectation</h2><p>顾名思义，即重写一个对象的行为，让他符合我们的预期。 他只能用于一个 test case 中（即@Test 标记的 fun)</p>
<h3 id="通常使用"><a href="#通常使用" class="headerlink" title="通常使用"></a>通常使用</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith(JMockit::class)</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Expectation</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">methodToBeMock</span><span class="params">()</span></span> = <span class="number">1</span></div><div class="line">        <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</div><div class="line">            <span class="function"><span class="keyword">fun</span> <span class="title">staticFunction</span><span class="params">()</span></span> = <span class="number">110</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="comment">//在测试参数里，加了一个 companion 的 mock，这是kotlin 下 static function mock 的解决方案，详情参见下方 static function mock</span></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">mockInstanceExpectationTest</span><span class="params">(<span class="meta">@Mocked</span> mockInstance: <span class="type">SomeClass</span>, <span class="meta">@Mocked</span> <span class="keyword">companion</span>: <span class="type">SomeClass</span>.<span class="type">Companion</span>)</span></span> &#123;</div><div class="line">        <span class="comment">// 重写一个 mock 对象的返回值</span></div><div class="line">        <span class="keyword">object</span> : Expectations() &#123;</div><div class="line">            init &#123;</div><div class="line">                <span class="comment">//1. 调用一个对象的方法</span></div><div class="line">                mockInstance.methodToBeMock()</div><div class="line">                <span class="comment">//2. 重新定义返回值，当然返回类型必须和声明的一致，Unit 则不需要写</span></div><div class="line">                result = <span class="number">123</span></div><div class="line">                <span class="comment">//3. 设定 mock 生效次数，times = 1 则说明只生效一次，不写则不限定匹配次数</span></div><div class="line">                times = <span class="number">1</span></div><div class="line"></div><div class="line">                <span class="comment">//4. 也可以重写 static 方法</span></div><div class="line">                SomeClass.staticFunction()</div><div class="line">                result = <span class="number">1</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        assertEquals(<span class="number">123</span>, mockInstance.methodToBeMock()) <span class="comment">//测试通过</span></div><div class="line">        assertEquals(<span class="number">1</span>, SomeClass.staticFunction()) <span class="comment">// 测试通过</span></div><div class="line">        assertEquals(<span class="number">123</span>, mockInstance.methodToBeMock()) <span class="comment">//测试不通过，因为在 expectation 中只设定了 times = 1，第二次会抛出异常，Unexpected invocation</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="PartialMock"><a href="#PartialMock" class="headerlink" title="PartialMock"></a>PartialMock</h3><p>在默认情况下，Expectations 只能用于被标记为<code>@Mocked</code>的对象，当我们需要使用某个对象原有的方法，而部分方法又需要使用 mock 时，就需要使用到 partial mock 了。</p>
<p>partial mock 有两种使用方式，一个是把所有对象对应匹配的方法都 mock 了（MockingClass），另一种是只 mock 特定对象的方法（MockingInstnace）</p>
<p>我们先声明一个测试类，方便后续 demo 验证</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collaborator</span> </span>&#123;</div><div class="line">    <span class="keyword">val</span> mValue: <span class="built_in">Int</span></div><div class="line">    <span class="keyword">val</span> value: <span class="built_in">Int</span></div><div class="line">        <span class="keyword">get</span>() = mValue</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        mValue = <span class="number">-1</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(value: <span class="built_in">Int</span>) &#123;</div><div class="line">        mValue = value</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">simpleOperation</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">String</span>, c: <span class="type">Date</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">(b: <span class="type">Boolean</span>, s: <span class="type">String</span>)</span></span> &#123;</div><div class="line">            <span class="keyword">throw</span> IllegalStateException()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="MockingClass"><a href="#MockingClass" class="headerlink" title="MockingClass"></a>MockingClass</h4><p>在 expectation 的构造参数中，传入 class，则表明所有该 class 的对象，在 expectation 中声明的方法都会被mocked<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">partiallyMockingAClassAndItsInstances</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">//这里只是为了拿到一个实例，用于在 expectation 里使用，随便哪个实例都行，即使是后边拿来测试用的</span></div><div class="line">    <span class="keyword">val</span> anyInstance = Collaborator()</div><div class="line"></div><div class="line">    <span class="comment">//注意，这里必须用 class.java</span></div><div class="line">    <span class="keyword">object</span> : Expectations(Collaborator::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>) </span>&#123;</div><div class="line">        init &#123;</div><div class="line">            anyInstance.value</div><div class="line">            result = <span class="number">123</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 正常的构造，会调用我们的实现</span></div><div class="line">    <span class="keyword">val</span> c1 = Collaborator()</div><div class="line">    <span class="keyword">val</span> c2 = Collaborator(<span class="number">150</span>)</div><div class="line"></div><div class="line">    <span class="comment">// 以下调用了 mocked 的方法，即都会返回123</span></div><div class="line">    assertEquals(<span class="number">123</span>, c1.value)</div><div class="line">    assertEquals(<span class="number">123</span>, c2.value)</div><div class="line"></div><div class="line">    <span class="comment">// 调用没有在 expectation 中定义的方法，则会返回我们自己的实现</span></div><div class="line">    assertTrue(c1.simpleOperation(<span class="number">1</span>, <span class="string">"b"</span>, <span class="literal">null</span>))</div><div class="line">    assertEquals(<span class="number">45</span>, Collaborator(<span class="number">45</span>).mValue)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="MockingInstance"><a href="#MockingInstance" class="headerlink" title="MockingInstance"></a>MockingInstance</h4><p>在 expectation 的构造参数中，传入对象，则表明把该对象在 expectation 的方法给 mocked，不影响该类的其他实例<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">partiallyMockingASingleInstance</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> collaborator = Collaborator(<span class="number">2</span>)</div><div class="line">    <span class="comment">//构造参数中传入 collaborator 实例，表明只 mock 该对象</span></div><div class="line">    <span class="keyword">object</span> : Expectations(collaborator) &#123;</div><div class="line">        init &#123;</div><div class="line">            collaborator.value</div><div class="line">            result = <span class="number">123</span></div><div class="line">            collaborator.simpleOperation(<span class="number">1</span>, <span class="string">""</span>, <span class="literal">null</span>)</div><div class="line">            result = <span class="literal">false</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//static 方法的 mock 方式，详细说明参见 static function mock</span></div><div class="line">    <span class="keyword">object</span> : Expectations(Collaborator.Companion) &#123;</div><div class="line">        init &#123;</div><div class="line">            <span class="comment">// Static methods can be dynamically mocked too.</span></div><div class="line">            Collaborator.doSomething(anyBoolean, <span class="string">"test"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 调用 collaborator 对象的对应方法，都会使用 mocked 的结果</span></div><div class="line">    assertEquals(<span class="number">123</span>, collaborator.value)</div><div class="line">    assertFalse(collaborator.simpleOperation(<span class="number">1</span>, <span class="string">""</span>, <span class="literal">null</span>))</div><div class="line">    Collaborator.doSomething(<span class="literal">true</span>, <span class="string">"test"</span>)</div><div class="line"></div><div class="line">    <span class="comment">// 调用没有在 expectation 中的方法，还是正常的</span></div><div class="line">    assertEquals(<span class="number">2</span>, collaborator.mValue)</div><div class="line"></div><div class="line">    <span class="comment">// 用其他实例调用 mocked 方法，还是返回该对象正常的实现</span></div><div class="line">    assertEquals(<span class="number">45</span>, Collaborator(<span class="number">45</span>).mValue)</div><div class="line">    assertEquals(<span class="number">-1</span>, Collaborator().value)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="static-function-mock"><a href="#static-function-mock" class="headerlink" title="static function mock"></a>static function mock</h3><p>kotlin class 的 companion mock 和 java 的 static mock 有些不同，我们需要 mock 的是 Companion 这个 class</p>
<p>java 版<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Expectations(collaborator) &#123;&#123;</div><div class="line">    collaborator.getValue(); result = <span class="number">123</span>;</div><div class="line">    collaborator.simpleOperation(<span class="number">1</span>, <span class="string">""</span>, <span class="keyword">null</span>); result = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Static methods can be dynamically mocked too.</span></div><div class="line">    Collaborator.doSomething(anyBoolean, <span class="string">"test"</span>);</div><div class="line">&#125;&#125;;</div></pre></td></tr></table></figure></p>
<p>Kotlin 版<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> collaborator = Collaborator(<span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="keyword">object</span> : Expectations(collaborator) &#123;</div><div class="line">    init &#123;</div><div class="line">        collaborator.value</div><div class="line">        result = <span class="number">123</span></div><div class="line">        collaborator.simpleOperation(<span class="number">1</span>, <span class="string">""</span>, <span class="literal">null</span>)</div><div class="line">        result = <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">object</span> : Expectations(Collaborator.Companion) &#123;</div><div class="line">    init &#123;</div><div class="line">        <span class="comment">// Static methods can be dynamically mocked too.</span></div><div class="line">        Collaborator.doSomething(anyBoolean, <span class="string">"test"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>即使加了 JvmStatic 也不行，因为在 kotlin 中，还是会在内部初始化一个 companion object，然后实现放在 companion object 中。代码会类似这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@JvmStatic</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">boolean</span> b, @NotNull String s)</span> </span>&#123;</div><div class="line">   Intrinsics.checkParameterIsNotNull(s, <span class="string">"s"</span>);</div><div class="line">   Companion.doSomething(b, s);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Companion</span> </span>&#123;</div><div class="line">   <span class="meta">@JvmStatic</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">boolean</span> b, @NotNull String s)</span> </span>&#123;</div><div class="line">      Intrinsics.checkParameterIsNotNull(s, <span class="string">"s"</span>);</div><div class="line">      <span class="keyword">throw</span> (Throwable)(<span class="keyword">new</span> IllegalStateException());</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Companion</span><span class="params">()</span> </span>&#123;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// $FF: synthetic method</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Companion</span><span class="params">(DefaultConstructorMarker $constructor_marker)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以我们的 PartialMock 对象，需要从 colloborator 改为 colloborator.Companion</p>
<p>如果 Colloborator 是一个 java class，则 static 方法还是我们熟知的 static 方式实现，因此 mock 还是按照普通的方式声明：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> collaborator = Collaborator(<span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="keyword">object</span> : Expectations(collaborator) &#123;</div><div class="line">    init &#123;</div><div class="line">        collaborator.value</div><div class="line">        result = <span class="number">123</span></div><div class="line">        collaborator.simpleOperation(<span class="number">1</span>, <span class="string">""</span>, <span class="literal">null</span>)</div><div class="line">        result = <span class="literal">false</span></div><div class="line">        <span class="comment">// Static methods can be dynamically mocked too.</span></div><div class="line">        Collaborator.doSomething(anyBoolean, <span class="string">"test"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Verification"><a href="#Verification" class="headerlink" title="Verification"></a>Verification</h2><p>用于验证 mock 对象是否调用了特定的方法。只能是 mock 对象才能使用。一般是用来验证那些无返回的或者逻辑相对复杂的方法，通过是否调用某个方法来验证测试是否通过。<br>使用方式和 expectation 类似，只是需要放到方法调用之后。</p>
<p>Verification 有两类，一类是验证顺序的（VerificationInOrder, FullVerificationInOrder），另一类是不验证顺序的（Verification，FullVerification）。其中Full 开头的方法，验证方式很严格，必须所有的调用顺序都匹配上才行，少写一个都不可以，所以一般很少用到，因为通常我们只需要关注关键方法是否被调用到就好了</p>
<p>以下例子包含了 Verification，VerificationInOrder, FullVerificationInOrder 三种用法<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith(JMockit::class)</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">VerificationExample</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span></span>(<span class="keyword">val</span> context: Context) &#123;</div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</div><div class="line">            Log.e(<span class="string">"error"</span>, <span class="string">"some thing happened"</span>)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doOtherThing</span><span class="params">()</span></span> &#123;</div><div class="line">            Log.d(<span class="string">"tag"</span>, <span class="string">"some log"</span>)</div><div class="line">            context.startActivity(Intent())</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doMoreThing</span><span class="params">()</span></span> &#123;</div><div class="line">            context.sendBroadcast(Intent())</div><div class="line">            Log.d(<span class="string">"tag"</span>, <span class="string">"some log"</span>)</div><div class="line">            context.startActivity(Intent())</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">callSomething</span><span class="params">()</span></span> &#123;</div><div class="line">            UtilsClass.doSomething()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UtilsClass</span> </span>&#123;</div><div class="line">        <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</div><div class="line">            <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> = <span class="number">1</span></div><div class="line">            <span class="function"><span class="keyword">fun</span> <span class="title">doSomething2</span><span class="params">()</span></span> = <span class="number">2</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Injectable</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> anyContext: Context</div><div class="line">    <span class="comment">//必须要包含@Mocked anyLog: Log，这样才能让 Log 里的所有方法被 mocked，Verification 才能生效</span></div><div class="line">    <span class="meta">@Mocked</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> anyLog: Log</div><div class="line">    <span class="meta">@Tested</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> testInstance: SomeClass</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testDoSomething</span><span class="params">()</span></span> &#123;</div><div class="line">        testInstance.doSomething()</div><div class="line">        <span class="keyword">object</span> : Verifications() &#123;</div><div class="line">            init &#123;</div><div class="line">                Log.e(<span class="string">"error"</span>, anyString)</div><div class="line">                times = <span class="number">1</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testDoOtherThing</span><span class="params">(<span class="meta">@Mocked</span> anyIntent: <span class="type">Intent</span>)</span></span> &#123;</div><div class="line">        testInstance.doOtherThing()</div><div class="line">        <span class="comment">//测试方法的调用顺序，可以不包含所有的方法调用</span></div><div class="line">        <span class="keyword">object</span> : VerificationsInOrder() &#123;</div><div class="line">            init &#123;</div><div class="line">                Log.d(anyString, anyString)</div><div class="line">                times = <span class="number">1</span></div><div class="line">                anyContext.startActivity(any <span class="keyword">as</span> Intent?)</div><div class="line">                times = <span class="number">1</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//测试都调用了哪些方法，不需要理会顺序</span></div><div class="line">        <span class="keyword">object</span> : Verifications() &#123;</div><div class="line">            init &#123;</div><div class="line">                anyContext.startActivity(any <span class="keyword">as</span> Intent?)</div><div class="line">                times = <span class="number">1</span></div><div class="line">                Log.d(anyString, anyString)</div><div class="line">                times = <span class="number">1</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="comment">//测试方法的调用顺序，必须包含所有的方法调用。一般很少用到这个方式测试</span></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testDoMoreThing</span><span class="params">(<span class="meta">@Mocked</span> anyIntent: <span class="type">Intent</span>)</span></span> &#123;</div><div class="line">        testInstance.doMoreThing()</div><div class="line">        <span class="keyword">object</span> : FullVerificationsInOrder() &#123;</div><div class="line">            init &#123;</div><div class="line">                <span class="comment">//里面的任何方法调用都需要写，否则测试不通过</span></div><div class="line">                Intent()</div><div class="line">                anyContext.sendBroadcast(any <span class="keyword">as</span> Intent?)</div><div class="line">                Log.d(anyString, anyString)</div><div class="line">                Intent()</div><div class="line">                anyContext.startActivity(any)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="comment">//PartialMock 的对象，也可以 verify</span></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testWithPartialMock</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">object</span> : Expectations(UtilsClass.Companion) &#123;</div><div class="line">            init &#123;</div><div class="line">                UtilsClass.doSomething()</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        testInstance.callSomething()</div><div class="line">        <span class="keyword">object</span> : VerificationsInOrder() &#123;</div><div class="line">            init &#123;</div><div class="line">                UtilsClass.doSomething()</div><div class="line"><span class="comment">//                UtilsClass.doSomething2() //doSomething2虽然没有被 mock，但是也可以支持 verify 了</span></div><div class="line">                times = <span class="number">1</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>verification 的 block 里，填写的是非 mocked 对象时，测试实际上是通过的，因为是非 mocked 对象，不记录在验证的 record 里，相当于写了一个空的 block。所以在编写 verification 时，先故意写一个错误的验证（比如加 times = 100），如果验证通过，说明 verification 没有写对。</li>
<li>Fake对象是不能拿来 verify 的，想要 verify，只能通过 mocked 声明或者 partial mock</li>
</ol>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ol>
<li>可以利用 expectation 来实现 mock 方法，重新定义返回值</li>
<li>partial mock 可以支持对一个 class 或者一个实例进行部分 mock，没有 mock 的部分仍然会调用原有实现</li>
<li>想要在 expectation 中 mock 方法，对应的对象必须是 mock 的，或者是个 static 方法</li>
<li>static 方法在 kotlin 中，实际上要改为 mock Companion 这个class</li>
<li>Verification 有两类，一类是只验证方法是否被调用，另一类是较为严格，要验证方法的调用顺序</li>
<li>Verification 的 block 里必须是 mocked 对象，非 mocked 对象不生效</li>
</ol>
<h1 id="Faking"><a href="#Faking" class="headerlink" title="Faking"></a>Faking</h1><p>顾名思义，欺骗，就是提供一个假的实现，其实和 partial mock 作用有些类似，但是和 mocked 不同的是，fake 对象不会被 record，也就是在 verification 里是无法使用的。一般来说，fake class 多用于第三方库，android 的 class等不需要进行测试的对象，是可复用的。因为和 mocking 是类似的，所以需要在前期和团队声明好，fake 应当仅用于external library，避免和 mock 用法混淆。</p>
<p>fake 可以用于@before，@beforeClass，属于在 test 初始化的一部分，而 mock 是跟随 test case 的，我们也可以把他们通过生命周期分隔开</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith(JMockit::class)</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FakeExample</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> = Utils.doSomething()</div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doOtherThing</span><span class="params">()</span></span> = Utils().doOtherThing()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Utils</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doOtherThing</span><span class="params">()</span></span> = <span class="number">2</span></div><div class="line">        <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</div><div class="line">            <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> = <span class="number">1</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//fake 一个成员方法</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FakeUtils</span>: <span class="type">MockUp</span>&lt;<span class="type">Utils</span>&gt;</span>() &#123;</div><div class="line">        <span class="meta">@Mock</span></div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doOtherThing</span><span class="params">()</span></span> = <span class="number">22</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//fake 一个 Companion 方法，因为 class 是一个 kotlin class，因此需要 fake 的是Companion，这和 Kotlin 生成的 java 代码相关，和 Mock 一个 static 方法类似</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FakeUtilsCompanion</span>: <span class="type">MockUp</span>&lt;<span class="type">Utils.Companion</span>&gt;</span>() &#123;</div><div class="line">        <span class="meta">@Mock</span></div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> = <span class="number">11</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//因为 Log 是 java 实现，所以 static 方法我们可以按照官网的例子去 fake</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FakeLog</span>: <span class="type">MockUp</span>&lt;<span class="type">Log</span>&gt;</span>() &#123;</div><div class="line">        <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</div><div class="line">            <span class="meta">@JvmStatic</span></div><div class="line">            <span class="meta">@Mock</span></div><div class="line">            <span class="function"><span class="keyword">fun</span> <span class="title">e</span><span class="params">(tag: <span class="type">String</span>, message: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</div><div class="line">                print(<span class="string">"log message = <span class="variable">$message</span>"</span>)</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</div><div class="line">        <span class="meta">@BeforeClass</span></div><div class="line">        <span class="meta">@JvmStatic</span></div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">setupClass</span><span class="params">()</span></span> &#123;</div><div class="line">            FakeUtils()</div><div class="line">            FakeUtilsCompanion()</div><div class="line">            FakeLog()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testFake</span><span class="params">(<span class="meta">@Tested</span> testInstance: <span class="type">SomeClass</span>)</span></span> &#123;</div><div class="line">        Log.e(<span class="string">"tag"</span>, <span class="string">"print a message in console!"</span>)</div><div class="line">        Assert.assertEquals(<span class="number">11</span>, testInstance.doSomething())</div><div class="line">        Assert.assertEquals(<span class="number">22</span>, testInstance.doOtherThing())</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><ol>
<li>Fake 一般用于 external library，相当于可复用的 mock。</li>
<li>我们定义 Fake 是在 test 初始化（@before, @beforeClass）时使用，和 mock 区别开来</li>
<li>Fake 实际上没有 record，因此不支持 verify</li>
<li>Fake 一个 static 方法时，和 mock 类似，需要看对应的 class 是 kotlin class 还是 java class，分别对应不同的方式。</li>
</ol>
<h1 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h1><ol>
<li>不要忘记在 class 前加上@RunWith(JMockit:class)，否则执行 testcase 的引擎不正确，导致各种 mock 无效</li>
</ol>
<p><a href="https://github.com/luhui/JMockitSampleInKotlin" target="_blank" rel="external">demo 源码地址</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mlazy.club/react-native-animation-anlaysis-summary.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mluffy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人小屋">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/react-native-animation-anlaysis-summary.html" itemprop="url">react-native 动画性能分析总结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-15T19:33:40+08:00">
                2017-12-15
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/react-native-animation-anlaysis-summary.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="react-native-animation-anlaysis-summary.html" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          
             <span id="/react-native-animation-anlaysis-summary.html" class="leancloud_visitors" data-flag-title="react-native 动画性能分析总结">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在文章 <a href="/react-native-animation-performance-tool-systrace.html" title="react-native 下，Android动画性能分析工具-systrace">react-native 下，Android动画性能分析工具-systrace</a> 中，发现在当前项目，动画的不流畅感不是因为丢帧的因素影响到的。接着猜测可能是 react-native 的动画实现可能存在权限，因此对比了<a href="/android-animation-principle.html" title="android 动画原理">android 动画原理</a>、<a href="/react-native-animated-principle.html" title="react-native animated 动画实现原理">react-native animated 动画实现原理</a>。但是发现两边的实现思路是雷同的，性能差别也不会太大。接着猜测是否是因为导航库在动画使用上出现问题，我们分析了<a href="/react-navigation-animation-principle.html" title="react-navigation 动画实现原理">react-navigation 动画实现原理</a>，发现其使用方法也没问题。总结发现，以上的分析中，主要是分析了动画频率是否出现了问题，并没有验证中间生成的画面是否是连续的，因此猜测可能是在 react-native 的动画中，中间帧的渲染是异常的，导致动画过程中，虽然没有丢帧，但是由于画面不是连续的，让人产生不流畅的错觉。</p>
<h1 id="画面过程分析"><a href="#画面过程分析" class="headerlink" title="画面过程分析"></a>画面过程分析</h1><p>由于转场动画只涉及到了 translationX，因此可以看看是否是 translationX 的值有异常导致的。那么我们需要分别对比在 native 下，使用 animator 的 translationX 方案以及使用 react-native animated 的 translationX 方案在计算值的过程中是否有差别。</p>
<p>native 层很简单，通过 updateListener 记录中间值即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@TargetApi</span>(Build.VERSION_CODES.KITKAT)</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> View view = <span class="keyword">new</span> View(<span class="keyword">this</span>);</div><div class="line">    view.setBackgroundColor(Color.BLUE);</div><div class="line">    <span class="keyword">final</span> FrameLayout container = (FrameLayout) findViewById(R.id.container);</div><div class="line">    FrameLayout.LayoutParams params = <span class="keyword">new</span> FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);</div><div class="line">    container.addView(view, params);</div><div class="line">    mLastTranlationX = container.getWidth();</div><div class="line">    view.setTranslationX(container.getWidth());</div><div class="line">    view.animate().translationX(<span class="number">0</span>).setDuration(<span class="number">1000</span>).setUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</div><div class="line">            <span class="keyword">float</span> between = view.getTranslationX() - mLastTranlationX;</div><div class="line">            mLastTranlationX = view.getTranslationX();</div><div class="line">            Log.e(<span class="string">"lh"</span>, mLastTranlationX + <span class="string">"\t"</span> + between);</div><div class="line">        &#125;</div><div class="line">    &#125;).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其 translationX 的曲线如下：</p>
<p><img src="/images/react-native-animation-anlaysis-summary/898E86818F9CCA69988C713497D399A0.jpg" alt="IMAGE"></p>
<p>react-native 层则需要依赖 react-native 的源码，通过在 BaseViewManager 中的 setTransform 方法中加个 log 来实现。<br>react-native 如何依赖源码，可以参考<a href="https://facebook.github.io/react-native/docs/android-building-from-source.html" target="_blank" rel="external">官方文档</a></p>
<p>其 translationX 的曲线如下：<br><img src="/images/react-native-animation-anlaysis-summary/5512FEFCFAA394ACB4A496C5E951777C.jpg" alt="IMAGE"></p>
<p>对比 native 方案，发现其 translationX 的曲线是不够平滑的</p>
<p>在 pop 时不流畅感比较明显的一次记录：</p>
<p><img src="/images/react-native-animation-anlaysis-summary/409299ADD3A9005B8338C5380A54BAD0.jpg" alt="IMAGE"></p>
<p>因此到这里，基本可以得出结论，造成动画不流畅的原因，是由于 react-native 在计算中间帧时，在 dip-&gt;pix 的计算过程中，出现精度丢失，导致画面不连续，造成动画不连续的错觉。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>react-native 在动画性能上和原生方案差距不大</li>
<li>react-native 的 animated value 都是自己计算的，由于 js 里是使用 dip，而在 native 层某些参数使用的是 pixel，在转换的过程中可能会造成精度丢失导致画面产生不连续感。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mlazy.club/react-navigation-animation-principle.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mluffy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人小屋">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/react-navigation-animation-principle.html" itemprop="url">react-navigation 动画实现原理</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-15T19:33:23+08:00">
                2017-12-15
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/react-navigation-animation-principle.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="react-navigation-animation-principle.html" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          
             <span id="/react-navigation-animation-principle.html" class="leancloud_visitors" data-flag-title="react-navigation 动画实现原理">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是android 动画性能分析系列文章中有关源码分析的最后一章，我们通过对比<a href="/android-animation-principle.html" title="android 动画原理">android 动画原理</a>以及<a href="/react-native-animated-principle.html" title="react-native animated 动画实现原理">react-native animated 动画实现原理</a>发现，两者的实现并无本质区别，其中的性能差距是可以预期的，不会与项目中出现的卡顿现象相关（部分高性能 android 机子上也出现了不流畅问题，反而低配置机子表现正常）。因此只能再看看项目中使用到的 react navigation，看看里边是如何使用的 Animated 源码。</p>
<h1 id="React-Navigation-的布局结构"><a href="#React-Navigation-的布局结构" class="headerlink" title="React Navigation 的布局结构"></a>React Navigation 的布局结构</h1><p>一个使用 StackNavigator 的布局，大概会是这样：<br>StackNavigator -&gt; CardStackTransitioner -&gt; Transitioner -&gt; CardStack -&gt; Card -&gt; SceneView -&gt; Component<br><img src="/images/react-navigation-animation-principle/1DDD56B3F959824C9ADDECC4829DCE4A.jpg" alt="ReactNative 动画流程__ReactNavigagtion 动画流程__StackNavigator 渲染流程_5.jpg"></p>
<ul>
<li>StackNavigator：类似于工厂类，提供上层的 api 接口，CardStackTransitioner 由它来构造</li>
<li>CardStackTransitioner：Transitioner 的渲染代理，提供动画的配置</li>
<li>Transitioner：动画执行类，侦听参数变化，执行动画。动画配置和视图渲染交由外部来实现</li>
<li>CardStack：管理导航层级</li>
<li>Card：作为一个 container，管理手势的处理（如右滑返回）</li>
<li>SceneView：简单的参数封装，通过 context 获取 navigation 参数，把 navigation 以及 screenProps传递给 Component</li>
<li>Component：我们自己的定义的 view</li>
</ul>
<p>从流程可以分析得到，动画相关的核心就在于 CardStackTransitioner。</p>
<h1 id="React-Navigation-动画实现原理"><a href="#React-Navigation-动画实现原理" class="headerlink" title="React Navigation 动画实现原理"></a>React Navigation 动画实现原理</h1><p>由 CardStackTransitioner 代码追踪，最终定位到整个动画配置就在 <code>TransitionerConfig.js</code>中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* @flow */</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> &#123; Animated, Easing, Platform &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> type &#123;</div><div class="line">  NavigationTransitionProps,</div><div class="line">  NavigationTransitionSpec,</div><div class="line">  TransitionConfig,</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'../../TypeDefinition'</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> CardStackStyleInterpolator <span class="keyword">from</span> <span class="string">'./CardStackStyleInterpolator'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> IOSTransitionSpec = (&#123;</div><div class="line">  duration: <span class="number">500</span>,</div><div class="line">  easing: Easing.bezier(<span class="number">0.2833</span>, <span class="number">0.99</span>, <span class="number">0.31833</span>, <span class="number">0.99</span>),</div><div class="line">  timing: Animated.timing,</div><div class="line">&#125;: NavigationTransitionSpec);</div><div class="line"></div><div class="line"><span class="comment">// Standard iOS navigation transition</span></div><div class="line"><span class="keyword">const</span> SlideFromRightIOS = (&#123;</div><div class="line">  transitionSpec: IOSTransitionSpec,</div><div class="line">  screenInterpolator: CardStackStyleInterpolator.forHorizontal,</div><div class="line">  containerStyle: &#123;</div><div class="line">    backgroundColor: <span class="string">'#000'</span>,</div><div class="line">  &#125;,</div><div class="line">&#125;: TransitionConfig);</div><div class="line"></div><div class="line"><span class="comment">//...其他配置</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultTransitionConfig</span>(<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  <span class="regexp">//</span> props for the new screen</span></span></div><div class="line"><span class="function"><span class="params">  transitionProps: NavigationTransitionProps,</span></span></div><div class="line"><span class="function"><span class="params">  <span class="regexp">//</span> props for the old screen</span></span></div><div class="line"><span class="function"><span class="params">  prevTransitionProps: ?NavigationTransitionProps,</span></span></div><div class="line"><span class="function"><span class="params">  <span class="regexp">//</span> whether we<span class="string">'re animating in/out a modal screen</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">  isModal: boolean</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">): TransitionConfig &#123;</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">  //...其他配置</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">  return SlideFromRightIOS;</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">&#125;</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string"></span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">function getTransitionConfig(</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">  transitionConfigurer?: (</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">    transitionProps: NavigationTransitionProps,</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">    prevTransitionProps: ?NavigationTransitionProps,</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">    isModal: boolean</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">  ) =&gt; TransitionConfig,</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">  // props for the new screen</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">  transitionProps: NavigationTransitionProps,</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">  // props for the old screen</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">  prevTransitionProps: ?NavigationTransitionProps,</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">  isModal: boolean</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">): TransitionConfig &#123;</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">  const defaultConfig = defaultTransitionConfig(</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">    transitionProps,</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">    prevTransitionProps,</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">    isModal</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">  );</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">  if (transitionConfigurer) &#123;</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">    return &#123;</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">      ...defaultConfig,</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">      ...transitionConfigurer(transitionProps, prevTransitionProps, isModal),</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">    &#125;;</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">  &#125;</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">  return defaultConfig;</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">&#125;</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string"></span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">export default &#123;</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">  defaultTransitionConfig,</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">  getTransitionConfig,</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">&#125;;</span></span></span></div></pre></td></tr></table></figure>
<p>因为我们项目中是 copy 了 iOS 的动画配置，让 android 也实现类似 iOS 的 push 效果，因此在这里我们只分析 <code>SlideFromRightIOS</code>是如何实现的。</p>
<p>其中 interpolation 是使用了 <code>CardStackStyleInterpolator</code> 的 <code>forHorizontal</code> 方法，来看看他里边是如何配置的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//CardStackStyleInterpolator.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">forHorizontal</span>(<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  props: NavigationSceneRendererProps</span></span></div><div class="line"><span class="function"><span class="params"></span>): <span class="title">AnimatedViewStyleProp</span> </span>&#123;</div><div class="line">  <span class="keyword">const</span> &#123; layout, position, scene &#125; = props;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!layout.isMeasured) &#123;</div><div class="line">    <span class="keyword">return</span> forInitial(props);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">const</span> interpolate = getSceneIndicesForInterpolationInputRange(props);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!interpolate) <span class="keyword">return</span> &#123; <span class="attr">opacity</span>: <span class="number">0</span> &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> &#123; first, last &#125; = interpolate;</div><div class="line">  <span class="keyword">const</span> index = scene.index;</div><div class="line">  <span class="comment">//设置从前一个视图到当前视图的动画效果，以及从当前视图进入下一个视图时，该视图的动画效果</span></div><div class="line">  <span class="keyword">const</span> opacity = position.interpolate(&#123;</div><div class="line">    inputRange: [first, first + <span class="number">0.01</span>, index, last - <span class="number">0.01</span>, last],</div><div class="line">    outputRange: ([<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0.85</span>, <span class="number">0</span>]: <span class="built_in">Array</span>&lt;number&gt;),</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> width = layout.initWidth;</div><div class="line">  <span class="comment">//利用 transform 的 translateX 来实现动画的左右滑动</span></div><div class="line">  <span class="comment">//first 是上一个页面的位置，index 是当前的位置，last 是下一个页面的位置</span></div><div class="line">  <span class="comment">//这个动画的含义为，A push B，则 B 的 transformX 是从 width 到0，A 的 transformX 是从0到 width*-0.3</span></div><div class="line">  <span class="comment">//B pop，则 B 的transfromX 是从 0 到 width，A 的 transformX 是从 width*-0.3到0</span></div><div class="line">  <span class="keyword">const</span> translateX = position.interpolate(&#123;</div><div class="line">    inputRange: ([first, index, last]: <span class="built_in">Array</span>&lt;number&gt;),</div><div class="line">    outputRange: I18nManager.isRTL</div><div class="line">      ? ([-width, <span class="number">0</span>, width * <span class="number">0.3</span>]: <span class="built_in">Array</span>&lt;number&gt;)</div><div class="line">      : ([width, <span class="number">0</span>, width * <span class="number">-0.3</span>]: <span class="built_in">Array</span>&lt;number&gt;),</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">const</span> translateY = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    opacity,</div><div class="line">    transform: [&#123; translateX &#125;, &#123; translateY &#125;],</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总的来说，整个动画的核心是利用当前页面的位置变化映射到 translationX 的变化中，实现push 和 pop 的动画效果</p>
<p>接着，动画是由 Transitioner 触发的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">//Transitioner.js</span></div><div class="line">  componentWillReceiveProps(nextProps: Props): <span class="keyword">void</span> &#123;</div><div class="line">  <span class="keyword">const</span> nextScenes = NavigationScenesReducer(</div><div class="line">    <span class="keyword">this</span>.state.scenes,</div><div class="line">    nextProps.navigation.state,</div><div class="line">    <span class="keyword">this</span>.props.navigation.state</div><div class="line">  );</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (nextScenes === <span class="keyword">this</span>.state.scenes) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> indexHasChanged =</div><div class="line">    nextProps.navigation.state.index !== <span class="keyword">this</span>.props.navigation.state.index;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._isTransitionRunning) &#123;</div><div class="line">    <span class="keyword">this</span>._queuedTransition = &#123; nextProps, nextScenes, indexHasChanged &#125;;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//props 变更，实际上就是页面发生变化了，执行转场动画</span></div><div class="line">  <span class="keyword">this</span>._startTransition(nextProps, nextScenes, indexHasChanged);</div><div class="line">&#125;</div><div class="line"></div><div class="line">_startTransition(</div><div class="line">  nextProps: Props,</div><div class="line">  nextScenes: <span class="built_in">Array</span>&lt;NavigationScene&gt;,</div><div class="line">  indexHasChanged: boolean</div><div class="line">) &#123;</div><div class="line">  <span class="keyword">const</span> nextState = &#123;</div><div class="line">    ...this.state,</div><div class="line">    scenes: nextScenes,</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> &#123; position, progress &#125; = nextState;</div><div class="line"></div><div class="line">  progress.setValue(<span class="number">0</span>);</div><div class="line"></div><div class="line">  <span class="keyword">this</span>._prevTransitionProps = <span class="keyword">this</span>._transitionProps;</div><div class="line">  <span class="keyword">this</span>._transitionProps = buildTransitionProps(nextProps, nextState);</div><div class="line"></div><div class="line">  <span class="comment">// get the transition spec.</span></div><div class="line">  <span class="comment">//这里通过外部拿到动画配置，目的是可以通过外部自定义动画参数。可以认为就是一个动画参数代理</span></div><div class="line">  <span class="keyword">const</span> transitionUserSpec = nextProps.configureTransition</div><div class="line">    ? nextProps.configureTransition(</div><div class="line">        <span class="keyword">this</span>._transitionProps,</div><div class="line">        <span class="keyword">this</span>._prevTransitionProps</div><div class="line">      )</div><div class="line">    : <span class="literal">null</span>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> transitionSpec = &#123;</div><div class="line">    ...DefaultTransitionSpec,</div><div class="line">    ...transitionUserSpec,</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> &#123; timing &#125; = transitionSpec;</div><div class="line">  <span class="keyword">delete</span> transitionSpec.timing;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> toValue = nextProps.navigation.state.index;</div><div class="line">  <span class="keyword">const</span> positionHasChanged = position.__getValue() !== toValue;</div><div class="line"></div><div class="line">  <span class="comment">// if swiped back, indexHasChanged == true &amp;&amp; positionHasChanged == false</span></div><div class="line">  <span class="keyword">const</span> animations =</div><div class="line">    indexHasChanged &amp;&amp; positionHasChanged</div><div class="line">      ? [</div><div class="line">          <span class="comment">//progress 只是为了标记当前动画的执行进度</span></div><div class="line">          timing(progress, &#123;</div><div class="line">            ...transitionSpec,</div><div class="line">            toValue: <span class="number">1</span>,</div><div class="line">          &#125;),</div><div class="line">          <span class="comment">//转场动画配置</span></div><div class="line">          timing(position, &#123;</div><div class="line">            ...transitionSpec,</div><div class="line">            toValue: nextProps.navigation.state.index,</div><div class="line">          &#125;),</div><div class="line">        ]</div><div class="line">      : [];</div><div class="line"></div><div class="line">  <span class="comment">// update scenes and play the transition</span></div><div class="line">  <span class="keyword">this</span>._isTransitionRunning = <span class="literal">true</span>;</div><div class="line">  <span class="keyword">this</span>.setState(nextState, () =&gt; &#123;</div><div class="line">    nextProps.onTransitionStart &amp;&amp;</div><div class="line">      nextProps.onTransitionStart(</div><div class="line">        <span class="keyword">this</span>._transitionProps,</div><div class="line">        <span class="keyword">this</span>._prevTransitionProps</div><div class="line">      );</div><div class="line">    Animated.parallel(animations).start(<span class="keyword">this</span>._onTransitionEnd);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过 <code>componentWillReceivePoprs</code> 来判断当前 index 是否改变，如果改变，则执行一次动画</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>React-Navigation 的 push/pop 动画，本质上是利用 index的变化，映射到 translationX 来实现的</li>
<li>动画的配置、视图的渲染由 CardStackTransitioner 来实现</li>
<li>具体的动画执行时机，有 Transitioner 来实现。Transitioner 利用 <code>componentWillReceiveProps</code> 来侦听当前 index 是否变化，从而决定是否要执行转场动画</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mlazy.club/react-native-animated-principle.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mluffy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人小屋">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/react-native-animated-principle.html" itemprop="url">react-native animated 动画实现原理</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-15T19:32:54+08:00">
                2017-12-15
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/react-native-animated-principle.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="react-native-animated-principle.html" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          
             <span id="/react-native-animated-principle.html" class="leancloud_visitors" data-flag-title="react-native animated 动画实现原理">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上篇：<a href="/android-animation-principle.html" title="android 动画原理">android 动画原理</a> 说到，要对比 android 本身的动画实现以及 react-native 的动画实现来对比分析。本篇主要分析 react-native 的 Animated 控件是如何实现动画的，包含 Animated 中使用 nativeDriver 的 native 层动画实现方案以及不使用 nativeDriver 的纯 JS 动画实现方案</p>
<p>P.S. 本篇源码分析是基于 react-native-0.47.2 进行解析的</p>
<h1 id="react-native-动画实现原理"><a href="#react-native-动画实现原理" class="headerlink" title="react-native 动画实现原理"></a>react-native 动画实现原理</h1><p>react-native 的动画也有两种方案，一种是纯 JS 方案，仅在 JS 层通过 <code>requestAnimationFrame</code> 来实现定时渲染，以此来实现动画。<br>另一种是 native 方案，在 js 层配置好视图（ AnimatedNode ）与数据（ AnimatedValue ）的绑定，再把配置信息以及动画信息传递给 native 层，由 native 层来实现动画，而 native 层则利用与原生Animator 相似的方案来执行动画。稍微有些区别的是，Animator 是直接针对 view 的属性进行更新，而 native 方案是通过更新 node 来实现的，native 方案几乎和 Animator 等价，区别是在于native 方案中间需要 findNode 之类的操作找到最终需要操作的 view，他们之间的性能差距取决于 react-native 对于布局的更新处理机制。<br>值得注意的是，虽然 native 方案利用了 Choreographer 来实现定时器，但如果系统版本不支持，则其使用自定义的 Handler 来实现，时间是17ms，而原生的 Choreographer，在不支持 VSYNC 的设备中，自定义的 handler 的间隔是10ms，因此在低版本（api &lt; 16, android 3.0以下）的设备上，react-native 的动画在 android 上可能不会很流畅。</p>
<p>建议先阅读<a href="http://www.alloyteam.com/2016/01/reactnative-animated/" target="_blank" rel="external">react-native animated 动画原理</a>，以此来对动画是如何实现的有个基本的认知，因为核心思路都是一致的，不同的只是在具体的环境中，如何对模块进行划分，模块之间如何通讯协作。</p>
<h2 id="纯-JS-的动画实现"><a href="#纯-JS-的动画实现" class="headerlink" title="纯 JS 的动画实现"></a>纯 JS 的动画实现</h2><p>动画的入口很多，比如 AnimatedComponent，或者手动 start 一个 animation，这里我们通过手动的 start animator 来分析整个流程，核心流程都是一致的，不同的入口只是在初始化配置的部分有些差异。</p>
<h3 id="js-层流程图"><a href="#js-层流程图" class="headerlink" title="js 层流程图"></a>js 层流程图</h3><p>先来核心的调用流程，了解其中涉及的模块。</p>
<p><img src="/images/react-native-animated-principle/1DC392BFD58B05CE38DEE4B2F20343B4.jpg" alt="ReactNative 动画流程__Animated 动画流程__AnimatedValue 流程_3.jpg"></p>
<p>在执行动画流程里，包含纯 js 流程（上半部分）和 native 流程（下半部分），这里我们只需要先关注上半部分的 js流程即可。</p>
<p>核心的通讯流程包含3个部分</p>
<ul>
<li>TimingAnimation: 执行动画的具体类，包括实现动画的周期，循环等等</li>
<li>AnimatedImplementation：Animated 的实现类。</li>
<li>AnimatedValue：动画数值的映射类，负责动画数值的更新，以及视图的更新。</li>
</ul>
<p>先由 AnimatedImplmentation 触发动画的开始，接着由 AnimatedValue 触发 TimingAnimation 开始执行动画，TimingAnimation 通过<code>requestAnimationFrame</code>来触发 <code>_onUpdate</code> 方法，<code>_onUpdate</code> 方法本质上是一个 delegate，由 AnimatedValue 来实现，相当于 TimingAnimation 触发动画渲染后，把渲染这个动作委托给 AnimatedValue 来实现，最终 AnimatedValue 通过 <code>_flush</code> 方法进行更新。<code>_flush</code>方法是通过 setNativeProps 的方式，直接操作 dom 进行view 的更新。</p>
<h2 id="Native-方案实现"><a href="#Native-方案实现" class="headerlink" title="Native 方案实现"></a>Native 方案实现</h2><p>Native 方案中，与 JS 方案不同的是，TimingAnimation 不控制动画的渲染频率了，而是从 AnimatedValue 中获取对应的 TAG（在 react-native 中，每一个 view 都有一个唯一的 tag 与之对应，和 android 里的 id 是一个道理），通过<code>startAnimatingNode</code>方法，把 animationConfig 和 tag 传给 <code>NativeAnimatedHelper</code>，由 <code>NativeAnimatedHelper</code> 调用 native 层的 <code>NativeAnimatedModule</code>，由 <code>NativeAnimatedModule</code> 在 native 层实现动画。</p>
<h3 id="native-层流程图"><a href="#native-层流程图" class="headerlink" title="native 层流程图"></a>native 层流程图</h3><p><img src="/images/react-native-animated-principle/50718B4E2D7D2CA7828B0CCA001E729D.jpg" alt="ReactNative 动画流程__Animated 动画流程__NativeAnimated 流程_4.jpg"><br>和原生方案类似，都是通过注册 frameCallback，在每一帧心跳到来时，执行视图的更新。</p>
<p>核心的通讯流程包含4个部分</p>
<ul>
<li>NativeAnimatedModule：对 js 层的接口，负责接收 js 层的 animate 信息，把信息添加到 operation 队列中，等待下一次frame 心跳触发。该模块同时负责实现循环心跳的侦听</li>
<li>ReactChoreographer：android 的 Choreographer 的一个封装，3.0版本以下使用自己的 handler 实现，间隔是17ms</li>
<li>NativeAnimatedNodesManager：负责遍历所有 AnimatedNode，通过 AnimationDriver 获取当前帧需要更新的值，然后调用 AnimatedNode 的 update 方法更新 Node</li>
<li>AnimatedNode：类似 Animator 中的 ValueAnimator，绑定 view 和 value，value 变更时更新 view</li>
</ul>
<h4 id="NativeAnimatedModule"><a href="#NativeAnimatedModule" class="headerlink" title="NativeAnimatedModule"></a>NativeAnimatedModule</h4><p><code>NativeAnimatedModule</code>有两个职责，一个是作为对 js 的接口，另一个是负责侦听心跳，执行队列中的操作。</p>
<p>以<code>startAnimatingNode</code>为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ReactMethod</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startAnimatingNode</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">int</span> animationId,</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">int</span> animatedNodeTag,</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">final</span> ReadableMap animationConfig,</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">final</span> Callback endCallback)</span> </span>&#123;</div><div class="line">  mOperations.add(<span class="keyword">new</span> UIThreadOperation() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(NativeAnimatedNodesManager animatedNodesManager)</span> </span>&#123;</div><div class="line">      animatedNodesManager.startAnimatingNode(</div><div class="line">        animationId,</div><div class="line">        animatedNodeTag,</div><div class="line">        animationConfig,</div><div class="line">        endCallback);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>NativeAnimatedModule</code> 在收到 js 请求后，并不立即执行对应的方法，而是封装为一 个<code>UIThreadOperation</code>，放到 <code>mOperations</code> 的队列里，等待 <code>ReactChoreagrapher</code> 的心跳触发。</p>
<p>该模块是通过在 callback 中进行递归调用实现的心跳侦听机制，代码调用流程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//1. 利用 LifeCircleEventlistener，在 HostActivity resume时 enqueueFrameCallback</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onHostResume</span><span class="params">()</span> </span>&#123;</div><div class="line">  enqueueFrameCallback();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//2. 向 ReactChoreographer postFameCallback，侦听下一个心跳</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueueFrameCallback</span><span class="params">()</span> </span>&#123;</div><div class="line">  Assertions.assertNotNull(mReactChoreographer).postFrameCallback(</div><div class="line">    ReactChoreographer.CallbackType.NATIVE_ANIMATED_MODULE,</div><div class="line">    mAnimatedFrameCallback);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//3. 在 AnimatedFrameCallback 的最后，直接postFrameCallback，通过递归实现循环侦听。Facebook 也觉得这样不好，但是他还没在这一块做优化</span></div><div class="line">  mAnimatedFrameCallback = <span class="keyword">new</span> GuardedFrameCallback(reactContext) &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFrameGuarded</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</div><div class="line">      <span class="comment">//3.1 lazy load NativeAnimatedNodeManager</span></div><div class="line">      <span class="keyword">if</span> (mNodesManager == <span class="keyword">null</span>) &#123;</div><div class="line">        UIManagerModule uiManager = getReactApplicationContext()</div><div class="line">          .getNativeModule(UIManagerModule.class);</div><div class="line">        mNodesManager = <span class="keyword">new</span> NativeAnimatedNodesManager(uiManager);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">//3.2 把 mReadyOperations 放到局部变量然后置空，这里是为了保证这一次 frameCallback 不会有其他 operation 添加进来，保证线程安全。因为这个 callback 是在主线程中执行的，js 接口是在 native ModuleThread 执行的</span></div><div class="line">      ArrayList&lt;UIThreadOperation&gt; operations;</div><div class="line">      <span class="keyword">synchronized</span> (mOperationsCopyLock) &#123;</div><div class="line">        operations = mReadyOperations;</div><div class="line">        mReadyOperations = <span class="keyword">null</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (operations != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = operations.size(); i &lt; size; i++) &#123;</div><div class="line">          <span class="comment">//3.3 在这里执行刚才 startAnimatingNode 的方法，实际上调用了 mNodeManager 的startAnimatingNode 方法</span></div><div class="line">          operations.get(i).execute(mNodesManager);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">//3.4 调用了 mNodeManager 的 startAnimatingNode 方法后，这里的值变为 true，因此最终会执行 mNodeManager 的 runUpdates 方法来执行动画更新</span></div><div class="line">      <span class="keyword">if</span> (mNodesManager.hasActiveAnimations()) &#123;</div><div class="line">        mNodesManager.runUpdates(frameTimeNanos);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// <span class="doctag">TODO:</span> Would be great to avoid adding this callback in case there are no active animations</span></div><div class="line">      <span class="comment">// and no outstanding tasks on the operations queue. Apparently frame callbacks can only</span></div><div class="line">      <span class="comment">// be posted from the UI thread and therefore we cannot schedule them directly from</span></div><div class="line">      <span class="comment">// @ReactMethod methods</span></div><div class="line">      <span class="comment">//3.5 再次post callback，递归实现循环心跳</span></div><div class="line">      Assertions.assertNotNull(mReactChoreographer).postFrameCallback(</div><div class="line">        ReactChoreographer.CallbackType.NATIVE_ANIMATED_MODULE,</div><div class="line">        mAnimatedFrameCallback);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div></pre></td></tr></table></figure>
<h4 id="ReactChoreographer"><a href="#ReactChoreographer" class="headerlink" title="ReactChoreographer"></a>ReactChoreographer</h4><p>ReactChoreographer 代码比较简单，它实际上是一个 proxy，真正的实现是 ChoreographerCompat</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ReactChoreographer.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">ReactChoreographer</span><span class="params">()</span> </span>&#123;</div><div class="line">  mChoreographer = ChoreographerCompat.getInstance();</div><div class="line">  mReactChoreographerDispatcher = <span class="keyword">new</span> ReactChoreographerDispatcher();</div><div class="line">  mCallbackQueues = <span class="keyword">new</span> ArrayDeque[CallbackType.values().length];</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mCallbackQueues.length; i++) &#123;</div><div class="line">    mCallbackQueues[i] = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//ChoreographerCompat.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">ChoreographerCompat</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (IS_JELLYBEAN_OR_HIGHER) &#123;</div><div class="line">    mChoreographer = getChoreographer();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    mHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="NativeAnimatedNodesManager"><a href="#NativeAnimatedNodesManager" class="headerlink" title="NativeAnimatedNodesManager"></a>NativeAnimatedNodesManager</h4><p>由 NativeAnimatedModule 的 frameCallback 可以看到，核心的代码便是 <code>startAnimatingNode</code>和<code>runUpdates</code></p>
<p>在 NativeAnimatedNodesManager 中，有两个 map，一个是 mUpdateNodes，这个是用于存储刚创建的 AnimatedNode 以及手动更新 animatedValue 的操作，mActiveAnimations用于存储正在执行的动画<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1. 在 nativeAnimatedModule 的 callback 中，startAnimatingNode,实际上是构造了一个 AnimatedNode，然后放到 mActiveAnimations 的 map 中</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startAnimatingNode</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">  <span class="keyword">int</span> animationId,</span></span></div><div class="line"><span class="function"><span class="params">  <span class="keyword">int</span> animatedNodeTag,</span></span></div><div class="line"><span class="function"><span class="params">  ReadableMap animationConfig,</span></span></div><div class="line"><span class="function"><span class="params">  Callback endCallback)</span> </span>&#123;</div><div class="line">  AnimatedNode node = mAnimatedNodes.get(animatedNodeTag);</div><div class="line">  <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> JSApplicationIllegalArgumentException(<span class="string">"Animated node with tag "</span> + animatedNodeTag +</div><div class="line">      <span class="string">" does not exists"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (!(node <span class="keyword">instanceof</span> ValueAnimatedNode)) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> JSApplicationIllegalArgumentException(<span class="string">"Animated node should be of type "</span> +</div><div class="line">      ValueAnimatedNode.class.getName());</div><div class="line">  &#125;</div><div class="line">  String type = animationConfig.getString(<span class="string">"type"</span>);</div><div class="line">  <span class="keyword">final</span> AnimationDriver animation;</div><div class="line">  <span class="keyword">if</span> (<span class="string">"frames"</span>.equals(type)) &#123;</div><div class="line">    animation = <span class="keyword">new</span> FrameBasedAnimationDriver(animationConfig);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"spring"</span>.equals(type)) &#123;</div><div class="line">    animation = <span class="keyword">new</span> SpringAnimation(animationConfig);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"decay"</span>.equals(type)) &#123;</div><div class="line">    animation = <span class="keyword">new</span> DecayAnimation(animationConfig);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> JSApplicationIllegalArgumentException(<span class="string">"Unsupported animation type: "</span> + type);</div><div class="line">  &#125;</div><div class="line">  animation.mId = animationId;</div><div class="line">  animation.mEndCallback = endCallback;</div><div class="line">  animation.mAnimatedValue = (ValueAnimatedNode) node;</div><div class="line">  mActiveAnimations.put(animationId, animation);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//2.遍历 mActiveAnimations，放到 mRunUpdateNodeList 中，然后执行 updateNodes 方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runUpdates</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</div><div class="line">  UiThreadUtil.assertOnUiThread();</div><div class="line">  <span class="keyword">boolean</span> hasFinishedAnimations = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="comment">//2.1 先保证 Node 的创建、人为的更新</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mUpdatedNodes.size(); i++) &#123;</div><div class="line">    AnimatedNode node = mUpdatedNodes.valueAt(i);</div><div class="line">    mRunUpdateNodeList.add(node);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Clean mUpdatedNodes queue</span></div><div class="line">  mUpdatedNodes.clear();</div><div class="line"></div><div class="line">  <span class="comment">//2.2 取得当前帧的动画值，放到更新队列里</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mActiveAnimations.size(); i++) &#123;</div><div class="line">    <span class="comment">//这个 AnimationDriver 是一个abstract class，具体的实现类是SpringAnimation 等，具体是哪个实现类要看在 js 里的动画配置，使用的是哪个类型的Animated</span></div><div class="line">    AnimationDriver animation = mActiveAnimations.valueAt(i);</div><div class="line">    <span class="comment">//通过 currentValue、toValue、时间函数、当前时间，计算下一个mAnimatedValue</span></div><div class="line">    animation.runAnimationStep(frameTimeNanos);</div><div class="line">    AnimatedNode valueNode = animation.mAnimatedValue;</div><div class="line">    mRunUpdateNodeList.add(valueNode);</div><div class="line">    <span class="keyword">if</span> (animation.mHasFinished) &#123;</div><div class="line">      hasFinishedAnimations = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//2.3 遍历 mRunUpdateNodeList，更新里边所有的 Node</span></div><div class="line">  updateNodes(mRunUpdateNodeList);</div><div class="line">  mRunUpdateNodeList.clear();</div><div class="line"></div><div class="line">  <span class="comment">// Cleanup finished animations. Iterate over the array of animations and override ones that has</span></div><div class="line">  <span class="comment">// finished, then resize `mActiveAnimations`.</span></div><div class="line">  <span class="comment">// 2.4 如果有动画结束了，找到对应结束的动画，回调 callback</span></div><div class="line">  <span class="keyword">if</span> (hasFinishedAnimations) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mActiveAnimations.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">      AnimationDriver animation = mActiveAnimations.valueAt(i);</div><div class="line">      <span class="keyword">if</span> (animation.mHasFinished) &#123;</div><div class="line">        WritableMap endCallbackResponse = Arguments.createMap();</div><div class="line">        endCallbackResponse.putBoolean(<span class="string">"finished"</span>, <span class="keyword">true</span>);</div><div class="line">        animation.mEndCallback.invoke(endCallbackResponse);</div><div class="line">        mActiveAnimations.removeAt(i);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//3. 执行 AnimatedNode 的更新。nodes 里实际上是一个无向图，通过 BFS（广度优先）的方式进行遍历 遍历这个图，对每个节点进行更新。nodes 的元素属于头结点，AnimatedNode.mchildren 属于子节点。核心思想就是先更新头结点，再更新子节点，最后再次更新头结点，最后一步是确保子节点对父节点的影响也更新了。</span></div><div class="line"><span class="comment">// 比如 nodes 有3个节点，n1，n2，n3，每个节点有一个子节点，n1的子节点n11，n2的子节点n22，n3的子节点n33，那么更新顺序就是 n1-&gt;n2-&gt;n3-&gt;n11-&gt;n22-&gt;n33-&gt;n1-&gt;n2-&gt;n3</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateNodes</span><span class="params">(List&lt;AnimatedNode&gt; nodes)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> activeNodesCount = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> updatedNodesCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="comment">// STEP 1.</span></div><div class="line">  <span class="comment">// BFS over graph of nodes. Update `mIncomingNodes` attribute for each node during that BFS.</span></div><div class="line">  <span class="comment">// Store number of visited nodes in `activeNodesCount`. We "execute" active animations as a part</span></div><div class="line">  <span class="comment">// of this step.</span></div><div class="line"></div><div class="line">  <span class="comment">//BFSColor 相当于标记当前遍历时的类型，主要是用于标记 node 是否已经被遍历过了（visited）。</span></div><div class="line">  mAnimatedGraphBFSColor++; <span class="comment">/* use new color */</span></div><div class="line">  <span class="keyword">if</span> (mAnimatedGraphBFSColor == AnimatedNode.INITIAL_BFS_COLOR) &#123;</div><div class="line">    <span class="comment">// value "0" is used as an initial color for a new node, using it in BFS may cause some nodes</span></div><div class="line">    <span class="comment">// to be skipped.</span></div><div class="line">    mAnimatedGraphBFSColor++;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//3.1 以 BFS 遍历整个图，计算所有的 node 个数（activeNodesCount），并给所有子节点标记 mActiveIncomingNode = 1</span></div><div class="line"></div><div class="line">  Queue&lt;AnimatedNode&gt; nodesQueue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line">  <span class="keyword">for</span> (AnimatedNode node : nodes) &#123;</div><div class="line">    <span class="keyword">if</span> (node.mBFSColor != mAnimatedGraphBFSColor) &#123;</div><div class="line">      node.mBFSColor = mAnimatedGraphBFSColor;</div><div class="line">      activeNodesCount++;</div><div class="line">      nodesQueue.add(node);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (!nodesQueue.isEmpty()) &#123;</div><div class="line">    AnimatedNode nextNode = nodesQueue.poll();</div><div class="line">    <span class="keyword">if</span> (nextNode.mChildren != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nextNode.mChildren.size(); i++) &#123;</div><div class="line">        AnimatedNode child = nextNode.mChildren.get(i);</div><div class="line">        child.mActiveIncomingNodes++;</div><div class="line">        <span class="keyword">if</span> (child.mBFSColor != mAnimatedGraphBFSColor) &#123;</div><div class="line">          child.mBFSColor = mAnimatedGraphBFSColor;</div><div class="line">          activeNodesCount++;</div><div class="line">          nodesQueue.add(child);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//3.2 以 BFS 遍历整个图，对访问到的每个 node 进行更新</span></div><div class="line">  <span class="comment">// STEP 2</span></div><div class="line">  <span class="comment">// BFS over the graph of active nodes in topological order -&gt; visit node only when all its</span></div><div class="line">  <span class="comment">// "predecessors" in the graph have already been visited. It is important to visit nodes in that</span></div><div class="line">  <span class="comment">// order as they may often use values of their predecessors in order to calculate "next state"</span></div><div class="line">  <span class="comment">// of their own. We start by determining the starting set of nodes by looking for nodes with</span></div><div class="line">  <span class="comment">// `mActiveIncomingNodes = 0` (those can only be the ones that we start BFS in the previous</span></div><div class="line">  <span class="comment">// step). We store number of visited nodes in this step in `updatedNodesCount`</span></div><div class="line"></div><div class="line">  mAnimatedGraphBFSColor++;</div><div class="line">  <span class="keyword">if</span> (mAnimatedGraphBFSColor == AnimatedNode.INITIAL_BFS_COLOR) &#123;</div><div class="line">    <span class="comment">// see reasoning for this check a few lines above</span></div><div class="line">    mAnimatedGraphBFSColor++;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// find nodes with zero "incoming nodes", those can be either nodes from `mUpdatedNodes` or</span></div><div class="line">  <span class="comment">// ones connected to active animations</span></div><div class="line">  <span class="comment">//遍历所有 node，找到所有头节点，把头节点添加到队列尾部。这里的目的是为了让所有子节点更新完毕后，再次更新头节点，因为有可能头节点会因为子节点的变动而有新的改变</span></div><div class="line">  <span class="keyword">for</span> (AnimatedNode node : nodes) &#123;</div><div class="line">    <span class="keyword">if</span> (node.mActiveIncomingNodes == <span class="number">0</span> &amp;&amp; node.mBFSColor != mAnimatedGraphBFSColor) &#123;</div><div class="line">      node.mBFSColor = mAnimatedGraphBFSColor;</div><div class="line">      updatedNodesCount++;</div><div class="line">      nodesQueue.add(node);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//BFS 的遍历顺序更新所有节点。</span></div><div class="line">  <span class="comment">// Run main "update" loop</span></div><div class="line">  <span class="keyword">while</span> (!nodesQueue.isEmpty()) &#123;</div><div class="line">    AnimatedNode nextNode = nodesQueue.poll();</div><div class="line">    nextNode.update();</div><div class="line">    <span class="keyword">if</span> (nextNode <span class="keyword">instanceof</span> PropsAnimatedNode) &#123;</div><div class="line">      <span class="comment">// Send property updates to native view manager</span></div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">//如果是 PropsAnimatedNode，通过 updateView 直接更新对应的参数</span></div><div class="line">        ((PropsAnimatedNode) nextNode).updateView(mUIImplementation);</div><div class="line">      &#125; <span class="keyword">catch</span> (IllegalViewOperationException e) &#123;</div><div class="line">          <span class="comment">// An exception is thrown if the view hasn't been created yet. This can happen because views are</span></div><div class="line">          <span class="comment">// created in batches. If this particular view didn't make it into a batch yet, the view won't</span></div><div class="line">          <span class="comment">// exist and an exception will be thrown when attempting to start an animation on it.</span></div><div class="line">          <span class="comment">//</span></div><div class="line">          <span class="comment">// Eat the exception rather than crashing. The impact is that we may drop one or more frames of the</span></div><div class="line">          <span class="comment">// animation.</span></div><div class="line">          FLog.e(ReactConstants.TAG, <span class="string">"Native animation workaround, frame lost as result of race condition"</span>, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (nextNode <span class="keyword">instanceof</span> ValueAnimatedNode) &#123;</div><div class="line">      <span class="comment">//把值回调给 js 层</span></div><div class="line">      <span class="comment">// Potentially send events to JS when the node's value is updated</span></div><div class="line">      ((ValueAnimatedNode) nextNode).onValueUpdate();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (nextNode.mChildren != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nextNode.mChildren.size(); i++) &#123;</div><div class="line">        AnimatedNode child = nextNode.mChildren.get(i);</div><div class="line">        child.mActiveIncomingNodes--;</div><div class="line">        <span class="comment">//没有遍历过的子节点，才添加到 nodeQueue 进行更新。这里是为了避免上一步，再次更新头节点时，又把子节点重新更新一遍</span></div><div class="line">        <span class="keyword">if</span> (child.mBFSColor != mAnimatedGraphBFSColor &amp;&amp; child.mActiveIncomingNodes == <span class="number">0</span>) &#123;</div><div class="line">          child.mBFSColor = mAnimatedGraphBFSColor;</div><div class="line">          updatedNodesCount++;</div><div class="line">          nodesQueue.add(child);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Verify that we've visited *all* active nodes. Throw otherwise as this would mean there is a</span></div><div class="line">  <span class="comment">// cycle in animated node graph. We also take advantage of the fact that all active nodes are</span></div><div class="line">  <span class="comment">// visited in the step above so that all the nodes properties `mActiveIncomingNodes` are set to</span></div><div class="line">  <span class="comment">// zero</span></div><div class="line">  <span class="keyword">if</span> (activeNodesCount != updatedNodesCount) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Looks like animated nodes graph has cycles, there are "</span></div><div class="line">      + activeNodesCount + <span class="string">" but toposort visited only "</span> + updatedNodesCount);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="AnimatedNode"><a href="#AnimatedNode" class="headerlink" title="AnimatedNode"></a>AnimatedNode</h4><p>从上边 <code>updateNodes</code> 的源码，我们可以看到，最终是调用 PropsAnimatedNode 的 updateView 来更新的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//PropsAnimatedNode.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">updateView</span><span class="params">(UIImplementation uiImplementation)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (mConnectedViewTag == -<span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Node has not been attached to a view"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//1. 根据不同的 AnimatedNode，生成需要更新的 props</span></div><div class="line">  JavaOnlyMap propsMap = <span class="keyword">new</span> JavaOnlyMap();</div><div class="line">  <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : mPropMapping.entrySet()) &#123;</div><div class="line">    <span class="meta">@Nullable</span> AnimatedNode node = mNativeAnimatedNodesManager.getNodeById(entry.getValue());</div><div class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Mapped property node does not exists"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node <span class="keyword">instanceof</span> StyleAnimatedNode) &#123;</div><div class="line">      ((StyleAnimatedNode) node).collectViewUpdates(propsMap);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node <span class="keyword">instanceof</span> ValueAnimatedNode) &#123;</div><div class="line">      propsMap.putDouble(entry.getKey(), ((ValueAnimatedNode) node).getValue());</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported type of node used in property node "</span> +</div><div class="line">          node.getClass());</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// <span class="doctag">TODO:</span> Reuse propsMap and stylesDiffMap objects - note that in subsequent animation steps</span></div><div class="line">  <span class="comment">// for a given node most of the time we will be creating the same set of props (just with</span></div><div class="line">  <span class="comment">// different values). We can take advantage on that and optimize the way we allocate property</span></div><div class="line">  <span class="comment">// maps (we also know that updating view props doesn't retain a reference to the styles object).</span></div><div class="line">  <span class="comment">//2. 执行 view 的更新</span></div><div class="line">  uiImplementation.synchronouslyUpdateViewOnUIThread(</div><div class="line">    mConnectedViewTag,</div><div class="line">    <span class="keyword">new</span> ReactStylesDiffMap(propsMap));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而在 UIImplementation 中，最终是调用了 NativeViewHierarchyManager.updateProperty 方法来更新 view 的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//UIImplementation.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synchronouslyUpdateViewOnUIThread</span><span class="params">(<span class="keyword">int</span> tag, ReactStylesDiffMap props)</span> </span>&#123;</div><div class="line">  UiThreadUtil.assertOnUiThread();</div><div class="line">  mOperationsQueue.getNativeViewHierarchyManager().updateProperties(tag, props);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 NativeViewHierachyManager 中，通过 tag 找到对应的 view manager，然后通过 setter，调用对应的方法。比如以 transform 为例，最终会调用到 BaseViewManager 中的 setTransform 方法。至于 ViewManager 如果通过 setter 代理实现的，后续再另开文章剖析里边的设计思路。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//NativeViewHierarchyManager.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">updateProperties</span><span class="params">(<span class="keyword">int</span> tag, ReactStylesDiffMap props)</span> </span>&#123;</div><div class="line">  UiThreadUtil.assertOnUiThread();</div><div class="line"></div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    ViewManager viewManager = resolveViewManager(tag);</div><div class="line">    View viewToUpdate = resolveView(tag);</div><div class="line">    viewManager.updateProperties(viewToUpdate, props);</div><div class="line">  &#125; <span class="keyword">catch</span> (IllegalViewOperationException e) &#123;</div><div class="line">    Log.e(TAG, <span class="string">"Unable to update properties for view tag "</span> + tag, e);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//BaseViewManager.java</span></div><div class="line"><span class="meta">@ReactProp</span>(name = PROP_TRANSFORM)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTransform</span><span class="params">(T view, ReadableArray matrix)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (matrix == <span class="keyword">null</span>) &#123;</div><div class="line">    resetTransformProperty(view);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    setTransformProperty(view, matrix);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>react-native 提供了在 js 层的纯动画实现，利用 requestAnimationFrame 来作为计时器，每个计时周期计算对应的值并更新相应的视图。</li>
<li>react-native 在 native 层使用了 Choreographer 作为计时器实现 nativeDriver，在 js 层把 animation 信息传到 native 层，由 native 层在主线程中更新 view，避免 js 层执行耗时任务导致动画卡顿。如果低于3.0版本，则使用自定义的 Handler，间隔为16ms 作为计时器。</li>
<li>react-native 的动画实现，其核心思想和 animator 是相似的，利用显示心跳，周期性的更新动画 View 的值，性能上的差距就在于view 的查找，style 到 view property 的转化上，和react-native 的布局机制相关</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.alloyteam.com/2016/01/reactnative-animated/" target="_blank" rel="external">react-native animated 动画原理</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mlazy.club/android-animation-principle.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mluffy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人小屋">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/android-animation-principle.html" itemprop="url">android 动画原理</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-15T19:10:58+08:00">
                2017-12-15
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/android-animation-principle.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="android-animation-principle.html" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          
             <span id="/android-animation-principle.html" class="leancloud_visitors" data-flag-title="android 动画原理">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一篇：<a href="/react-native-animation-performance-tool-systrace.html" title="react-native 下，Android动画性能分析工具-systrace">react-native 下，Android动画性能分析工具-systrace</a> 中，为了定位 react-native 项目中部分 android 机型动画效果不流畅问题，提到最终定位的结果是因为<code>画面不连续</code>导致的，实际上分析的过程并没有那么简单。我们通过<code>systrace</code>对比 demo 项目（RN实现及 native 实现），分析排查出动画不流畅不是因为丢帧，CPU 负债问题引起的，那么只能是 react-native 的动画实现有问题，为了定位问题点，需要对比 android 的动画实现及 react-native 的动画实现，通过对比双方实现的差一点来定位问题可能出现的位置。</p>
<p>因此，本篇主要是针对 android 的实现原理（api-26）进行解析。</p>
<h1 id="Android-动画原理"><a href="#Android-动画原理" class="headerlink" title="Android 动画原理"></a>Android 动画原理</h1><p>Android 的动画实现目前有两种，一种是古老的 Animation （3.0之前）方式，另一种是 Animator</p>
<p>Animation 是在 draw 方法中被使用的，那么看看 draw 方法里具体做了些什么事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//android-25源码，animation 实现方案</span></div><div class="line"><span class="comment">//View.java</span></div><div class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">draw</span><span class="params">(Canvas canvs, ViewGroup parent, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</div><div class="line">        <span class="comment">//...其他处理</span></div><div class="line"></div><div class="line">        <span class="keyword">final</span> Animation a = getAnimation();</div><div class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</div><div class="line">            more = applyLegacyAnimation(parent, drawingTime, a, scalingRequired);</div><div class="line">            concatMatrix = a.willChangeTransformationMatrix();</div><div class="line">            <span class="keyword">if</span> (concatMatrix) &#123;</div><div class="line">                mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;</div><div class="line">            &#125;</div><div class="line">            transformToApply = parent.getChildTransformation();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//...没有动画时的处理</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//...其他处理</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">applyLegacyAnimation</span><span class="params">(ViewGroup parent, <span class="keyword">long</span> drawingTime,</span></span></div><div class="line"><span class="function"><span class="params">            Animation a, <span class="keyword">boolean</span> scalingRequired)</span> </span>&#123;</div><div class="line">        Transformation invalidationTransform;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> flags = parent.mGroupFlags;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> initialized = a.isInitialized();</div><div class="line">        <span class="keyword">if</span> (!initialized) &#123;</div><div class="line">            <span class="comment">//初始化渲染区域，开始执行动画</span></div><div class="line">            a.initialize(mRight - mLeft, mBottom - mTop, parent.getWidth(), parent.getHeight());</div><div class="line">            a.initializeInvalidateRegion(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop);</div><div class="line">            <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span>) a.setListenerHandler(mAttachInfo.mHandler);</div><div class="line">            onAnimationStart();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> Transformation t = parent.getChildTransformation();</div><div class="line">        <span class="comment">//通过 getTransformation 来更新 t，具体如何更新的和 animation 的子类相关，最终调用的是 applyTransformation</span></div><div class="line">        <span class="keyword">boolean</span> more = a.getTransformation(drawingTime, t, <span class="number">1f</span>);</div><div class="line">        <span class="comment">//兼容代码，scalingRequired 是 mAttachInfo 里的，用来标识应用是否处于 compatible mode</span></div><div class="line">        <span class="keyword">if</span> (scalingRequired &amp;&amp; mAttachInfo.mApplicationScale != <span class="number">1f</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (parent.mInvalidationTransformation == <span class="keyword">null</span>) &#123;</div><div class="line">                parent.mInvalidationTransformation = <span class="keyword">new</span> Transformation();</div><div class="line">            &#125;</div><div class="line">            invalidationTransform = parent.mInvalidationTransformation;</div><div class="line">            a.getTransformation(drawingTime, invalidationTransform, <span class="number">1f</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            invalidationTransform = t;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (more) &#123;</div><div class="line">            <span class="keyword">if</span> (!a.willChangeBounds()) &#123;</div><div class="line">                <span class="comment">//大小没有改变时的渲染区域设定</span></div><div class="line">                <span class="keyword">if</span> ((flags &amp; (ViewGroup.FLAG_OPTIMIZE_INVALIDATE | ViewGroup.FLAG_ANIMATION_DONE)) ==</div><div class="line">                        ViewGroup.FLAG_OPTIMIZE_INVALIDATE) &#123;</div><div class="line">                    parent.mGroupFlags |= ViewGroup.FLAG_INVALIDATE_REQUIRED;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((flags &amp; ViewGroup.FLAG_INVALIDATE_REQUIRED) == <span class="number">0</span>) &#123;</div><div class="line">                    <span class="comment">// The child need to draw an animation, potentially offscreen, so</span></div><div class="line">                    <span class="comment">// make sure we do not cancel invalidate requests</span></div><div class="line">                    parent.mPrivateFlags |= PFLAG_DRAW_ANIMATION;</div><div class="line">                    parent.invalidate(mLeft, mTop, mRight, mBottom);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//大小改变后需要渲染的区域设定</span></div><div class="line">                <span class="keyword">if</span> (parent.mInvalidateRegion == <span class="keyword">null</span>) &#123;</div><div class="line">                    parent.mInvalidateRegion = <span class="keyword">new</span> RectF();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">final</span> RectF region = parent.mInvalidateRegion;</div><div class="line">                a.getInvalidateRegion(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop, region,</div><div class="line">                        invalidationTransform);</div><div class="line"></div><div class="line">                <span class="comment">// The child need to draw an animation, potentially offscreen, so</span></div><div class="line">                <span class="comment">// make sure we do not cancel invalidate requests</span></div><div class="line">                parent.mPrivateFlags |= PFLAG_DRAW_ANIMATION;</div><div class="line"></div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> left = mLeft + (<span class="keyword">int</span>) region.left;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> top = mTop + (<span class="keyword">int</span>) region.top;</div><div class="line">                parent.invalidate(left, top, left + (<span class="keyword">int</span>) (region.width() + .<span class="number">5f</span>),</div><div class="line">                        top + (<span class="keyword">int</span>) (region.height() + .<span class="number">5f</span>));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> more;</div><div class="line">    &#125;</div><div class="line">`</div></pre></td></tr></table></figure>
<p>Animator 是在具体的子类实现动画的更新的，比如 ValueAnimator 的源码，核心的更新代码在<code>doAnimationFrame</code>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ValueAnimator.java  Animator方案</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doAnimationFrame</span><span class="params">(<span class="keyword">long</span> frameTime)</span> </span>&#123;</div><div class="line">        AnimationHandler handler = AnimationHandler.getInstance();</div><div class="line">        <span class="comment">//确认是否已经结束动画了</span></div><div class="line">        <span class="keyword">if</span> (mLastFrameTime == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// First frame</span></div><div class="line">            handler.addOneShotCommitCallback(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">if</span> (mStartDelay &gt; <span class="number">0</span>) &#123;</div><div class="line">                startAnimation();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (mSeekFraction &lt; <span class="number">0</span>) &#123;</div><div class="line">                mStartTime = frameTime;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">long</span> seekTime = (<span class="keyword">long</span>) (getScaledDuration() * mSeekFraction);</div><div class="line">                mStartTime = frameTime - seekTime;</div><div class="line">                mSeekFraction = -<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            mStartTimeCommitted = <span class="keyword">false</span>; <span class="comment">// allow start time to be compensated for jank</span></div><div class="line">        &#125;</div><div class="line">        mLastFrameTime = frameTime;</div><div class="line">        <span class="keyword">if</span> (mPaused) &#123;</div><div class="line">            mPauseTime = frameTime;</div><div class="line">            handler.removeCallback(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mResumed) &#123;</div><div class="line">            mResumed = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">if</span> (mPauseTime &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// Offset by the duration that the animation was paused</span></div><div class="line">                mStartTime += (frameTime - mPauseTime);</div><div class="line">                mStartTimeCommitted = <span class="keyword">false</span>; <span class="comment">// allow start time to be compensated for jank</span></div><div class="line">            &#125;</div><div class="line">            handler.addOneShotCommitCallback(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// The frame time might be before the start time during the first frame of</span></div><div class="line">        <span class="comment">// an animation.  The "current time" must always be on or after the start</span></div><div class="line">        <span class="comment">// time to avoid animating frames at negative time intervals.  In practice, this</span></div><div class="line">        <span class="comment">// is very rare and only happens when seeking backwards.</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> currentTime = Math.max(frameTime, mStartTime);</div><div class="line">        <span class="comment">//根据时间计算最新的 animated 的值，然后通过 listener 回调 onAnimationUpdate</span></div><div class="line">        <span class="keyword">boolean</span> finished = animateBasedOnTime(currentTime);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (finished) &#123;</div><div class="line">            endAnimation();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>上述代码只展现了单一帧的渲染过程，那么整一个动画是如何渲染的呢？肯定是有个地方每16ms  触发一次<code>draw</code>或者是<code>doAnimationFrame</code>方法，让他刷新界面，而这个16ms 的定时器，就是由 Choreographer 来实现的，他实际上是通过接收<code>display subsystem</code>的<code>timing pluses</code>来实现定时器功能的。当然如果系统不支持，则使用 handler 来实现定时器，handler 定时器的时间为10ms，设定时间比16ms 短是为了防止等待时间过长导致丢帧，因为定时器并不是完全准时的。</p>
<p>Choreographer 只是一个定时器，定时器的注册还是放在 view 本身或者 AnimationHandler。</p>
<p>Choregrapher 的 postCallback 经过各种处理后（比如入栈，出栈等操作），最终会调用 doFrame 方法，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">  doFrame(<span class="keyword">long</span> , <span class="keyword">int</span> ) &#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = System.nanoTime();</div><div class="line">        <span class="comment">//获取 callbackqueue 中与当前事件最近的操作来处理，即跳帧。理想情况下，queue 中应该只会有一个元素，当主线程比较卡，一个渲染周期内积累了太多事件，就会导致 callback 多</span></div><div class="line">        callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(</div><div class="line">              now / TimeUtils.NANOS_PER_MS);</div><div class="line">      <span class="keyword">if</span> (callbacks == <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">          mCallbacksRunning = <span class="keyword">true</span>;</div><div class="line">      <span class="comment">//...一些帧信息等处理，丢帧的 log 就是在这部分抛出的</span></div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">          Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"Choreographer#doFrame"</span>);</div><div class="line">          AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);</div><div class="line"></div><div class="line">          mFrameInfo.markInputHandlingStart();</div><div class="line">          <span class="comment">//先处理输入事件</span></div><div class="line">          doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</div><div class="line"></div><div class="line">          mFrameInfo.markAnimationsStart();</div><div class="line">          <span class="comment">//再处理动画</span></div><div class="line">          doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</div><div class="line"></div><div class="line">          mFrameInfo.markPerformTraversalsStart();</div><div class="line">          <span class="comment">//最后处理view 的布局和绘制</span></div><div class="line">          doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</div><div class="line"></div><div class="line">          <span class="comment">//处理完成</span></div><div class="line">          doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</div><div class="line">      &#125; <span class="keyword">finally</span> &#123;</div><div class="line">          AnimationUtils.unlockAnimationClock();</div><div class="line">          Trace.traceEnd(Trace.TRACE_TAG_VIEW);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="comment">//CallbackQueue.java</span></div><div class="line"> <span class="function"><span class="keyword">public</span> CallbackRecord <span class="title">extractDueCallbacksLocked</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</div><div class="line">          CallbackRecord callbacks = mHead;</div><div class="line">          <span class="keyword">if</span> (callbacks == <span class="keyword">null</span> || callbacks.dueTime &gt; now) &#123;</div><div class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          CallbackRecord last = callbacks;</div><div class="line">          CallbackRecord next = last.next;</div><div class="line">          <span class="keyword">while</span> (next != <span class="keyword">null</span>) &#123;</div><div class="line">              <span class="keyword">if</span> (next.dueTime &gt; now) &#123;</div><div class="line">                  last.next = <span class="keyword">null</span>;</div><div class="line">                  <span class="keyword">break</span>;</div><div class="line">              &#125;</div><div class="line">              last = next;</div><div class="line">              next = next.next;</div><div class="line">          &#125;</div><div class="line">          mHead = next;</div><div class="line">          <span class="keyword">return</span> callbacks;</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<p>弄明白 Choreographer 的机制后，再看 Animator 的实现就方便了，Animator 的动画，最终是通过 AnimationHandler 来进行处理的，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//AnimationHandler.java</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Choreographer.FrameCallback mFrameCallback = <span class="keyword">new</span> Choreographer.FrameCallback() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</div><div class="line">            doAnimationFrame(getProvider().getFrameTime());</div><div class="line">            <span class="keyword">if</span> (mAnimationCallbacks.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">                getProvider().postFrameCallback(<span class="keyword">this</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAnimationFrame</span><span class="params">(<span class="keyword">long</span> frameTime)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> size = mAnimationCallbacks.size();</div><div class="line">        <span class="keyword">long</span> currentTime = SystemClock.uptimeMillis();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">            <span class="keyword">final</span> AnimationFrameCallback callback = mAnimationCallbacks.get(i);</div><div class="line">            <span class="keyword">if</span> (callback == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//从动画的延迟列表里找 callback，如果没有，说明已经开始了，如果有并且开始时间小于 currentTime，也开始执行（相当于动画开始）</span></div><div class="line">            <span class="keyword">if</span> (isCallbackDue(callback, currentTime)) &#123;</div><div class="line">                callback.doAnimationFrame(frameTime);</div><div class="line">                <span class="keyword">if</span> (mCommitCallbacks.contains(callback)) &#123;</div><div class="line">                    getProvider().postCommitCallback(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                            commitAnimationFrame(callback, getProvider().getFrameTime());</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//把一些callback 为 null 的项清空掉，removeCallbacks 时，是把对应 index 下的 callback 置空，这是为了保证线程安全</span></div><div class="line">        cleanUpList();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeCallback</span><span class="params">(AnimationFrameCallback callback)</span> </span>&#123;</div><div class="line">        mCommitCallbacks.remove(callback);</div><div class="line">        mDelayedCallbackStartTime.remove(callback);</div><div class="line">        <span class="keyword">int</span> id = mAnimationCallbacks.indexOf(callback);</div><div class="line">        <span class="keyword">if</span> (id &gt;= <span class="number">0</span>) &#123;</div><div class="line">            mAnimationCallbacks.set(id, <span class="keyword">null</span>);</div><div class="line">            mListDirty = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>古老的 Animation 方式没有利用 CALLBACK_ANIMATION 这个类型，而是使用递归的方式来实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ViewRootImpl.java</span></div><div class="line">    <span class="comment">//任何 view 的 invalidate 最终都会调用到这个类的这个方法中，再通过 Choreographer 的 postCallback，在下一帧中进行重绘</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!mTraversalScheduled) &#123;</div><div class="line">            mTraversalScheduled = <span class="keyword">true</span>;</div><div class="line">            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</div><div class="line">            <span class="comment">//这里用的是布局类型，说明古老的 animation 方式，是通过实时刷新ViewTree 来实现的。</span></div><div class="line">            mChoreographer.postCallback(</div><div class="line">                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</div><div class="line">            <span class="keyword">if</span> (!mUnbufferedInputDispatch) &#123;</div><div class="line">                scheduleConsumeBatchedInput();</div><div class="line">            &#125;</div><div class="line">            notifyRendererOfFramePending();</div><div class="line">            pokeDrawLockIfNeeded();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><h3 id="Animation-动画"><a href="#Animation-动画" class="headerlink" title="Animation 动画"></a>Animation 动画</h3><p>view 渲染流程：<br><img src="/images/android-animation-principle/E396D831AAEB46950785E4F0991D9088.jpg" alt="IMAGE"></p>
<p>Animation 动画流程：<br><img src="/images/android-animation-principle/72AFDF08B0CE617A43B14281DDEADABD.jpg" alt="IMAGE"></p>
<p>Animator 动画流程：<br><img src="/images/android-animation-principle/BC368855FA78E690CD9DA1243A49A7E5.jpg" alt="IMAGE"></p>
<p><a href="/images/android-animation-principle/AA68573C5A5880D945D2F78F15EAE992.mdj">流程图源文件.mdj</a></p>
<h2 id="关键帧动画（keyframe-animatin"><a href="#关键帧动画（keyframe-animatin" class="headerlink" title="关键帧动画（keyframe animatin)"></a>关键帧动画（keyframe animatin)</h2><p>通过设定关键帧，由系统自动补全中间过程得以实现，中间的补充过程是用特定的插值方法计算得到，至于怎么算的，有时间再研究</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>动画的本质是在极短的时间内，渲染连续的画面，通过实现错觉让人感觉画面是“动”的，能够骗过人眼的频率是60fps，即每秒60帧，平均16ms 渲染一帧</li>
<li>view或者 ValueAnimator 中主要处理单帧画面的渲染，而至于渲染的时机，通过 postCallback 的方式，把触发时机交给 Choreographer 来实现</li>
<li>Choreophraher 通过侦听<code>display subsystem</code>的显示心跳来实现计时器，为了兼容，其内部也支持了通过 handler 实现的计时器，其计时周期是10ms</li>
<li>Choreophraher 心跳触发后，在 doFrame 中进行处理，把对应的 callback 拿出来执行，callback 分为三类，按照输入-&gt;动画-&gt;布局的顺序来处理事件</li>
<li>在单个帧的处理中，如果相同类型的时间出现多次，只取小于当前时间，并且离当前时间最近的事件来处理，即通常意义的跳帧。如果出现跳帧的操作，展现出来的就是丢帧，最终的结果就是看起来卡了下</li>
<li>所以丢帧可能会是两种原因，一个是 doFrame 的时间过长，另一个是主线程执行了比较重的任务，导致线程处理不过来</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.cnblogs.com/kross/p/4087780.html" target="_blank" rel="external">Android动画原理分析</a><br><a href="https://juejin.im/entry/57abeac5a341310060dbd7fd" target="_blank" rel="external">自定义 View-invalidate 传递与绘制流程分析</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mlazy.club/react-native-animation-performance-tool-systrace.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mluffy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人小屋">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/react-native-animation-performance-tool-systrace.html" itemprop="url">react-native 下，Android动画性能分析工具-systrace</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-15T19:08:24+08:00">
                2017-12-15
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/react-native-animation-performance-tool-systrace.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="react-native-animation-performance-tool-systrace.html" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          
             <span id="/react-native-animation-performance-tool-systrace.html" class="leancloud_visitors" data-flag-title="react-native 下，Android动画性能分析工具-systrace">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在项目中发现 react-native 的项目在实现转场动画的过程中，部分国产 android 机型出现转场时有不流畅的感觉，因此需要对动画过程进行分析，定位问题。本篇文章是定位问题过程衍生出来的第一篇文章。这一系列文章，会涉及到</p>
<ol>
<li><a href="/react-native-animation-performance-tool-systrace.html" title="react-native 下，Android动画性能分析工具-systrace">react-native 下，Android动画性能分析工具-systrace</a></li>
<li><a href="/android-animation-principle.html" title="android 动画原理">android 动画原理</a></li>
<li><a href="/react-native-animated-principle.html" title="react-native animated 动画实现原理">react-native animated 动画实现原理</a></li>
<li><a href="/react-navigation-animation-principle.html" title="react-navigation 动画实现原理">react-navigation 动画实现原理</a></li>
<li><a href="/react-native-animation-anlaysis-summary.html" title="react-native 动画性能分析总结">react-native 动画性能分析总结</a>
</li>
</ol>
<h1 id="systrace"><a href="#systrace" class="headerlink" title="systrace"></a>systrace</h1><p>官方文档的 <a href="https://facebook.github.io/react-native/docs/performance.html" target="_blank" rel="external">performance</a> 里，提到了不少分析工具，在定位的过程中，更多使用的是 android 提供的 systrace 方法，其使用说明在 <a href="https://facebook.github.io/react-native/docs/performance.html#Profiling" target="_blank" rel="external">performance</a> 的 <code>profiling</code> 章节中也有提到</p>
<h2 id="systrace-的使用方法"><a href="#systrace-的使用方法" class="headerlink" title="systrace 的使用方法"></a>systrace 的使用方法</h2><p>systrace 本质上是通过记录关键方法的调用记录进行统计分析。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ &lt;path_to_android_sdk&gt;/platform-tools/systrace/systrace.py --time=10 -o trace.html <span class="built_in">sched</span> gfx view -a &lt;your_package_name&gt;</div></pre></td></tr></table></figure>
<p>几个参数的含义：</p>
<ul>
<li><code>time</code>：数据记录收集的时长</li>
<li><code>sched</code>，<code>gfx</code>，<code>view</code>都是分析指标，这三个属于分析过程中需要关注到的几个指标。<code>sched</code>是提供集每一核 cpu 具体在处理的事情，<code>gfx</code>提供图形化的信息，比如按照每一帧来给时间划分区域，<code>view</code>则是提供视图的计算、布局和渲染耗时</li>
<li>-a <package_name>用于指定收集特定应用的数据</package_name></li>
<li>-o <file.html> 用于指定分析结果的输出位置，输出结果最好用 chrome 打开，其他浏览器不保证兼容性</file.html></li>
</ul>
<h2 id="阅读分析结果"><a href="#阅读分析结果" class="headerlink" title="阅读分析结果"></a>阅读分析结果</h2><p>在 chrome 打开文件后，可以在右上角的<code>View Options</code>里，打开 Hightlight VSync，用于标记显示系统（display subsystem）渲染每一帧的时间点。</p>
<p>一个测试结果如下：<br><img src="/images/react-native-animation-performance-tool-systrace/CE7AF2EB29354FF79D54A3E05F310D01.jpg" alt="IMAGE"><br><a href="/images/react-native-animation-performance-tool-systrace/268FACA41EBCD174731B1A95B7C68AA7.zip">测试结果源文件</a></p>
<p>左侧是进程以及进程下正在执行的线程（并不是所有线程，而是在记录时活跃的线程）。中间的图形则是渲染的分析结果，F 表示视图开始渲染的时间点，即 view 执行<code>performTraversals</code>时的时间点。F 标记为绿色，说明视图渲染的时间不超过一帧，不是绿色，说明已经有丢帧出现。这时就可以查看丢帧严重的地方，看看是哪个部分占用耗时。</p>
<p><img src="/images/react-native-animation-performance-tool-systrace/3871F6AC03A57304753B84964C56E564.jpg" alt="IMAGE"><br>比如上图红色的 frame，可以看到大部分是在 performTraversals 耗时较多，说明视图的渲染比较耗时。虽然说是在渲染视图时耗时，但是并不一定完全是因为 view 太过复杂引起的，实际上，在上述例子中，这个界面只是简单的几个按钮，view 并不复杂，这时候需要同步分析 cpu 中线程的执行情况，看看是否是因为 CPU 负载过高，导致任务等待。点击 DrawFrame，我们可以看到执行时间实际只有13ms（CPU Duration），但是等待 cpu 资源达到了20ms（Wall Duration - CPU Duration），这就 与应用的环境、系统的环境有关系了。<br><img src="/images/react-native-animation-performance-tool-systrace/CBE4145B3B4BF25025077BF9909556BF.jpg" alt="IMAGE"></p>
<h2 id="有关丢帧"><a href="#有关丢帧" class="headerlink" title="有关丢帧"></a>有关丢帧</h2><p>在上节分析结果，我们说到 F 标记为黄色或者红色时，说明有丢帧出现，但从实际体验上看，只是黄色的丢帧并没有令人感觉到不流畅，或者说短时间的动画，让人感受不到那细微的差异。因为从本质上说，30FPS（人眼能够感知的最低动画频率是24FPS） 的动画也是让人感受不到异常的，当然这要具体情况具体分析，不同场景下，对帧率的要求也是不同的（比如射击游戏对帧率的要求就比较高，不然会让人有眩晕感）。总的来说，我们不能单纯的以 profile 的结果来判定动画的性能，需要结合实际情况进行分析，profile 只是一个辅助定位的手段。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>[performance]（<a href="https://facebook.github.io/react-native/docs/performance.html）章节中，提到了很多性能分析的方法，定位动画问题最常用到的是" target="_blank" rel="external">https://facebook.github.io/react-native/docs/performance.html）章节中，提到了很多性能分析的方法，定位动画问题最常用到的是</a> systrace</li>
<li>利用 systrace，我们可以得到每一帧中视图的渲染情况、线程的执行情况及 CPU 的负载情况，综合上述的几个指标，可以分析定位可能影响动画性能的地方</li>
<li>丢帧并不一定会影响最终的展现效果，手机一般的帧率是60FPS，远大于人眼能够感知的最低帧率（24FPS），因此单纯靠分析结果去判定动画性能是不靠谱的。某些丢帧的部分可能是影响不大的地方，对最终的动画效果并不能产生决定性的影响。我们应该把 profile 的结果作为一个分析参数，最终还要综合其他因素进行考量</li>
</ol>
<h1 id="有个坑"><a href="#有个坑" class="headerlink" title="有个坑"></a>有个坑</h1><p>虽然有了如此多的分析工具，但是这些工具本质上是在分析动画的渲染频率，并没有对中间过程的动画进行分析。动画，本质上是一组<code>连续的</code>画面，按照<code>一定频率</code>播放的结果，这些工具主要是在验证动画是否是按照<code>一定频率</code>进行渲染，而在本次分析的结果中，发现，实际上发现是因为画面<code>不连续</code>导致的。那么这个结果是如何发现的？其看下集：<a href="/android-animation-principle.html" title="android 动画原理">android 动画原理</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mlazy.club/thought-of-android-performance-anlaysis.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mluffy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人小屋">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/thought-of-android-performance-anlaysis.html" itemprop="url">Android 性能分析（道篇）</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-21T19:25:42+08:00">
                2017-09-21
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/thought-of-android-performance-anlaysis.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="thought-of-android-performance-anlaysis.html" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          
             <span id="/thought-of-android-performance-anlaysis.html" class="leancloud_visitors" data-flag-title="Android 性能分析（道篇）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近需要对手头上的项目做一个性能优化，要求应用能正常的跑在一个低性能的设备上，碰碰巧这一块是此前没怎么涉及到的，相当于是一个全新的任务。真正做起来的时候绕了不少弯路，回过头在总结的时候才发现，使用的方法和编程都是一个套路，用在不同的场景下得出了不同的名字，本质上仍然是相同的，这也是为什么历史上站在行业顶峰的人，都是一长串的 XX 家作为 title。比如爱因斯坦，数学、物理很厉害，小提琴也有不小的造诣。再如达芬奇虽然以艺术功底闻名于世，其机械、医学能力也是相当出彩的。</p>
<p>复杂的事往往都有简单的道理，而简单的道理往往能运用在工作生活的方方面面。</p>
<h1 id="从宏观到微观（至顶向下）的分析方法"><a href="#从宏观到微观（至顶向下）的分析方法" class="headerlink" title="从宏观到微观（至顶向下）的分析方法"></a>从宏观到微观（至顶向下）的分析方法</h1><p>编程世界里，我们倡导设计先行，从需求出发，先进行需求分析，再进行软件设计，最后才开始编码实现。这一套方法论总结起来就是从宏观的角度分析、发现问题，再分解到微观角度去解析问题的本质。</p>
<p>无独有偶，物理、化学也是一个从宏观到微观的过程，先通过宏观了解到事物的表象，再从微观去理解本质。</p>
<p>那么套方法论到性能分析上，就可以逐层分解出几个主题：</p>
<p><strong>确定性能指标</strong><br><strong>寻找分析工具</strong><br><strong>确定分析方法</strong><br><strong>问题修复</strong></p>
<h2 id="确定性能指标"><a href="#确定性能指标" class="headerlink" title="确定性能指标"></a>确定性能指标</h2><p>通过 Google，搜索一些诸如 android 性能分析 性能评估 性能瓶颈 等等关键词，提取出确定性能的几个指标，再结合当前的项目抽取出合适当前项目的指标。</p>
<p>比如本次我总结出来以下几点：</p>
<ul>
<li>OS<ul>
<li>cpu</li>
<li>memory</li>
<li>I/O</li>
</ul>
</li>
<li>App<ul>
<li>业务方法调用耗时<ul>
<li>java</li>
<li>native</li>
</ul>
</li>
<li>UI 布局</li>
</ul>
</li>
</ul>
<p>主要分为了两个角度，一个是系统层面，从操作系统的角度来分析应用的性能，二是应用层面，从应用层的角度去分析性能瓶颈。这两者实际上是有重叠的，但是因为切入的角度不一样，通过对比，可以更容易的发现和解决问题。</p>
<p>另外，在当前的项目中，由于 I/O 操作几乎没有，因此这部分可以不在此次的评估范围内，因此就目前的项目来说，就可以把分析指标定位在以下几个：</p>
<ul>
<li>OS<ul>
<li>cpu</li>
<li>memory</li>
<li>I/O</li>
</ul>
</li>
<li>App<ul>
<li>业务方法调用耗时<ul>
<li>java</li>
<li>native</li>
</ul>
</li>
<li>UI 布局</li>
</ul>
</li>
</ul>
<h2 id="寻找分析工具"><a href="#寻找分析工具" class="headerlink" title="寻找分析工具"></a>寻找分析工具</h2><p>Android 的性能分析工具种类繁多，简书上有一篇收集的挺好的 - <a href="http://www.jianshu.com/p/8b77d394b2a6" target="_blank" rel="external">Android 性能分析工具整理汇总</a>，这里就不再赘述。</p>
<p>那么问题来了，这么多工具，应该选哪一个呢？</p>
<p>前面说到，分析问题的时候，需要使用至顶向下的分析方式，那么需要使用工具解决问题的时候，还能使用这个方法吗？</p>
<p>答案是不能，使用工具、解决问题，这已经是一个顶层的事情，你看网络模型里，application layer 是不是放在上边的？</p>
<p>所以到使用工具，解决问题的领域时，就需要刚好相反的能力，至底向上。我们需要从底部开始，了解事物的本质，才能够从容的选择上层的工具来解决问题。比如你访问 Google 出现 connection reset，如果仅限于了解http 404是网页未找到，这个问题就等于无解了。你得先了解 TCP/IP，了解浏览器访问 google.com 时都做了什么事情，国家防火墙在这个过程又充当了什么角色，这才有底气的通过抓包工具定位问题。</p>
<p>回到性能分析，我的答案是先看<a href="https://developer.android.com/studio/profile/am-cpu.html" target="_blank" rel="external">官方文档</a>，官方文档里提供的工具，相对基础，先了解这些工具如何使用，也就基本掌握指标对应的含义。那么在使用过程中产生的痛点，也就是你对工具的需求了，针对自己的需求，再去找工具，就有的放矢了。</p>
<h2 id="确定分析方法"><a href="#确定分析方法" class="headerlink" title="确定分析方法"></a>确定分析方法</h2><p>上面说到先用官方工具来分析，那么如何分析呢。那些如何看图表，指标的含义在这里不再赘述，后续的文章中会详细说明。在这里只说一点，就是要排出干扰，无论什么领域，在分析问题的时候，都需要遵守单一变量原则，做科学实验如此，解 bug 如此，分析性能也是一样。无论是低端一点的注释方法，还是高级一些的 API mock，都是围绕单一变量原则来进行的。了解这个，那么所使用的方法就不会有太多拘束了。独孤九剑的最高奥义无招胜有招也是一个道理，了解剑招的本质，也就无所谓剑招了。</p>
<h2 id="问题修复"><a href="#问题修复" class="headerlink" title="问题修复"></a>问题修复</h2><p>这里又会回到分析问题，因此继续套用至顶向下的分析方法。定位到对应代码出了问题，要避免单纯的针对问题本身做修复，而是要从宏观的角度来分析问题，多问问自己，这个问题是否设计上的缺陷？语言缺陷？应该如何从根本上去避免此类问题？</p>
<p>题外话，修复问题的时候，不要想着“先这样改吧，以后有时间再做优化”，然后还加个 TODO 以此为证。历史经验证明，这招往往是没有效的，计划赶不上变化，技术一直在持续更新，你现在不优化，跟上节奏，那么会越来越跟不上节奏。另外，需求一直有，今年特别多，你也不大有机会再回来处理这个优先级如此之低的 TODO 了</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上，就是我在分析当前项目性能的过程中领悟到的一些知识。总体来说就是分析问题时，至顶向下来分析，解决问题时，至底向上去解决。前者有利于把问题想透，后者有利于把问题彻底解决。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mlazy.club/ios-background-mode.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mluffy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人小屋">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ios-background-mode.html" itemprop="url">iOS 的后台运行机制</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-22T20:01:58+08:00">
                2016-10-22
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/ios-background-mode.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="ios-background-mode.html" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          
             <span id="/ios-background-mode.html" class="leancloud_visitors" data-flag-title="iOS 的后台运行机制">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>详细的说明可以参考<a href="https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/BackgroundExecution/BackgroundExecution.html#//apple_ref/doc/uid/TP40007072-CH4-SW1" target="_blank" rel="external">Background Execution</a></p>
<p>在APP不支持background mode的前提下，点击home之后，会进入background state，接着经过短短几秒后，会进入suspend state。</p>
<p>iOS提供了一些后台运行的权限申请，用以保证特定场景下的后台执行需求。截止iOS9，所支持的权限如下表：<br><img src="/images/ios-background-mode/1439214114982.png" alt="Alt text"></p>
<p>一般情况下，如果仅需要在进入后台的时候额外做一些操作，则不需要申请这些后台权限，仅需要执行一个long-runing task即可。<br>示例代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (<span class="keyword">void</span>)applicationDidEnterBackground:(<span class="built_in">UIApplication</span> *)application</div><div class="line">&#123;</div><div class="line">    bgTask = [application beginBackgroundTaskWithName:<span class="string">@"MyTask"</span> expirationHandler:^&#123;</div><div class="line">        <span class="comment">// Clean up any unfinished task business by marking where you</span></div><div class="line">        <span class="comment">// stopped or ending the task outright.</span></div><div class="line">        [application endBackgroundTask:bgTask];</div><div class="line">        bgTask = <span class="built_in">UIBackgroundTaskInvalid</span>;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    <span class="comment">// Start the long-running task and return immediately.</span></div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line"></div><div class="line">        <span class="comment">// Do the work associated with the task, preferably in chunks.</span></div><div class="line"></div><div class="line">        [application endBackgroundTask:bgTask];</div><div class="line">        bgTask = <span class="built_in">UIBackgroundTaskInvalid</span>;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>首先需要明确APP的一个生命周期<br><img src="/images/ios-background-mode/1439212569060.png" alt="Alt text"></p>
<h2 id="Activate"><a href="#Activate" class="headerlink" title="Activate"></a>Activate</h2><p>APP处于前台，接受UI的点击事件</p>
<h2 id="InActivate"><a href="#InActivate" class="headerlink" title="InActivate"></a>InActivate</h2><p>APP仍然处于前台，但不接受UI点击事件</p>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>APP处于后台，此时APP完全属于不可见的状态，比如点击home键之后，即进入了background state。此时应用仍然在运行，所有代码均可执行。</p>
<h2 id="suspend"><a href="#suspend" class="headerlink" title="suspend"></a>suspend</h2><p>挂起，此时iOS会存储当前应用的执行状态，接着释放掉对应的资源。</p>
<h1 id="iOS后台运行机制分析"><a href="#iOS后台运行机制分析" class="headerlink" title="iOS后台运行机制分析"></a>iOS后台运行机制分析</h1><p>介绍完基础知识，开始进入正题。先从实践入手，目前使用了CentralManager mode和Location update mode两个后台使用权限。从这两个后台模式碰到的一些现象，来尝试分析iOS是如何完成后台运行的。</p>
<h2 id="Location-update"><a href="#Location-update" class="headerlink" title="Location update"></a>Location update</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>Step1.首先做好后台的配置，先在Xcode的capabilities中勾选对应的选项<br><img src="/images/ios-background-mode/1439454966117.png" alt="Alt text"></p>
<p>Step2.接着在plist中添加NSLocationAlawaysUsageDescription<br><img src="/images/ios-background-mode/1439455184137.png" alt="Alt text"></p>
<p>完成这两步才算完成了后台运行的基础。<br>Step3.接着还需要在代码中调用<code>requestAlwaysAuthorization</code>，才算完成了对后台更新location的申请。</p>
<p>为什么需要做这些配置呢？<br>iOS默认是不支持后台执行的，为的是能够将更多的资源集中在当前运行的应用上。因此需要有step1.运行权限的配置。<br>在iOS7之后，对于location的使用，提供了两种模式<code>Always</code>以及<code>WhenInUse</code>，从命名上也很容易明白，<code>Always</code>即任何情况下都可以使用，而<code>WhenInUse</code>则是在应用开启的时候允许使用。<br>下面一张图会看着比较清晰<br><img src="/images/ios-background-mode/1439455776679.png" alt="Alt text"><br>两者的区别无非是对于Location Monitoring的使用权限。那么这两个东西分别是什么鬼？<br><code>Region monitoring</code>，是对一个进出某一个区域的检测。对应的方法是<code>startMonitoringForRegion:</code>。我们可以使用<code>CLRegion</code>设定一个圆，在位置进出这个圆时，会调用<code>didEnterRegion</code>以及<code>didExitRegion</code>的代理。<br><code>Significant location changes</code>，是苹果为了电量的优化做的定位策略。对应的方法是<code>startMonitoringSignificantLocationChanges</code>。<br>摘抄API的描述文档：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Starts the generation of updates based on significant location changes.</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">If you start this service and your app is subsequently terminated, the system automatically relaunches the app into the background if a new event arrives.</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">Apps can expect a notification as soon as the device moves 500 meters or more from its previous notification. It should not expect notifications more frequently than once every five minutes.</div></pre></td></tr></table></figure>
<p>从以上的描述得到两个重要信息，</p>
<ol>
<li>这个方法可以在app terminate的时候重启app使其进入后台模式</li>
<li>这个方法只有在运动了500米并且已经过了5分钟，才会执行一次定位</li>
</ol>
<p>从这个描述里，我们已经嗅到iOS的后台运行机制，它不仅仅是保持应用在后台执行。</p>
<p>接下来我们做个试验：<br>定义个BMLocationManager</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BMLocationManager</span> : <span class="title">CLLocationManager</span>&lt;<span class="title">CLLocationManagerDelegate</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>在初始化的时候直接执行定位：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BMLocationManager</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ([<span class="built_in">CLLocationManager</span> authorizationStatus] != kCLAuthorizationStatusAuthorizedAlways &amp;&amp; [<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(requestAlwaysAuthorization)]) &#123;</div><div class="line">            [<span class="keyword">self</span> requestAlwaysAuthorization];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">self</span>.distanceFilter = <span class="number">30</span>;</div><div class="line">        <span class="keyword">self</span>.desiredAccuracy = kCLLocationAccuracyBest;</div><div class="line">        <span class="keyword">self</span>.delegate = <span class="keyword">self</span>;</div><div class="line">        <span class="keyword">self</span>.pausesLocationUpdatesAutomatically = <span class="literal">YES</span>;</div><div class="line"></div><div class="line"><span class="comment">//        [self startMonitoringSignificantLocationChanges];</span></div><div class="line">        [<span class="keyword">self</span> startUpdatingLocation];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>didUpdateLocations</code>的代理里加上locationNotification方便查看log。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)locationManager:(<span class="built_in">CLLocationManager</span> *)manager didUpdateLocations:(<span class="built_in">NSArray</span> *)locations</div><div class="line">&#123;</div><div class="line">    <span class="built_in">UILocalNotification</span> *n = [<span class="built_in">UILocalNotification</span> new];</div><div class="line">    n.alertTitle = <span class="string">@"位置"</span>;</div><div class="line">    n.alertBody = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"位置更新：%@"</span>, [<span class="built_in">NSDateFormatter</span> localizedStringFromDate:[<span class="built_in">NSDate</span> date] dateStyle:<span class="built_in">NSDateFormatterNoStyle</span> timeStyle:<span class="built_in">NSDateFormatterShortStyle</span>]];</div><div class="line">    n.soundName = <span class="built_in">UILocalNotificationDefaultSoundName</span>;</div><div class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] scheduleLocalNotification:n];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"location update:%@"</span>, locations);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在模拟器app启动之后，点击home键进入后台，在debug-&gt;location下选择freeway-drive。（注意不要使用使用调试模式，在这个模式下app是不会被系统杀死的，和真实环境会有所出入。）<br>我们会发现，会不停的有location通知，然而挂着足够长的时间（可以跑这个<a href="https://github.com/ddaddy/BackgroundKill" target="_blank" rel="external">应用</a>让系统内存压力杀死其他app），发现通知停了，打开app一看，经历了闪屏，说明应用被杀掉了。<br>因此，在这里可以进行一个猜想，<strong>使用background mode并不能保证应用不会被系统杀死。</strong></p>
<p>那么location update的后台执行到底是怎么实现呢？我们来看看<code>startMonitoringSignificantLocationChanges</code>的方式。<br>既然API文档说在应用被终止时会重启app，并且调用<code>didFinishLaunchWithOptions</code>的代理，那么我们就在appDelegate里加上一个notification来做验证</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//收到位置消息时唤醒app</span></div><div class="line">    <span class="keyword">if</span> (launchOptions[<span class="built_in">UIApplicationLaunchOptionsLocationKey</span>]) &#123;</div><div class="line">        <span class="built_in">UILocalNotification</span> *noti = [<span class="built_in">UILocalNotification</span> new];</div><div class="line">        <span class="keyword">self</span>.strongRef = [BMLocationManager new];</div><div class="line">        noti.alertTitle = <span class="string">@"嘿嘿"</span>;</div><div class="line">        noti.alertBody = <span class="string">@"新的位置来了，app后台启动"</span>;</div><div class="line">        noti.soundName = <span class="built_in">UILocalNotificationDefaultSoundName</span>;</div><div class="line">        [application scheduleLocalNotification:noti];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>更新app，再次启动，接着直接杀死。发现确实调用了appDelegate。那么这个启动过程和一般的启动过程有什么不同呢？我们利用hook，在viewController里增加log，看看其调用过程。<br>log的配置使用了Aspects这个基于AOP的第三方框架。<br>AOP的方式在这类验证性的工作是非常有帮助的，保持了原有代码的整洁性。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (<span class="keyword">void</span>)makeHook</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSArray</span> *selectors = @[<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(init)),</div><div class="line">                           <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(awakeFromNib)),</div><div class="line">                           <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(viewDidLoad)),</div><div class="line">                           <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(viewWillAppear:)),</div><div class="line">                           <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(viewDidAppear:)),</div><div class="line">                           <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(viewWillDisappear:)),</div><div class="line">                           <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(viewDidDisappear:))];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *selectorStr <span class="keyword">in</span> selectors) &#123;</div><div class="line">        [<span class="keyword">self</span> hookClass:[<span class="built_in">UIViewController</span> <span class="keyword">class</span>] forSelector:<span class="built_in">NSSelectorFromString</span>(selectorStr)];</div><div class="line">    &#125;</div><div class="line">    selectors = @[<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(init)),</div><div class="line">                  <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(centralManager:willRestoreState:))];</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *selectorStr <span class="keyword">in</span> selectors) &#123;</div><div class="line">        [<span class="keyword">self</span> hookClass:[BMCentralManager <span class="keyword">class</span>] forSelector:<span class="built_in">NSSelectorFromString</span>(selectorStr)];</div><div class="line">    &#125;</div><div class="line">    selectors = @[<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(init)),</div><div class="line">                  <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(locationManager:didUpdateLocations:))];</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *selectorStr <span class="keyword">in</span> selectors) &#123;</div><div class="line">        [<span class="keyword">self</span> hookClass:[BMLocationManager <span class="keyword">class</span>] forSelector:<span class="built_in">NSSelectorFromString</span>(selectorStr)];</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span> hookClass:[<span class="built_in">UIWindow</span> <span class="keyword">class</span>] forSelector:<span class="keyword">@selector</span>(makeKeyAndVisible)];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)hookClass:(Class)aCass forSelector:(SEL)selecotr</div><div class="line">&#123;</div><div class="line">    [aCass aspect_hookSelector:selecotr withOptions:AspectPositionBefore usingBlock:^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@ call %@"</span>, [aspectInfo instance], <span class="built_in">NSStringFromSelector</span>(selecotr));</div><div class="line">    &#125;error:<span class="literal">nil</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来再次执行相同的步骤，看看log都输出了些什么？<br>发现一个viewController的完整生命周期都输出了。说明在后台启动的时候，并没有走什么特殊通道，而是按照正常的流程一直到等待UI输入的步骤。因此我们的app如果需要实现类似的后台运行模式，那么app delegate的设计就需要考虑到后台运行的情况了。</p>
<p>接下来再看，应用后台启动之后，我们手动打开app，又发生了什么事？<br>app又调用了闪屏，查看log，发现又重新来了一次启动流程。查看application的地址，发现不是同一个地址，说明手动开启app之后，系统把后台启动的应用给释放掉了。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>在location mode的后台执行模式下，应用并不会常驻在后台，而是与普通应用相同，随时会被killed。<br>想要达到类似常驻后台的效果，需要使用<code>startMonitoringSignificantLocationChanges</code>方法，在更新location时，系统会重启应用，使其处于后台模式。<br>应用启动时，与正常启动直到等待UI输入的流程无异。</p>
<h1 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h1><h2 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h2><p>在调试蓝牙后台时，需要验证是否真的唤醒了APP，但是调试模式下没办法进入suspend的状态，而双击home健手动杀掉进程，也同样不会唤醒APP，此时连蓝牙也会立即结束。因此需要进入suspend状态时，可以使用<br><code>kill(getpid(), SIGKILL)</code>方法模拟系统因为内存压力等原因结束进程的方式</p>
<h2 id="APNS"><a href="#APNS" class="headerlink" title="APNS"></a>APNS</h2><p>APNS需要在content-available为true，并且开启remote-notification的时候才会支持后台模式</p>
<p>当iOS收到一条push消息时，如果payload里包含content-available = true，那么会发生下面的事情</p>
<ul>
<li>如果app处于suspended状态，那么系统会把app置为background状态</li>
<li>如果app是是通过app switcher的方式被用户杀掉了，则不会启动app</li>
</ul>
<h2 id="关于后台启动"><a href="#关于后台启动" class="headerlink" title="关于后台启动"></a>关于后台启动</h2><p>后台启动根据不同的模式也会有不同的区别，一般情况下，只有应用处于suspended状态下的时候，才能够启动为background，对于force quit的应用，是不会生效的。目前来说，唯一例外的只有iOS 8之后的location模式会启动应用<br><img src="/images/ios-background-mode/1477103337238.png" alt="Alt text"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.png"
               alt="mluffy" />
          <p class="site-author-name" itemprop="name">mluffy</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/luhui" target="_blank" title="GitHub" rel="external nofollow">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mluffy</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io" rel="external nofollow">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" rel="external nofollow">
    NexT.Gemini
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	

		<script type="text/javascript">
		_hcwp = window._hcwp || [];

		_hcwp.push({widget:"Bloggerstream", widget_id: 99034, selector:".hc-comment-count", label: "{\%COUNT%\}" });

		

		(function() {
		if("HC_LOAD_INIT" in window)return;
		HC_LOAD_INIT = true;
		var lang = (navigator.language || navigator.systemLanguage || navigator.userLanguage || "en").substr(0, 2).toLowerCase();
		var hcc = document.createElement("script"); hcc.type = "text/javascript"; hcc.async = true;
		hcc.src = ("https:" == document.location.protocol ? "https" : "http")+"://w.hypercomments.com/widget/hc/99034/"+lang+"/widget.js";
		var s = document.getElementsByTagName("script")[0];
		s.parentNode.insertBefore(hcc, s.nextSibling);
		})();
		</script>

	










  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.2"></script>



  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("f8tImvggaaabjWNL6cKiB9NE-gzGzoHsz", "CCF7eatYpKomzwcayI4AAgNV");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
