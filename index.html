<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="mluffy&#39;s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="mluffy&#39;s blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mluffy&#39;s blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>mluffy's blog</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">mluffy's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">诶？不错哟</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/22/ios-background-mode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mluffy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mluffy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/22/ios-background-mode/" itemprop="url">iOS 的后台运行机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-22T20:01:58+08:00">
                2016-10-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>详细的说明可以参考<a href="https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/BackgroundExecution/BackgroundExecution.html#//apple_ref/doc/uid/TP40007072-CH4-SW1" target="_blank" rel="external">Background Execution</a></p>
<p>在APP不支持background mode的前提下，点击home之后，会进入background state，接着经过短短几秒后，会进入suspend state。</p>
<p>iOS提供了一些后台运行的权限申请，用以保证特定场景下的后台执行需求。截止iOS9，所支持的权限如下表：<br><img src="./1439214114982.png" alt="Alt text"></p>
<p>一般情况下，如果仅需要在进入后台的时候额外做一些操作，则不需要申请这些后台权限，仅需要执行一个long-runing task即可。<br>示例代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (<span class="keyword">void</span>)applicationDidEnterBackground:(<span class="built_in">UIApplication</span> *)application</div><div class="line">&#123;</div><div class="line">    bgTask = [application beginBackgroundTaskWithName:<span class="string">@"MyTask"</span> expirationHandler:^&#123;</div><div class="line">        <span class="comment">// Clean up any unfinished task business by marking where you</span></div><div class="line">        <span class="comment">// stopped or ending the task outright.</span></div><div class="line">        [application endBackgroundTask:bgTask];</div><div class="line">        bgTask = <span class="built_in">UIBackgroundTaskInvalid</span>;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    <span class="comment">// Start the long-running task and return immediately.</span></div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line"></div><div class="line">        <span class="comment">// Do the work associated with the task, preferably in chunks.</span></div><div class="line"></div><div class="line">        [application endBackgroundTask:bgTask];</div><div class="line">        bgTask = <span class="built_in">UIBackgroundTaskInvalid</span>;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>首先需要明确APP的一个生命周期<br><img src="./1439212569060.png" alt="Alt text"></p>
<h2 id="Activate"><a href="#Activate" class="headerlink" title="Activate"></a>Activate</h2><p>APP处于前台，接受UI的点击事件</p>
<h2 id="InActivate"><a href="#InActivate" class="headerlink" title="InActivate"></a>InActivate</h2><p>APP仍然处于前台，但不接受UI点击事件</p>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>APP处于后台，此时APP完全属于不可见的状态，比如点击home键之后，即进入了background state。此时应用仍然在运行，所有代码均可执行。</p>
<h2 id="suspend"><a href="#suspend" class="headerlink" title="suspend"></a>suspend</h2><p>挂起，此时iOS会存储当前应用的执行状态，接着释放掉对应的资源。</p>
<h1 id="iOS后台运行机制分析"><a href="#iOS后台运行机制分析" class="headerlink" title="iOS后台运行机制分析"></a>iOS后台运行机制分析</h1><p>介绍完基础知识，开始进入正题。先从实践入手，目前使用了CentralManager mode和Location update mode两个后台使用权限。从这两个后台模式碰到的一些现象，来尝试分析iOS是如何完成后台运行的。</p>
<h2 id="Location-update"><a href="#Location-update" class="headerlink" title="Location update"></a>Location update</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>Step1.首先做好后台的配置，先在Xcode的capabilities中勾选对应的选项<br><img src="./1439454966117.png" alt="Alt text"></p>
<p>Step2.接着在plist中添加NSLocationAlawaysUsageDescription<br><img src="./1439455184137.png" alt="Alt text"></p>
<p>完成这两步才算完成了后台运行的基础。<br>Step3.接着还需要在代码中调用<code>requestAlwaysAuthorization</code>，才算完成了对后台更新location的申请。</p>
<p>为什么需要做这些配置呢？<br>iOS默认是不支持后台执行的，为的是能够将更多的资源集中在当前运行的应用上。因此需要有step1.运行权限的配置。<br>在iOS7之后，对于location的使用，提供了两种模式<code>Always</code>以及<code>WhenInUse</code>，从命名上也很容易明白，<code>Always</code>即任何情况下都可以使用，而<code>WhenInUse</code>则是在应用开启的时候允许使用。<br>下面一张图会看着比较清晰<br><img src="./1439455776679.png" alt="Alt text"><br>两者的区别无非是对于Location Monitoring的使用权限。那么这两个东西分别是什么鬼？<br><code>Region monitoring</code>，是对一个进出某一个区域的检测。对应的方法是<code>startMonitoringForRegion:</code>。我们可以使用<code>CLRegion</code>设定一个圆，在位置进出这个圆时，会调用<code>didEnterRegion</code>以及<code>didExitRegion</code>的代理。<br><code>Significant location changes</code>，是苹果为了电量的优化做的定位策略。对应的方法是<code>startMonitoringSignificantLocationChanges</code>。<br>摘抄API的描述文档：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Starts the generation of updates based on significant location changes.</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">If you start <span class="keyword">this</span> service and your app is subsequently terminated, the system automatically relaunches the app into the background <span class="keyword">if</span> a new event arrives.</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">Apps can expect a notification as soon as the device moves <span class="number">500</span> meters or more from its previous notification. It should not expect notifications more frequently than once every five minutes.</div></pre></td></tr></table></figure>
<p>从以上的描述得到两个重要信息，</p>
<ol>
<li>这个方法可以在app terminate的时候重启app使其进入后台模式</li>
<li>这个方法只有在运动了500米并且已经过了5分钟，才会执行一次定位</li>
</ol>
<p>从这个描述里，我们已经嗅到iOS的后台运行机制，它不仅仅是保持应用在后台执行。</p>
<p>接下来我们做个试验：<br>定义个BMLocationManager</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BMLocationManager</span> : <span class="title">CLLocationManager</span>&lt;<span class="title">CLLocationManagerDelegate</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>在初始化的时候直接执行定位：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BMLocationManager</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ([<span class="built_in">CLLocationManager</span> authorizationStatus] != kCLAuthorizationStatusAuthorizedAlways &amp;&amp; [<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(requestAlwaysAuthorization)]) &#123;</div><div class="line">            [<span class="keyword">self</span> requestAlwaysAuthorization];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">self</span>.distanceFilter = <span class="number">30</span>;</div><div class="line">        <span class="keyword">self</span>.desiredAccuracy = kCLLocationAccuracyBest;</div><div class="line">        <span class="keyword">self</span>.delegate = <span class="keyword">self</span>;</div><div class="line">        <span class="keyword">self</span>.pausesLocationUpdatesAutomatically = <span class="literal">YES</span>;</div><div class="line"></div><div class="line"><span class="comment">//        [self startMonitoringSignificantLocationChanges];</span></div><div class="line">        [<span class="keyword">self</span> startUpdatingLocation];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>didUpdateLocations</code>的代理里加上locationNotification方便查看log。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)locationManager:(<span class="built_in">CLLocationManager</span> *)manager didUpdateLocations:(<span class="built_in">NSArray</span> *)locations</div><div class="line">&#123;</div><div class="line">    <span class="built_in">UILocalNotification</span> *n = [<span class="built_in">UILocalNotification</span> new];</div><div class="line">    n.alertTitle = <span class="string">@"位置"</span>;</div><div class="line">    n.alertBody = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"位置更新：%@"</span>, [<span class="built_in">NSDateFormatter</span> localizedStringFromDate:[<span class="built_in">NSDate</span> date] dateStyle:<span class="built_in">NSDateFormatterNoStyle</span> timeStyle:<span class="built_in">NSDateFormatterShortStyle</span>]];</div><div class="line">    n.soundName = <span class="built_in">UILocalNotificationDefaultSoundName</span>;</div><div class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] scheduleLocalNotification:n];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"location update:%@"</span>, locations);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在模拟器app启动之后，点击home键进入后台，在debug-&gt;location下选择freeway-drive。（注意不要使用使用调试模式，在这个模式下app是不会被系统杀死的，和真实环境会有所出入。）<br>我们会发现，会不停的有location通知，然而挂着足够长的时间（可以跑这个<a href="https://github.com/ddaddy/BackgroundKill" target="_blank" rel="external">应用</a>让系统内存压力杀死其他app），发现通知停了，打开app一看，经历了闪屏，说明应用被杀掉了。<br>因此，在这里可以进行一个猜想，<strong>使用background mode并不能保证应用不会被系统杀死。</strong></p>
<p>那么location update的后台执行到底是怎么实现呢？我们来看看<code>startMonitoringSignificantLocationChanges</code>的方式。<br>既然API文档说在应用被终止时会重启app，并且调用<code>didFinishLaunchWithOptions</code>的代理，那么我们就在appDelegate里加上一个notification来做验证</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//收到位置消息时唤醒app</span></div><div class="line">    <span class="keyword">if</span> (launchOptions[<span class="built_in">UIApplicationLaunchOptionsLocationKey</span>]) &#123;</div><div class="line">        <span class="built_in">UILocalNotification</span> *noti = [<span class="built_in">UILocalNotification</span> new];</div><div class="line">        <span class="keyword">self</span>.strongRef = [BMLocationManager new];</div><div class="line">        noti.alertTitle = <span class="string">@"嘿嘿"</span>;</div><div class="line">        noti.alertBody = <span class="string">@"新的位置来了，app后台启动"</span>;</div><div class="line">        noti.soundName = <span class="built_in">UILocalNotificationDefaultSoundName</span>;</div><div class="line">        [application scheduleLocalNotification:noti];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>更新app，再次启动，接着直接杀死。发现确实调用了appDelegate。那么这个启动过程和一般的启动过程有什么不同呢？我们利用hook，在viewController里增加log，看看其调用过程。<br>log的配置使用了Aspects这个基于AOP的第三方框架。<br>AOP的方式在这类验证性的工作是非常有帮助的，保持了原有代码的整洁性。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (<span class="keyword">void</span>)makeHook</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSArray</span> *selectors = @[<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(init)),</div><div class="line">                           <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(awakeFromNib)),</div><div class="line">                           <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(viewDidLoad)),</div><div class="line">                           <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(viewWillAppear:)),</div><div class="line">                           <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(viewDidAppear:)),</div><div class="line">                           <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(viewWillDisappear:)),</div><div class="line">                           <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(viewDidDisappear:))];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *selectorStr <span class="keyword">in</span> selectors) &#123;</div><div class="line">        [<span class="keyword">self</span> hookClass:[<span class="built_in">UIViewController</span> <span class="keyword">class</span>] forSelector:<span class="built_in">NSSelectorFromString</span>(selectorStr)];</div><div class="line">    &#125;</div><div class="line">    selectors = @[<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(init)),</div><div class="line">                  <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(centralManager:willRestoreState:))];</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *selectorStr <span class="keyword">in</span> selectors) &#123;</div><div class="line">        [<span class="keyword">self</span> hookClass:[BMCentralManager <span class="keyword">class</span>] forSelector:<span class="built_in">NSSelectorFromString</span>(selectorStr)];</div><div class="line">    &#125;</div><div class="line">    selectors = @[<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(init)),</div><div class="line">                  <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(locationManager:didUpdateLocations:))];</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *selectorStr <span class="keyword">in</span> selectors) &#123;</div><div class="line">        [<span class="keyword">self</span> hookClass:[BMLocationManager <span class="keyword">class</span>] forSelector:<span class="built_in">NSSelectorFromString</span>(selectorStr)];</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span> hookClass:[<span class="built_in">UIWindow</span> <span class="keyword">class</span>] forSelector:<span class="keyword">@selector</span>(makeKeyAndVisible)];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)hookClass:(Class)aCass forSelector:(SEL)selecotr</div><div class="line">&#123;</div><div class="line">    [aCass aspect_hookSelector:selecotr withOptions:AspectPositionBefore usingBlock:^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@ call %@"</span>, [aspectInfo instance], <span class="built_in">NSStringFromSelector</span>(selecotr));</div><div class="line">    &#125;error:<span class="literal">nil</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来再次执行相同的步骤，看看log都输出了些什么？<br>发现一个viewController的完整生命周期都输出了。说明在后台启动的时候，并没有走什么特殊通道，而是按照正常的流程一直到等待UI输入的步骤。因此我们的app如果需要实现类似的后台运行模式，那么app delegate的设计就需要考虑到后台运行的情况了。</p>
<p>接下来再看，应用后台启动之后，我们手动打开app，又发生了什么事？<br>app又调用了闪屏，查看log，发现又重新来了一次启动流程。查看application的地址，发现不是同一个地址，说明手动开启app之后，系统把后台启动的应用给释放掉了。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>在location mode的后台执行模式下，应用并不会常驻在后台，而是与普通应用相同，随时会被killed。<br>想要达到类似常驻后台的效果，需要使用<code>startMonitoringSignificantLocationChanges</code>方法，在更新location时，系统会重启应用，使其处于后台模式。<br>应用启动时，与正常启动直到等待UI输入的流程无异。</p>
<h1 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h1><h2 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h2><p>在调试蓝牙后台时，需要验证是否真的唤醒了APP，但是调试模式下没办法进入suspend的状态，而双击home健手动杀掉进程，也同样不会唤醒APP，此时连蓝牙也会立即结束。因此需要进入suspend状态时，可以使用<br><code>kill(getpid(), SIGKILL)</code>方法模拟系统因为内存压力等原因结束进程的方式</p>
<h2 id="APNS"><a href="#APNS" class="headerlink" title="APNS"></a>APNS</h2><p>APNS需要在content-available为true，并且开启remote-notification的时候才会支持后台模式</p>
<p>当iOS收到一条push消息时，如果payload里包含content-available = true，那么会发生下面的事情</p>
<ul>
<li>如果app处于suspended状态，那么系统会把app置为background状态</li>
<li>如果app是是通过app switcher的方式被用户杀掉了，则不会启动app</li>
</ul>
<h2 id="关于后台启动"><a href="#关于后台启动" class="headerlink" title="关于后台启动"></a>关于后台启动</h2><p>后台启动根据不同的模式也会有不同的区别，一般情况下，只有应用处于suspended状态下的时候，才能够启动为background，对于force quit的应用，是不会生效的。目前来说，唯一例外的只有iOS 8之后的location模式会启动应用<br><img src="./1477103337238.png" alt="Alt text"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/01/09/getting-start-core-data/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mluffy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mluffy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/01/09/getting-start-core-data/" itemprop="url">CoreData 入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-01-09T20:26:18+08:00">
                2015-01-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章对平时项目开发中容易理解错误，以及碰到的坑进行了归纳总结，理解完本篇文章的内容算不上精通，但是已经算是正确入门了吧。</p>
<h1 id="CoreData的特性"><a href="#CoreData的特性" class="headerlink" title="CoreData的特性"></a>CoreData的特性</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>官网里对core data的表述是这样的：</p>
<blockquote>
<p>The Core Data framework provides generalized and automated solutions<br>to common tasks associated with object life-cycle and object graph<br>management, including persistence.</p>
</blockquote>
<p>所以呢，core data，是一个关于数据的解决方案，他帮助我们定义并管理一个对象的生命周期和数据之间的关系。数据关系很好理解，他定义的关系和SQL相似，略有区别的地方在于CoreData中的数据关系都是双向的，具体在下边的开始使用章节会提到。</p>
<h2 id="CoreData组件"><a href="#CoreData组件" class="headerlink" title="CoreData组件"></a>CoreData组件</h2><p>CoreData有三大组件，理解三个组件的关系对了解CoreData的全貌有非常大的帮助。<br><img src="./1416815008789.png" alt="Alt text"></p>
<h3 id="NSPersistenStoreCoordinator"><a href="#NSPersistenStoreCoordinator" class="headerlink" title="NSPersistenStoreCoordinator"></a>NSPersistenStoreCoordinator</h3><p>官网描述是这么说的：</p>
<blockquote>
<p>Instances of NSPersistentStoreCoordinator associate persistent stores<br>(by type) with a model (or more accurately, a configuration of a<br>model) and serve to mediate between the persistent store or stores and<br>the managed object context or contexts. Instances of<br>NSManagedObjectContext use a coordinator to save object graphs to<br>persistent storage and to retrieve model information. A context<br>without a coordinator is not fully functional as it cannot access a<br>model except through a coordinator. The coordinator is designed to<br>present a façade to the managed object contexts such that a group of<br>persistent stores appears as an aggregate store. A managed object<br>context can then create an object graph based on the union of all the<br>data stores the coordinator covers.</p>
</blockquote>
<p><code>NSPersistentStoreCoordinator</code>顾名思义，是一个持久化层（如SQL数据库）和内存（<code>NSManagedObjectContext</code>）之间的一个数据解析层。他的职责就是根据<code>NSManagedObjectModel</code>里的配置信息，将数据转化成对应层能够解析的样子。<br>从他的使用里，也证实了这一点。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSPersistentStoreCoordinator</span> *persistentStoreCoordinator = [[<span class="built_in">NSPersistentStoreCoordinator</span> alloc] initWithManagedObjectModel:[<span class="keyword">self</span> managedObjectModel]];<span class="comment">//根据NSManagedObjectModel初始化一个解释器</span></div><div class="line">[persistentStoreCoordinator addPersistentStoreWithType:<span class="built_in">NSSQLiteStoreType</span> configuration:<span class="literal">nil</span> URL:storeURL options:<span class="literal">nil</span> error:&amp;error]<span class="comment">//为解释器设置一个持久化存储类型，这里把持久化存储设置为了SQLite类型。</span></div></pre></td></tr></table></figure>
<p>从这个接口也能够发现，CoreData是可以支持SQL以外的存储方式的！<br>注意<code>addPersistentStoreWithType:</code>的命名，参照章节开始的图，我们发现<code>NSPersistentStoreCoordinator</code>是可以支持多一个持久化类型的，当然多个持久化类型的方式在iOS的开发中并不多见。<br>目前CoreData所支持的类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">COREDATA_EXTERN NSString * const NSSQLiteStoreType NS_AVAILABLE(10_4, 3_0);</div><div class="line">COREDATA_EXTERN NSString * const NSXMLStoreType NS_AVAILABLE(10_4, NA);</div><div class="line">COREDATA_EXTERN NSString * const NSBinaryStoreType NS_AVAILABLE(10_4, 3_0);</div><div class="line">COREDATA_EXTERN NSString * const NSInMemoryStoreType NS_AVAILABLE(10_4, 3_0);</div></pre></td></tr></table></figure></p>
<h3 id="NSManagedObjectModel"><a href="#NSManagedObjectModel" class="headerlink" title="NSManagedObjectModel"></a>NSManagedObjectModel</h3><p>官方描述如下：</p>
<blockquote>
<p>Models describe object graphs to be managed. Models (and their<br>entities/properties/fetch request templates) are editable until they<br>are used by a persistent store coordinator, allowing developers to<br>create/modify them dynamically. However, once a model is being used,<br>it MUST NOT be changed. When the persistent store coordinator first<br>fetches data using a model, it will become uneditable. Any attempt to<br>mutate a model or any of its subobjects after that point will cause an<br>exception to be thrown. If you need to modify a model that is in use,<br>create a copy, modify the copy, and then discard the objects with the<br>old model.</p>
</blockquote>
<p><code>NSManagedObjectModel</code>顾名思义，是一个对象模板，他描述了对象的数据结构以及数据之间的关系</p>
<h3 id="NSMnagedObjectContext"><a href="#NSMnagedObjectContext" class="headerlink" title="NSMnagedObjectContext"></a>NSMnagedObjectContext</h3><p>官方描述：</p>
<blockquote>
<p>An instance of NSManagedObjectContext represents a single “object<br>space” or scratch pad in an application. Its primary responsibility is<br>to manage a collection of managed objects. These objects form a group<br>of related model objects that represent an internally consistent view<br>of one or more persistent stores. A single managed object instance<br>exists in one and only one context, but multiple copies of an object<br>can exist in different contexts. Thus object uniquing is scoped to a<br>particular context.</p>
</blockquote>
<p>他是对象的管理者，管理内存中<code>注册</code>在这个context下的所有对象，包括他的生命周期和状态。注册这个地方很有意思，在一个application中，可以存在不止一个context，持久化层里的同一个数据也可以被注册在不同的context中。这么做有什么好处呢，在context的章节会详细表述</p>
<h1 id="开始使用CoreData"><a href="#开始使用CoreData" class="headerlink" title="开始使用CoreData"></a>开始使用CoreData</h1><p>关于入门的使用，网上有很多，随便一搜就是一大把，可参考<a href="http://www.cnblogs.com/xiaodao/archive/2012/10/08/2715477.html" target="_blank" rel="external">这个</a></p>
<h2 id="使用MagicalRecord"><a href="#使用MagicalRecord" class="headerlink" title="使用MagicalRecord"></a>使用MagicalRecord</h2><p>一般情况下，core data在使用时会出现非常多重复的代码，身为程序猿，都有有一颗偷懒的心，拒绝重复的工作，所以MagicalRecord（业界简称MR）应运而生。<br>MR提供了非常简便的API，帮助我们创建，保存，检索对象。并且他在初始化时定义了一个基本的context架构，具体会在<strong><em>Context</em></strong>章节中提到。<br>关于MR的具体操作，他的<a href="https://github.com/magicalpanda/MagicalRecord/blob/develop/Docs/Getting-Started.md" target="_blank" rel="external">wiki</a>有着详细的描述。<br>关于 MR 的一些坑，可以参考<a href="/core-data-with-magical-record">CoreData 与 MagicalRecord的故事这篇文章</a></p>
<h2 id="使用Mogenerator"><a href="#使用Mogenerator" class="headerlink" title="使用Mogenerator"></a>使用Mogenerator</h2><p>由于<code>NSManagedObject</code>的生成是一个手动的过程，因此在我们修改<code>DataModel</code>后，之前已经生成的<code>NSManagedObject</code>并不能及时更新，必须要手动重新生成新的类文件。但是问题来了，我们可能在对应的object class里新增了一些通用方法以便我们更容易的操作object，但是重新生成类文件并不会保留我们的修改。因此在更新<code>DataModel</code>的操作变得尤其麻烦。<br>偷懒的程序员们由此写了一个工具，根据<code>DataModel</code>自动生成<code>NSManagedObject</code>，并且通过继承的方式，将core data自动生成的属性方法和人为添加的属性方法区别开来。这就是<a href="http://rentzsch.github.io/mogenerator/" target="_blank" rel="external">Mogenrator</a></p>
<p>Mogenrator可以根据预设的模板，生成对应的<code>NSManagedObject class</code>，我们可以通过Xcode的runscript脚本，实现在编译期间更新<code>DataModel</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">MODELS_DIR=<span class="string">"<span class="variable">$&#123;PROJECT_DIR&#125;</span>/<span class="variable">$PROJECT_NAME</span>"</span></div><div class="line">DATA_MODEL_PACKAGE=<span class="string">"<span class="variable">$MODELS_DIR</span>/CoreDataDemo.xcdatamodeld/CoreDataDemo.xcdatamodel"</span></div><div class="line"><span class="comment"># - 替换相应的 xxxxx.xcdatamodeld名称</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ -x /usr/<span class="built_in">local</span>/bin/mogenerator ]; <span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"mogenerator exists in /usr/local/bin path"</span>;</div><div class="line">MOGENERATOR_DIR=<span class="string">"/usr/local/bin"</span>;</div><div class="line"><span class="keyword">elif</span> [ -x /usr/bin/mogenerator ]; <span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"mogenerator exists in /usr/bin path"</span>;</div><div class="line">MOGENERATOR_DIR=<span class="string">"/usr/bin"</span>;</div><div class="line"><span class="keyword">else</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"mogenerator not found"</span>; <span class="built_in">exit</span> 1;</div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="variable">$MOGENERATOR_DIR</span>/mogenerator --template-var arc=<span class="literal">true</span> -m <span class="string">"<span class="variable">$DATA_MODEL_PACKAGE</span>"</span> -M <span class="string">"<span class="variable">$MODELS_DIR</span>/CoreData/Machine/"</span> -H <span class="string">"<span class="variable">$MODELS_DIR</span>/CoreData/Human/"</span></div><div class="line"><span class="comment"># 如果是ARC工程，加上 --template-var arc=true就行了，即mogenerator命令换成：</span></div><div class="line"><span class="comment"># $MOGENERATOR_DIR/mogenerator --template-var arc=true -m "$DATA_MODEL_PACKAGE" -M "$MODELS_DIR/CoreData/Machine/" -H "$MODELS_DIR/CoreData/Human/"</span></div></pre></td></tr></table></figure>
<p>顺便做一个广告，在<a href="http://x.gz.cvte.cn/luhui/iosprojectscript" target="_blank" rel="external">gitlab</a>的项目集合了一些项目相关的脚本，你又可以再偷懒一点了：）</p>
<h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><p>Context是贯穿在整个应用之间的core data组件，在实际的项目中，只有在初始化的时候才会用到其他两个组件，甚至在使用MR后，我们都不再需要关心除开context外的组件了。</p>
<h2 id="多个context下的数据更新"><a href="#多个context下的数据更新" class="headerlink" title="多个context下的数据更新"></a>多个context下的数据更新</h2><p>每个context都是一块独立的内存空间，那么如何把一个context中某个对象的修改通知到另一个context中呢？<br>在<code>NSManagedObjectContext.h</code>中定义了以下几个notification<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// Notifications immediately before and immediately after the context saves.  The user info dictionary contains information about the objects that changed and what changed</div><div class="line">COREDATA_EXTERN NSString * const NSManagedObjectContextWillSaveNotification NS_AVAILABLE(10_5, 3_0);</div><div class="line">COREDATA_EXTERN NSString * const NSManagedObjectContextDidSaveNotification NS_AVAILABLE(10_4, 3_0);</div><div class="line"></div><div class="line">// Notification when objects in a context changed:  the user info dictionary contains information about the objects that changed and what changed</div><div class="line">COREDATA_EXTERN NSString * const NSManagedObjectContextObjectsDidChangeNotification NS_AVAILABLE(10_4, 3_0);</div></pre></td></tr></table></figure></p>
<p>保存的通知很好理解，就是调用context的save接口时调用。那么<code>NSManagedObjectContextObjectsDidChangeNotification</code>是在何时调用呢？<br>他不是在某个对象被修改时调用，而是在调用<code>processPendingChanges</code>时触发的。那么<code>processPendingChanges</code>又是在什么时候调用呢？只有这个context是一个main thread的context时才会自动触发。而属于其他线程的context，则必须要自己调用。<br>在<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreData/Articles/cdConcurrency.html" target="_blank" rel="external">这篇文章</a>的<strong>Track Changes in Other Threads Using Notifications</strong>章节有提到。<br>并且在这个过程中，有一个地方需要注意。假设某个实体对象发生了改变，而这个实体对象在一个main thread context中是<code>Fault</code>状态，那么这个notification也不会触发。因为在<code>Fault</code>状态说明这个实体对象还没有被使用，那么也就没有触发这个通知的必要了。则一点在平时的使用过程中一般不会在意，而在单元测试中，需要模拟一些数据操作并侦听这个通知时，是需要注意的地方。</p>
<h2 id="层级结构"><a href="#层级结构" class="headerlink" title="层级结构"></a>层级结构</h2><p>context的层级结构在复杂的项目中尤其重要。他是iOS5之后出来的，称为Nested Context，为了解决多线程下的数据同步问题。<br>在一个简单的项目里，可能只需要一个context就能够解决所有的问题，但是在涉及到多线程后，一个context会造成主线程的阻塞，并且在高并发的情况下，有可能造成死锁<br>关于context的架构，先看<a href="http://www.nsguy.com/blog/2014/02/09/learning-core-data/" target="_blank" rel="external">这篇文章</a></p>
<h3 id="MR中的层级结构"><a href="#MR中的层级结构" class="headerlink" title="MR中的层级结构"></a>MR中的层级结构</h3><p>在MR中，他使用的context结构是：<br><img src="./1416820705812.png" alt="Alt text"><br><img src="./1416820847757.png" alt="Alt text"><br>两个策略的结合体。<br>首先，在<code>[MagicalRecord setup]</code>中，会创建rootContext和defaultContext，<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">void</span>) MR_initializeDefaultContextWithCoordinator:(<span class="built_in">NSPersistentStoreCoordinator</span> *)coordinator;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (defaultManagedObjectContext_ == <span class="literal">nil</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSManagedObjectContext</span> *rootContext = [<span class="keyword">self</span> MR_contextWithStoreCoordinator:coordinator];</div><div class="line">        [<span class="keyword">self</span> MR_setRootSavingContext:rootContext];</div><div class="line"></div><div class="line">        <span class="built_in">NSManagedObjectContext</span> *defaultContext = [<span class="keyword">self</span> MR_newMainQueueContext];</div><div class="line">        [<span class="keyword">self</span> MR_setDefaultContext:defaultContext];</div><div class="line"></div><div class="line">        [defaultContext setParentContext:rootContext];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接着，在其context的便捷构造器中，返回的是defaultContext的childContext</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSManagedObjectContext</span> *) MR_context;</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSManagedObjectContext</span> *context = [[<span class="keyword">self</span> alloc] initWithConcurrencyType:<span class="built_in">NSPrivateQueueConcurrencyType</span>];</div><div class="line">    [context setParentContext:[<span class="keyword">self</span> MR_defaultContext]];</div><div class="line">    <span class="keyword">return</span> context;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个顺序的方式，提供了一个stack2的context架构<br>最后MR在<code>[MagicalRecord save]</code>方法中，使用的是stack3的方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">+ (void) saveWithBlock:(void(^)(NSManagedObjectContext *localContext))block completion:(MRSaveCompletionHandler)completion;</div><div class="line">&#123;</div><div class="line">    NSManagedObjectContext *mainContext  = [NSManagedObjectContext MR_rootSavingContext];</div><div class="line">    NSManagedObjectContext *localContext = [NSManagedObjectContext MR_contextWithParent:mainContext];</div><div class="line"></div><div class="line">    [localContext performBlock:^&#123;</div><div class="line">        if (block) &#123;</div><div class="line">            block(localContext);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        [localContext MR_saveWithOptions:MRSaveParentContexts completion:completion];</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>MR中，在<code>setDefaultContext:</code>时会增加一个rootContext的<code>NSManagedObjectContextDidSaveNotification</code>事件侦听，并在在主线程中merge这些修改</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">void</span>)rootContextChanged:(<span class="built_in">NSNotification</span> *)notification &#123;</div><div class="line">    <span class="keyword">if</span> ([<span class="built_in">NSThread</span> isMainThread] == <span class="literal">NO</span>) &#123;</div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [<span class="keyword">self</span> rootContextChanged:notification];</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    [[<span class="keyword">self</span> MR_defaultContext] mergeChangesFromContextDidSaveNotification:notification];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="我们在用的层级结构"><a href="#我们在用的层级结构" class="headerlink" title="我们在用的层级结构"></a>我们在用的层级结构</h3><p>结合MR，推荐使用的是如下的结构<br><img src="./1416819723339.png" alt="Alt text"></p>
<p>MR在setup时会创建一个Root context和default context，如上图左边部分。在应用中，我们通过default context进行读的操作，在editing context中进行读写操作。<br>在需要更新UI的部分，通过侦听<code>NSManagedObjectContextDidChangeNotification</code>以更新UI<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span> addObserverForName:<span class="built_in">NSManagedObjectContextObjectsDidChangeNotification</span> object:[<span class="built_in">NSManagedObjectContext</span> MR_defaultContext] usingBlock:^(<span class="built_in">NSNotification</span> *notification) &#123;</div><div class="line"><span class="comment">// Update UI operation</span></div><div class="line">        &#125;</div><div class="line">    &#125;];</div></pre></td></tr></table></figure></p>
<p>但是如此的侦听会有个问题，所有在defaultContext注册的object在change时都会触发这个通知，因此还需要在更新UI之前做一个判断：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)contextChange:(<span class="built_in">NSNotification</span> *)notification forEntityName:(<span class="built_in">NSString</span> *)entityName</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSSet</span> *deleteObject = notification.userInfo[<span class="built_in">NSDeletedObjectsKey</span>];</div><div class="line">    <span class="built_in">NSSet</span> *updateObject = notification.userInfo[<span class="built_in">NSUpdatedObjectsKey</span>];</div><div class="line">    <span class="built_in">NSSet</span> *insertObject = notification.userInfo[<span class="built_in">NSInsertedObjectsKey</span>];</div><div class="line"></div><div class="line">    <span class="built_in">NSPredicate</span> *predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"entity.name == %@"</span>, entityName];</div><div class="line"></div><div class="line">    <span class="built_in">NSUInteger</span> deleteCount = [[[deleteObject allObjects] filteredArrayUsingPredicate:predicate] count];</div><div class="line">    <span class="built_in">NSUInteger</span> updateCount = [[[updateObject allObjects] filteredArrayUsingPredicate:predicate] count];</div><div class="line">    <span class="built_in">NSUInteger</span> insertCount = [[[insertObject allObjects] filteredArrayUsingPredicate:predicate] count];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> (deleteCount + updateCount + insertCount != <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>抛出通知时，CoreData会将当前context所有变动的对象通过userInfo返回。因此我们可以通过检测这些对象中是否包含我们所需要侦听改变的对象来决定是否需要更新UI。</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>CoreData下的多线程，官方有很好的<a href="https://developer.apple.com/library/mac/documentation/cocoa/conceptual/CoreData/Articles/cdConcurrency.html" target="_blank" rel="external">解释</a><br>使用Thread Confinement的方式可以避免死锁。但这并不是必须的，所以这是一个编程规范，而不是规则。因此在使用多线程时是需要注意的。<br>如何保证Thread Confinement？使用context的performBlock方法。<br>那么这些context的thread是否需要维护呢？<br>看一个实验.<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSManagedObjectContext</span> *c1 = [<span class="built_in">NSManagedObjectContext</span> MR_context];</div><div class="line">    <span class="built_in">NSManagedObjectContext</span> *c2 = [<span class="built_in">NSManagedObjectContext</span> MR_rootSavingContext];</div><div class="line">    <span class="built_in">NSManagedObjectContext</span> *c3 = [<span class="built_in">NSManagedObjectContext</span> MR_contextWithParent:c2];</div><div class="line">    [c1 performBlock:^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"c1 Thread:%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    &#125;];</div><div class="line">    [c2 performBlock:^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"c2 Thread:%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    &#125;];</div><div class="line">    [c3 performBlock:^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"c3 Thread:%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    &#125;];</div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Thread in dispatch:%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        [c1 performBlock:^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"c1 Thread in dispatch:%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        &#125;];</div><div class="line">    &#125;);</div><div class="line">    [[<span class="built_in">NSManagedObjectContext</span> MR_defaultContext] performBlock:^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"default thread:%@ and main thread:%@"</span>, [<span class="built_in">NSThread</span> currentThread], [<span class="built_in">NSThread</span> mainThread]);</div><div class="line">    &#125;];</div></pre></td></tr></table></figure></p>
<p>三个context均在主线程中创建，打印结果如下：<br><img src="./1416823640132.png" alt="Alt text"></p>
<p>###Context的初始化<br>Context的初始化有三种类型</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSConfinementConcurrencyType</span>		= <span class="number">0x00</span>,    <span class="comment">/* this option is obsolete and not recommended for new code. */</span></div><div class="line">    <span class="built_in">NSPrivateQueueConcurrencyType</span>		= <span class="number">0x01</span>,</div><div class="line">    <span class="built_in">NSMainQueueConcurrencyType</span>			= <span class="number">0x02</span></div></pre></td></tr></table></figure>
<p>第一种是不支持多线程，context只能在当前线程下使用，现在已经不推荐使用了。后两个是当前常用的方式。在MR中，defaultContext是<code>NSMainQueueConcurrencyType</code><br>其他的context是<code>NSPrivateQueueConcurrencyType</code><br>在MR下，除非使用defaultContext，其余context中注册的object，在访问时最好使用performBlock调用会context的线程中，避免产生死锁。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><ol>
<li><p>使用MR时，在其他线程调用defaultContext进行保存会产生死锁。因为save时锁了主线程，而save后会触发<code>NSManagedObjectContextDidChangeNotification</code>，这时MR会调用<code>mergeChangeWithDidSaveNotification:</code>把修改更新到主线程上，这就导致死锁</p>
 <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[account.managedObjectContext performBlockAndWait:^&#123;</div><div class="line">    [account MR_deleteEntity];</div><div class="line">    [[account managedObjectContext] MR_saveToPersistentStoreAndWait];</div><div class="line">&#125;];</div><div class="line">因此保存上述代码风格是个好习惯</div></pre></td></tr></table></figure>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/12/02/git-getting-start/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mluffy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mluffy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/12/02/git-getting-start/" itemprop="url">git 入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-12-02T20:18:57+08:00">
                2014-12-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>每个人都有自己独特的学习技巧。于我来说，学习任何东西，都是先知其用法，再从基础开始，先懂其形，再观其意。这样做的好处就是能够非常快速的先踏入你所学习的领域，并将所得快速的纳入到自己现有的领域中来。这在工作中会非常受用，毕竟一个项目周期内，很难会给你充裕的时间从头到尾的了解新的知识。但是如此有一个很大的缺点，让人很容易浮躁，认为这一门学问很简单，很快就能掌握，到头来踩下无数的坑，每天去擦自己的屁股，于是才有了这篇文章。<br>在把自己的所得写成文章，必然需要把模糊的地方弄明白。慢慢的，不清晰的地方变清晰，对于这份知识的应用也越来越得心应手，终于，在文章结尾之时，这份知识才慢慢沉淀为自己的一部分，人也变得沉稳。这才是这篇文章最初的目的。</p>
<h1 id="源起"><a href="#源起" class="headerlink" title="源起"></a>源起</h1><p>同生活中的许多伟大事件一样，Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。到 2002 年，整个项目组开始启用分布式版本控制系统 BitKeeper 来管理和维护代码。</p>
<p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds ）不得不吸取教训，只有开发一套属于自己的版本控制系统才不至于重蹈覆辙。他们对新的系统制订了若干目标：</p>
<ul>
<li>速度</li>
<li>简单的设计</li>
<li>对非线性开发模式的强力支持（允许上千个并行开发的分支）</li>
<li>完全分布式</li>
<li>有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</li>
</ul>
<p>自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。它的速度飞快，极其适合管理大项目，它还有着令人难以置信的非线性分支管理系统，可以应付各种复杂的项目开发需求。</p>
<p>教科书里说：人和动物的区别就在于人类会使用工具。纵观伟大的产品的历史，都是为了提高工作效率而催生出来的产物。<br>在这个缺乏创新，control+c，control+v大行其道的时代，从身边的小事做起，致力于提高每一个细节的质量，也许一项为的产品就这么不经意间就诞生了。</p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>基础篇其实是我在学习git时遇到的疑问，并非传统的git基础。</p>
<h2 id="git特性"><a href="#git特性" class="headerlink" title="git特性"></a>git特性</h2><p>学习一门知识，最先需要了解的就是他的特点在哪里，这是我们能够快速评估他是否符合我们需求的一个方法。</p>
<h3 id="直接快照记录，而非差异比较"><a href="#直接快照记录，而非差异比较" class="headerlink" title="直接快照记录，而非差异比较"></a>直接快照记录，而非差异比较</h3><p>传统的VCS(如CVS,Subversion,Perforce,Bazaar)都是在各个版本中记录各个文件的具体差异，而git是保存每次更新时的文件快照。如此做法有什么好处呢？我们在分支处再说明</p>
<h3 id="时刻保持数据完整性"><a href="#时刻保持数据完整性" class="headerlink" title="时刻保持数据完整性"></a>时刻保持数据完整性</h3><p>如之前所说，git直接保存快照记录，那么他是如何判断文件是否更改的呢？<br>我们来看一看他的索引算法：<br>1.保存之前对所有数据进行checksum，并以结果作为数据的唯一标识和索引<br>2.使用SHA-1算法，通过文件内容和目录结构进行计算，得到一个SHA-1哈希值，作为指纹字符串。由40个16进制数组成（如：0e79d26c3c0abc43c135e4a33d2a4a94171d0da4）<br>3.所有保存在git数据库中的文件都是通过哈希值进行索引<br>通过他的索引算法，我们就清楚了为什么git的差异比较是如何实现的。所以git不会放过任何一个修改，即时是加了一个空格，文件的文件名，后缀，last modified属性被修改，git都会认为文件已经被修改。</p>
<h3 id="多数操作仅是添加数据"><a href="#多数操作仅是添加数据" class="headerlink" title="多数操作仅是添加数据"></a>多数操作仅是添加数据</h3><p>任何一种不可逆的操作，比如删除，都会使回退，或者重现历史版本变得困难重重。想象一下把计算机上的文件删除，而不是放入回收站，想要恢复就必须下载专业的恢复软件。常用的git操作都是只是简单的添加至数据库，然后保存快照。即时是git reset –hard的操作都是如此。这样在回退版本的时候就异常的简单。<br>我们来看一下git reflog的记录：<br>``</p>
<h2 id="四种文件状态"><a href="#四种文件状态" class="headerlink" title="四种文件状态"></a>四种文件状态</h2><h3 id="committed"><a href="#committed" class="headerlink" title="committed"></a>committed</h3><p>commit状态标识文件已经被快照记录，可以在版本库中回溯了</p>
<h3 id="staged"><a href="#staged" class="headerlink" title="staged"></a>staged</h3><p>已经被git add标记的文件，使用commit命令时会将处于这个状态的文件加入快照中。相当于预提交，通常我们称为暂存区。</p>
<h3 id="modified"><a href="#modified" class="headerlink" title="modified"></a>modified</h3><p>在最近的一个commit中存在的文件，当被修改时会处于modified状态。已经处于staged状态的文件，如果再次被修改，会同时出现在staged和modified状态。这个状态我们称为git的工作区</p>
<h3 id="untracked"><a href="#untracked" class="headerlink" title="untracked"></a>untracked</h3><p>在最近的一个commit中不存在的文件，处于没有被git追踪的状态，此文件git是不会去checksum的</p>
<h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><p>branch（分支）被称为git的必杀技。<br>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。在很多版本控制系统中，这是个昂贵的过程，常常需要创建一个源代码目录的完整副本，对大型项目来说会花费很长时间。<br>git的快照方式很好的支持了branch。新建一个branch，其实仅仅是在当前的commit号上创建了一个新的别名。今后在当前branch的操作中，就与在主分支一样的操作方式。所以每个branch都是相对独立的。从算法效率的角度来看，git的算法是通过牺牲空间来换取了时间。</p>
<h2 id="分支的操作"><a href="#分支的操作" class="headerlink" title="分支的操作"></a>分支的操作</h2><p>1.branch<br>~创建，查看，删除分支~<br>2.checkout<br>~切换，创建分支~<br>3.merge<br>~合并分支~<br>4.rebase<br>~衍合分支~<br>5.cherry-pick<br>~合并一/多个commit~</p>
<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>每个git项目，在其根目录下边都会有一个.git文件，里边存储着所有版本信息。下面我们就通过git的目录结构来研究他的实现机制。<br>一个典型的git目录结构如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ ls</div><div class="line">HEAD			保存当前分支最新的commit id</div><div class="line">branches/		分支信息，在新版本中已废弃</div><div class="line">config			当前git项目的配置信息</div><div class="line">description		仅供gitweb使用，具体用法还没有去了解</div><div class="line">hooks/			保存客户端或服务器的钩子脚本</div><div class="line">index			文件保存了暂存区的信息</div><div class="line">info/			包含了一份不存在.gitignore文件中管理的忽略模式的全局可执行文件</div><div class="line">objects/		目录存储所有数据内容</div><div class="line">refs/			目录存储指向数据（分支）的提交对象的指针</div></pre></td></tr></table></figure></p>
<p>refs中的信息如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$cd refs</div><div class="line">$ls</div><div class="line">heads/			保存本地的分支所指向的最新commit</div><div class="line">remote/			远程仓库的分支所指向的最新commit</div><div class="line">tags/			每个tag对应的commit</div></pre></td></tr></table></figure></p>
<p>我们把git的版本控制想象成对一个单链表的管理。链表中的每一个节点就是每个版本的快照指针（即一个commit）,所有的结点有且只有一个指针，指向其上一个commit。这就是为什么git中只保留HEAD，而没有一个tail的原因。<br>那么以上的文件其实就是一个指针，指向了链表中的某处。<br>链表中的每一个结点都可以延伸出多个结点（对应了不同的分支）<br>以第一个commit作为头节点，那么HEAD就是指向了当前正在操作的分支的一个尾节点的tail pointer<br>refs中的文件就是保存了一些比较特殊的结点，比如某个分支的HEAD结点（heads），某个结点的别名（tags），镜像链表的所有HEAD结点（remote）<br>所以每个git操作都可以认为是对链表的操作。每个结点都保存在.git/objects中，只有在某个时刻，git会运行git gc操作去回收一部分没有被引用的结点。<br>因此理论上，不管做了什么操作（除了删除.git这种脑残操作），只要还保存着commit信息，那么就能够回到任意状态。</p>
<h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><h2 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h2><p>个人感觉，git还是通过命令行去使用更有感觉，但是分支的状态，提交的更改在原始的git下操作是比较复杂的，因此GUI工具还是必不可少。<br>1.在Mac下，通常使用的GUI有source tree，通常是查看git的一个分支状态，以及一些commit的修改信息。<br>2.gitk是一个轻量级的git状态查看工具，还支持查看commit的修改项，通常情况下是满足了平时的业务需求。但是缺点就是没有Retina版本的gitk，Mac党用起来相当难受。</p>
<h2 id="diff-tool"><a href="#diff-tool" class="headerlink" title="diff tool"></a>diff tool</h2><p>原生的diff方法只能简单查看哪些地方被修改，可操控性，可读性都不是那么好，因此我们还是需要配合一个工具来对比修改。<br>meld是比较常用的difftool。安装方式<a href="http://jonathandean.com/2010/09/installing-meld-diff-tool-on-os-x-snow-leopard-using-fink/" target="_blank" rel="external">请点击这里</a></p>
<h2 id="命令别名"><a href="#命令别名" class="headerlink" title="命令别名"></a>命令别名</h2><p>在<code>~/.gitconfig</code>文件下，保存着git的全局配置信息，我们可以在这个文件中添加alias来达到为操作制定别名的效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[alias]</div><div class="line">        ck = checkout</div><div class="line">        st = status</div><div class="line">        ba = branch -av</div><div class="line">        ct = commit</div></pre></td></tr></table></figure></p>
<p>在文件末尾添加以上操作后，git st就可以查看git当前的状态，git ba就能够看到所有分支的详细信息，快去开始你高效工作的第一步吧：）</p>
<h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p>伟大的开源，伟大的分享！<br>有大神写了一个git练习教程，图文并茂，对理解git非常有帮助。<a href="http://pcottle.github.io/learnGitBranching/" target="_blank" rel="external">传送门</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/11/24/core-data-with-magical-record/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mluffy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mluffy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/11/24/core-data-with-magical-record/" itemprop="url">CoreData与MagicalRecord的故事</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-11-24T20:38:08+08:00">
                2014-11-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近使用Core data在多线程下遇到了不少的坑，多数都是因为使用不规范所引起的，这里将从最常用的MOC做展开，谈谈多线程下如何正确的使用context。<br>p.s.这篇博客会持续不断的更新，主要是记录core data中踩到的坑，在踩坑中慢慢成长，不断规范core data的使用方法。</p>
<h1 id="NSManagedObjectContext"><a href="#NSManagedObjectContext" class="headerlink" title="NSManagedObjectContext"></a>NSManagedObjectContext</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>说到MOC，当然先要贴上一副描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">An instance of NSManagedObjectContext represents a single “object space” or scratch pad in an application. Its primary responsibility is to manage a collection of managed objects. These objects form a group of related model objects that represent an internally consistent view of one or more persistent stores. A single managed object instance exists in one and only one context, but multiple copies of an object can exist in different contexts. Thus object uniquing is scoped to a particular context.</div></pre></td></tr></table></figure>
<p>从字义上来说，他就是一个数据库的上下文，并且维持在内存中。<br>context可以创建多个，说明一个进程中，可以拥有多个数据库的内存副本，并且每个副本之间都是相对独立的。<br>其实从这一点来看，Core data的设计结构和git是相似的。persistent store类似git的中心仓库，每个moc都是git的分支，moc内的操作都互不影响，只有在save（git的push）时才会保存到persistent store（git中心仓库）中。</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">The context is a powerful object with a central role in the life-cycle of managed objects, with responsibilities from life-cycle management (including faulting) to validation, inverse relationship handling, and undo/redo. Through a context you can retrieve or “fetch” objects from a persistent store, make changes to those objects, and then either discard the changes or—again through the context—commit them back to the persistent store. The context is responsible for watching for changes in its objects and maintains an undo manager so you can have finer-grained control over undo and redo. You can insert new objects and delete ones you have fetched, and commit these modifications to the persistent store.</div><div class="line"></div><div class="line">All objects fetched from an external store are registered in a context together with a global identifier (an instance of NSManagedObjectID) that’s used to uniquely identify each object to the external store.</div></pre></td></tr></table></figure>
<p>作为对象的管理者，moc管理着所有注册在这个moc下的对象的生命周期（包括faulting）。并且提供了非常丰富的数据操作，基本的增查删改，还提供了了undo/redo的方法，极大的简化了开发时间。</p>
<h2 id="fault"><a href="#fault" class="headerlink" title="fault"></a>fault</h2><p>moc中的所有object都是lazy loading的，所有注册到moc的object一开始都是出于faulted的状态，只有在引用到object时才会真正从数据库中加载数据至内存中，这个过程叫fire fault。当一个object被从moc中移除后，他会被置为fault状态。</p>
<h2 id="重头戏：Parent-Store"><a href="#重头戏：Parent-Store" class="headerlink" title="重头戏：Parent Store"></a>重头戏：Parent Store</h2><p>parent store是用来告诉MOC，数据的来源，数据的读取保存操作最终都是在parent store中执行的。<br>在OSX10.7以及iOS5.0时代，Parent Store一直是persisten store coordinator<br>从OSX10.7以及iOS5.0之后，Parent Store就可以是context，相当于定义了一个parent 这个moc的数据操作最终只会影响到其parent context，这极大的简化了不同context之间数据的更新。在这之前一直只能用Notification的方式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></div><div class="line">                                      selector:<span class="keyword">@selector</span>(&lt;<span class="meta">#Selector name#&gt;)</span></div><div class="line">                                      name:<span class="built_in">NSManagedObjectContextDidSaveNotification</span></div><div class="line">                                      object:&lt;<span class="meta">#A managed object context#&gt;];</span></div></pre></td></tr></table></figure>
<p>我们可以在程序运行的断点中查看context的parent store</p>
<image src="http://drp.io/brC"></image>

<p>这个parent store最终的应用场景是怎样呢？我们在后边的Nested context中介绍</p>
<h1 id="MagicalRecord概述"><a href="#MagicalRecord概述" class="headerlink" title="MagicalRecord概述"></a>MagicalRecord概述</h1><p><a href="https://github.com/magicalpanda/MagicalRecord" target="_blank" rel="external">Magical Recrod</a>是git的一个第三方库，是一个对Core data数据操作的封装库，常用的core data操作都得到了极大的简化，是在使用core data时提高编程效率的不二之选。<br>除开对操作的封装之外，MR的另一大好处就是为我们封装了多线程之下的context</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSManagedObjectContext</span> *) MR_contextForCurrentThread;</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span> ([<span class="built_in">NSThread</span> isMainThread])</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">return</span> [<span class="keyword">self</span> MR_defaultContext];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span></div><div class="line">	&#123;</div><div class="line">		<span class="built_in">NSMutableDictionary</span> *threadDict = [[<span class="built_in">NSThread</span> currentThread] threadDictionary];</div><div class="line">		<span class="built_in">NSManagedObjectContext</span> *threadContext = [threadDict objectForKey:kMagicalRecordManagedObjectContextKey];</div><div class="line">		<span class="keyword">if</span> (threadContext == <span class="literal">nil</span>)</div><div class="line">		&#123;</div><div class="line">			threadContext = [<span class="keyword">self</span> MR_contextWithParent:[<span class="built_in">NSManagedObjectContext</span> MR_defaultContext]];</div><div class="line">			[threadDict setObject:threadContext forKey:kMagicalRecordManagedObjectContextKey];</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> threadContext;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从他的代码，可以很清楚的知道，MR为每个线程都创建了context，并且在线程的<code>threadDictionary</code>中维持context的引用。因此在线程回收之前，我们都可以放心的在这个线程中使用context，并且不用担心何时需要释放context的问题。<br>在MR中，初始化core data时，他的数据结构是这样的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">void</span>) MR_initializeDefaultContextWithCoordinator:(<span class="built_in">NSPersistentStoreCoordinator</span> *)coordinator;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (defaultManagedObjectContext_ == <span class="literal">nil</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSManagedObjectContext</span> *rootContext = [<span class="keyword">self</span> MR_contextWithStoreCoordinator:coordinator];</div><div class="line">        [<span class="keyword">self</span> MR_setRootSavingContext:rootContext];</div><div class="line">        <span class="built_in">NSManagedObjectContext</span> *defaultContext = [<span class="keyword">self</span> MR_newMainQueueContext];</div><div class="line">        [<span class="keyword">self</span> MR_setDefaultContext:defaultContext];</div><div class="line">        [defaultContext setParentContext:rootContext];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一个root context，所有的context都会是这个root context的child context。<br>在主线程创建一个default context，其parent context是root context，因此我们在使用core data时，在主线程下的操作都是用的是default context，最终的操作都会是先保存到root context中，再保存到数据库中。<br>具体的解释暂且不表，放在另一篇文章中详细解释使用MR时的一些操作事项</p>
<p>##多线程下的Core Data</p>
<p>###MOC的三种类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Confinement (NSConfinementConcurrencyType)</div><div class="line">默认状态，只能在创建的线程中使用，其他线程均不能使用。官方的API文档写到：</div><div class="line">You can only use this concurrency type if the managed object context’s parent store is a persistent store coordinator.</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Private queue (NSPrivateQueueConcurrencyType)</div><div class="line">用在多线程下。MR中的rootContext与threadContext均是这个类型</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Main queue (NSMainQueueConcurrencyType)</div><div class="line">用在主线程下。MR中的defaultContext是这个类型。这个类型的context多用在controller以及一些UI对象上，这些对象只能要求在主线程中操作，因此只能用此类型的context在主线程中操作。</div></pre></td></tr></table></figure>
<h2 id="使用Magical-Recrod时，多线程下应注意的点"><a href="#使用Magical-Recrod时，多线程下应注意的点" class="headerlink" title="使用Magical Recrod时，多线程下应注意的点"></a>使用Magical Recrod时，多线程下应注意的点</h2><ol>
<li>在不同的线程，可以使用任意的context进行读的操作，但是写的操作必须保证所有的object均处于同一个context，并且该context所维护的thread就是当前线程。否则在写的时候会出现概率性的崩溃。一个context不能同时被两个线程访问</li>
<li>不同线程之间的object传递使用objectWithId。在MR中，使用的是existingObjectWithId，也就是已经在context中注册的object才可以拿到<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSManagedObjectContext</span> *moc = [<span class="built_in">NSManagedObjectContext</span> MR_contextWithParent:[<span class="built_in">NSManagedObjectContext</span> MR_defaultContext]];</div><div class="line">Department *d = [Department MR_createInContext:moc];</div><div class="line"><span class="built_in">NSManagedObjectContext</span> *moc2 = [<span class="built_in">NSManagedObjectContext</span> MR_contextWithParent:[<span class="built_in">NSManagedObjectContext</span> MR_defaultContext]];</div><div class="line">Department *t = [d MR_inContext:moc2];</div><div class="line">Department *t2 = (Department *)[moc2 objectWithID:d.objectID];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"t:%@ and t2:%@"</span>, t, t2);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这个代码的输出结果为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">t:(null) and t2:&lt;Department: 0x109600580&gt; (entity: Department; id: 0x10f507590 &lt;x-coredata:///Department/t8F610E34-B04A-4152-A481-75818DEC7DE12&gt; ; data: &lt;fault&gt;)</div></pre></td></tr></table></figure></p>
<ol>
<li>多个context下，使用undo操作时就要慎用，有可能会多undo了某些操作。比如：<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSUndoManager</span> *undoManager = [<span class="built_in">NSUndoManager</span> new];</div><div class="line">    [[<span class="built_in">NSManagedObjectContext</span> MR_defaultContext] setUndoManager:undoManager];</div><div class="line">    [[[<span class="built_in">NSManagedObjectContext</span> MR_defaultContext] undoManager] beginUndoGrouping];</div></pre></td></tr></table></figure>
</li>
</ol>
<p>当在<code>beginUndoGrouping</code>后，开了一个线程进行了数据操作并保存:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        <span class="comment">//somthing data operation</span></div><div class="line">        [[<span class="built_in">NSManagedObjectContext</span> MR_contextForCurrentThread] MR_saveOnlySelfAndWait];</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></p>
<p>这时候数据会先更新至defaultContext中，再保存至数据库。如果我们只打算undo在主线程中的更改，调用<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[[[<span class="built_in">NSManagedObjectContext</span> MR_defaultContext] undoManager] endUndoGrouping];</div><div class="line">[[[<span class="built_in">NSManagedObjectContext</span> MR_defaultContext] undoManager] undo];</div></pre></td></tr></table></figure></p>
<p>进行回滚，会把线程中执行的操作一起回滚掉。因此这种业务需求下的undo应该使用另一个MOC进行处理，defaultContext作为最终同时保存的部分。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSUndoManager</span> *undoManager = [<span class="built_in">NSUndoManager</span> new];</div><div class="line"><span class="built_in">NSManagedObjectContext</span> *moc = [<span class="built_in">NSManagedObjectContext</span> MR_contextWithParent:[<span class="built_in">NSManagedObjectContext</span> MR_defaultContext]];</div><div class="line">[moc setUndoManager:undoManager];</div><div class="line">[[moc undoManager] beginUndoGrouping];</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="mluffy" />
          <p class="site-author-name" itemprop="name">mluffy</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/luhui" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mluffy</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
