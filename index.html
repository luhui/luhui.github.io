<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="懒人小屋">
<meta property="og:url" content="http://mlazy.club/index.html">
<meta property="og:site_name" content="懒人小屋">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="懒人小屋">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: 'Y7WOEP5F21',
      apiKey: 'b381145e3b0e8b27fa7576de9cb620bb',
      indexName: 'mlazy.club',
      hits: {"per_page":10},
      labels: {"input_placeholder":"搜索文章","hits_empty":"未找到与 ${query} 相关的文章","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://mlazy.club/"/>





  <title>懒人小屋</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-111245807-1', 'auto');
  ga('send', 'pageview');
</script>











</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">懒人小屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">为了偷懒而使用工具</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mlazy.club/2017/12/15/react-native-animation-anlaysis-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mluffy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人小屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/15/react-native-animation-anlaysis-summary/" itemprop="url">react-native 动画性能分析总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-15T19:33:40+08:00">
                2017-12-15
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/12/15/react-native-animation-anlaysis-summary/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2017/12/15/react-native-animation-anlaysis-summary/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          
             <span id="/2017/12/15/react-native-animation-anlaysis-summary/" class="leancloud_visitors" data-flag-title="react-native 动画性能分析总结">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在文章 <a href="/2017/12/15/react-native-animation-performance-tool-systrace/" title="react-native 下，Android动画性能分析工具-systrace">react-native 下，Android动画性能分析工具-systrace</a> 中，发现在当前项目，动画的不流畅感不是因为丢帧的因素影响到的。接着猜测可能是 react-native 的动画实现可能存在权限，因此对比了<a href="/2017/12/15/android-animation-principle/" title="android 动画原理">android 动画原理</a>、<a href="/2017/12/15/react-native-animated-principle/" title="react-native animated 动画实现原理">react-native animated 动画实现原理</a>。但是发现两边的实现思路是雷同的，性能差别也不会太大。接着猜测是否是因为导航库在动画使用上出现问题，我们分析了<a href="/2017/12/15/react-navigation-animation-principle/" title="react-navigation 动画实现原理">react-navigation 动画实现原理</a>，发现其使用方法也没问题。总结发现，以上的分析中，主要是分析了动画频率是否出现了问题，并没有验证中间生成的画面是否是连续的，因此猜测可能是在 react-native 的动画中，中间帧的渲染是异常的，导致动画过程中，虽然没有丢帧，但是由于画面不是连续的，让人产生不流畅的错觉。</p>
<h1 id="画面过程分析"><a href="#画面过程分析" class="headerlink" title="画面过程分析"></a>画面过程分析</h1><p>由于转场动画只涉及到了 translationX，因此可以看看是否是 translationX 的值有异常导致的。那么我们需要分别对比在 native 下，使用 animator 的 translationX 方案以及使用 react-native animated 的 translationX 方案在计算值的过程中是否有差别。</p>
<p>native 层很简单，通过 updateListener 记录中间值即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@TargetApi</span>(Build.VERSION_CODES.KITKAT)</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> View view = <span class="keyword">new</span> View(<span class="keyword">this</span>);</div><div class="line">    view.setBackgroundColor(Color.BLUE);</div><div class="line">    <span class="keyword">final</span> FrameLayout container = (FrameLayout) findViewById(R.id.container);</div><div class="line">    FrameLayout.LayoutParams params = <span class="keyword">new</span> FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);</div><div class="line">    container.addView(view, params);</div><div class="line">    mLastTranlationX = container.getWidth();</div><div class="line">    view.setTranslationX(container.getWidth());</div><div class="line">    view.animate().translationX(<span class="number">0</span>).setDuration(<span class="number">1000</span>).setUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</div><div class="line">            <span class="keyword">float</span> between = view.getTranslationX() - mLastTranlationX;</div><div class="line">            mLastTranlationX = view.getTranslationX();</div><div class="line">            Log.e(<span class="string">"lh"</span>, mLastTranlationX + <span class="string">"\t"</span> + between);</div><div class="line">        &#125;</div><div class="line">    &#125;).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其 translationX 的曲线如下：</p>
<p><img src="/images/react-native-animation-anlaysis-summary/898E86818F9CCA69988C713497D399A0.jpg" alt="IMAGE"></p>
<p>react-native 层则需要依赖 react-native 的源码，通过在 BaseViewManager 中的 setTransform 方法中加个 log 来实现。<br>react-native 如何依赖源码，可以参考<a href="https://facebook.github.io/react-native/docs/android-building-from-source.html" target="_blank" rel="external">官方文档</a></p>
<p>其 translationX 的曲线如下：<br><img src="/images/react-native-animation-anlaysis-summary/5512FEFCFAA394ACB4A496C5E951777C.jpg" alt="IMAGE"></p>
<p>对比 native 方案，发现其 translationX 的曲线是不够平滑的</p>
<p>在 pop 时不流畅感比较明显的一次记录：</p>
<p><img src="/images/react-native-animation-anlaysis-summary/409299ADD3A9005B8338C5380A54BAD0.jpg" alt="IMAGE"></p>
<p>因此到这里，基本可以得出结论，造成动画不流畅的原因，是由于 react-native 在计算中间帧时，在 dip-&gt;pix 的计算过程中，出现精度丢失，导致画面不连续，造成动画不连续的错觉。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>react-native 在动画性能上和原生方案差距不大</li>
<li>react-native 的 animated value 都是自己计算的，由于 js 里是使用 dip，而在 native 层某些参数使用的是 pixel，在转换的过程中可能会造成精度丢失导致画面产生不连续感。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mlazy.club/2017/12/15/react-navigation-animation-principle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mluffy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人小屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/15/react-navigation-animation-principle/" itemprop="url">react-navigation 动画实现原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-15T19:33:23+08:00">
                2017-12-15
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/12/15/react-navigation-animation-principle/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2017/12/15/react-navigation-animation-principle/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          
             <span id="/2017/12/15/react-navigation-animation-principle/" class="leancloud_visitors" data-flag-title="react-navigation 动画实现原理">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是android 动画性能分析系列文章中有关源码分析的最后一章，我们通过对比<a href="/2017/12/15/android-animation-principle/" title="android 动画原理">android 动画原理</a>以及<a href="/2017/12/15/react-native-animated-principle/" title="react-native animated 动画实现原理">react-native animated 动画实现原理</a>发现，两者的实现并无本质区别，其中的性能差距是可以预期的，不会与项目中出现的卡顿现象相关（部分高性能 android 机子上也出现了不流畅问题，反而低配置机子表现正常）。因此只能再看看项目中使用到的 react navigation，看看里边是如何使用的 Animated 源码。</p>
<h1 id="React-Navigation-的布局结构"><a href="#React-Navigation-的布局结构" class="headerlink" title="React Navigation 的布局结构"></a>React Navigation 的布局结构</h1><p>一个使用 StackNavigator 的布局，大概会是这样：<br>StackNavigator -&gt; CardStackTransitioner -&gt; Transitioner -&gt; CardStack -&gt; Card -&gt; SceneView -&gt; Component<br><img src="/images/react-navigation-animation-principle/1DDD56B3F959824C9ADDECC4829DCE4A.jpg" alt="ReactNative 动画流程__ReactNavigagtion 动画流程__StackNavigator 渲染流程_5.jpg"></p>
<ul>
<li>StackNavigator：类似于工厂类，提供上层的 api 接口，CardStackTransitioner 由它来构造</li>
<li>CardStackTransitioner：Transitioner 的渲染代理，提供动画的配置</li>
<li>Transitioner：动画执行类，侦听参数变化，执行动画。动画配置和视图渲染交由外部来实现</li>
<li>CardStack：管理导航层级</li>
<li>Card：作为一个 container，管理手势的处理（如右滑返回）</li>
<li>SceneView：简单的参数封装，通过 context 获取 navigation 参数，把 navigation 以及 screenProps传递给 Component</li>
<li>Component：我们自己的定义的 view</li>
</ul>
<p>从流程可以分析得到，动画相关的核心就在于 CardStackTransitioner。</p>
<h1 id="React-Navigation-动画实现原理"><a href="#React-Navigation-动画实现原理" class="headerlink" title="React Navigation 动画实现原理"></a>React Navigation 动画实现原理</h1><p>由 CardStackTransitioner 代码追踪，最终定位到整个动画配置就在 <code>TransitionerConfig.js</code>中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* @flow */</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> &#123; Animated, Easing, Platform &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> type &#123;</div><div class="line">  NavigationTransitionProps,</div><div class="line">  NavigationTransitionSpec,</div><div class="line">  TransitionConfig,</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'../../TypeDefinition'</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> CardStackStyleInterpolator <span class="keyword">from</span> <span class="string">'./CardStackStyleInterpolator'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> IOSTransitionSpec = (&#123;</div><div class="line">  duration: <span class="number">500</span>,</div><div class="line">  easing: Easing.bezier(<span class="number">0.2833</span>, <span class="number">0.99</span>, <span class="number">0.31833</span>, <span class="number">0.99</span>),</div><div class="line">  timing: Animated.timing,</div><div class="line">&#125;: NavigationTransitionSpec);</div><div class="line"></div><div class="line"><span class="comment">// Standard iOS navigation transition</span></div><div class="line"><span class="keyword">const</span> SlideFromRightIOS = (&#123;</div><div class="line">  transitionSpec: IOSTransitionSpec,</div><div class="line">  screenInterpolator: CardStackStyleInterpolator.forHorizontal,</div><div class="line">  containerStyle: &#123;</div><div class="line">    backgroundColor: <span class="string">'#000'</span>,</div><div class="line">  &#125;,</div><div class="line">&#125;: TransitionConfig);</div><div class="line"></div><div class="line"><span class="comment">//...其他配置</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultTransitionConfig</span>(<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  <span class="regexp">//</span> props for the new screen</span></span></div><div class="line"><span class="function"><span class="params">  transitionProps: NavigationTransitionProps,</span></span></div><div class="line"><span class="function"><span class="params">  <span class="regexp">//</span> props for the old screen</span></span></div><div class="line"><span class="function"><span class="params">  prevTransitionProps: ?NavigationTransitionProps,</span></span></div><div class="line"><span class="function"><span class="params">  <span class="regexp">//</span> whether we<span class="string">'re animating in/out a modal screen</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">  isModal: boolean</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">): TransitionConfig &#123;</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">  //...其他配置</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">  return SlideFromRightIOS;</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">&#125;</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string"></span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">function getTransitionConfig(</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">  transitionConfigurer?: (</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">    transitionProps: NavigationTransitionProps,</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">    prevTransitionProps: ?NavigationTransitionProps,</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">    isModal: boolean</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">  ) =&gt; TransitionConfig,</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">  // props for the new screen</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">  transitionProps: NavigationTransitionProps,</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">  // props for the old screen</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">  prevTransitionProps: ?NavigationTransitionProps,</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">  isModal: boolean</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">): TransitionConfig &#123;</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">  const defaultConfig = defaultTransitionConfig(</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">    transitionProps,</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">    prevTransitionProps,</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">    isModal</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">  );</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">  if (transitionConfigurer) &#123;</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">    return &#123;</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">      ...defaultConfig,</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">      ...transitionConfigurer(transitionProps, prevTransitionProps, isModal),</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">    &#125;;</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">  &#125;</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">  return defaultConfig;</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">&#125;</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string"></span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">export default &#123;</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">  defaultTransitionConfig,</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">  getTransitionConfig,</span></span></span></div><div class="line"><span class="function"><span class="params"><span class="string">&#125;;</span></span></span></div></pre></td></tr></table></figure>
<p>因为我们项目中是 copy 了 iOS 的动画配置，让 android 也实现类似 iOS 的 push 效果，因此在这里我们只分析 <code>SlideFromRightIOS</code>是如何实现的。</p>
<p>其中 interpolation 是使用了 <code>CardStackStyleInterpolator</code> 的 <code>forHorizontal</code> 方法，来看看他里边是如何配置的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//CardStackStyleInterpolator.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">forHorizontal</span>(<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  props: NavigationSceneRendererProps</span></span></div><div class="line"><span class="function"><span class="params"></span>): <span class="title">AnimatedViewStyleProp</span> </span>&#123;</div><div class="line">  <span class="keyword">const</span> &#123; layout, position, scene &#125; = props;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!layout.isMeasured) &#123;</div><div class="line">    <span class="keyword">return</span> forInitial(props);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">const</span> interpolate = getSceneIndicesForInterpolationInputRange(props);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!interpolate) <span class="keyword">return</span> &#123; <span class="attr">opacity</span>: <span class="number">0</span> &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> &#123; first, last &#125; = interpolate;</div><div class="line">  <span class="keyword">const</span> index = scene.index;</div><div class="line">  <span class="comment">//设置从前一个视图到当前视图的动画效果，以及从当前视图进入下一个视图时，该视图的动画效果</span></div><div class="line">  <span class="keyword">const</span> opacity = position.interpolate(&#123;</div><div class="line">    inputRange: [first, first + <span class="number">0.01</span>, index, last - <span class="number">0.01</span>, last],</div><div class="line">    outputRange: ([<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0.85</span>, <span class="number">0</span>]: <span class="built_in">Array</span>&lt;number&gt;),</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> width = layout.initWidth;</div><div class="line">  <span class="comment">//利用 transform 的 translateX 来实现动画的左右滑动</span></div><div class="line">  <span class="comment">//first 是上一个页面的位置，index 是当前的位置，last 是下一个页面的位置</span></div><div class="line">  <span class="comment">//这个动画的含义为，A push B，则 B 的 transformX 是从 width 到0，A 的 transformX 是从0到 width*-0.3</span></div><div class="line">  <span class="comment">//B pop，则 B 的transfromX 是从 0 到 width，A 的 transformX 是从 width*-0.3到0</span></div><div class="line">  <span class="keyword">const</span> translateX = position.interpolate(&#123;</div><div class="line">    inputRange: ([first, index, last]: <span class="built_in">Array</span>&lt;number&gt;),</div><div class="line">    outputRange: I18nManager.isRTL</div><div class="line">      ? ([-width, <span class="number">0</span>, width * <span class="number">0.3</span>]: <span class="built_in">Array</span>&lt;number&gt;)</div><div class="line">      : ([width, <span class="number">0</span>, width * <span class="number">-0.3</span>]: <span class="built_in">Array</span>&lt;number&gt;),</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">const</span> translateY = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    opacity,</div><div class="line">    transform: [&#123; translateX &#125;, &#123; translateY &#125;],</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总的来说，整个动画的核心是利用当前页面的位置变化映射到 translationX 的变化中，实现push 和 pop 的动画效果</p>
<p>接着，动画是由 Transitioner 触发的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">//Transitioner.js</span></div><div class="line">  componentWillReceiveProps(nextProps: Props): <span class="keyword">void</span> &#123;</div><div class="line">  <span class="keyword">const</span> nextScenes = NavigationScenesReducer(</div><div class="line">    <span class="keyword">this</span>.state.scenes,</div><div class="line">    nextProps.navigation.state,</div><div class="line">    <span class="keyword">this</span>.props.navigation.state</div><div class="line">  );</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (nextScenes === <span class="keyword">this</span>.state.scenes) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> indexHasChanged =</div><div class="line">    nextProps.navigation.state.index !== <span class="keyword">this</span>.props.navigation.state.index;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._isTransitionRunning) &#123;</div><div class="line">    <span class="keyword">this</span>._queuedTransition = &#123; nextProps, nextScenes, indexHasChanged &#125;;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//props 变更，实际上就是页面发生变化了，执行转场动画</span></div><div class="line">  <span class="keyword">this</span>._startTransition(nextProps, nextScenes, indexHasChanged);</div><div class="line">&#125;</div><div class="line"></div><div class="line">_startTransition(</div><div class="line">  nextProps: Props,</div><div class="line">  nextScenes: <span class="built_in">Array</span>&lt;NavigationScene&gt;,</div><div class="line">  indexHasChanged: boolean</div><div class="line">) &#123;</div><div class="line">  <span class="keyword">const</span> nextState = &#123;</div><div class="line">    ...this.state,</div><div class="line">    scenes: nextScenes,</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> &#123; position, progress &#125; = nextState;</div><div class="line"></div><div class="line">  progress.setValue(<span class="number">0</span>);</div><div class="line"></div><div class="line">  <span class="keyword">this</span>._prevTransitionProps = <span class="keyword">this</span>._transitionProps;</div><div class="line">  <span class="keyword">this</span>._transitionProps = buildTransitionProps(nextProps, nextState);</div><div class="line"></div><div class="line">  <span class="comment">// get the transition spec.</span></div><div class="line">  <span class="comment">//这里通过外部拿到动画配置，目的是可以通过外部自定义动画参数。可以认为就是一个动画参数代理</span></div><div class="line">  <span class="keyword">const</span> transitionUserSpec = nextProps.configureTransition</div><div class="line">    ? nextProps.configureTransition(</div><div class="line">        <span class="keyword">this</span>._transitionProps,</div><div class="line">        <span class="keyword">this</span>._prevTransitionProps</div><div class="line">      )</div><div class="line">    : <span class="literal">null</span>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> transitionSpec = &#123;</div><div class="line">    ...DefaultTransitionSpec,</div><div class="line">    ...transitionUserSpec,</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> &#123; timing &#125; = transitionSpec;</div><div class="line">  <span class="keyword">delete</span> transitionSpec.timing;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> toValue = nextProps.navigation.state.index;</div><div class="line">  <span class="keyword">const</span> positionHasChanged = position.__getValue() !== toValue;</div><div class="line"></div><div class="line">  <span class="comment">// if swiped back, indexHasChanged == true &amp;&amp; positionHasChanged == false</span></div><div class="line">  <span class="keyword">const</span> animations =</div><div class="line">    indexHasChanged &amp;&amp; positionHasChanged</div><div class="line">      ? [</div><div class="line">          <span class="comment">//progress 只是为了标记当前动画的执行进度</span></div><div class="line">          timing(progress, &#123;</div><div class="line">            ...transitionSpec,</div><div class="line">            toValue: <span class="number">1</span>,</div><div class="line">          &#125;),</div><div class="line">          <span class="comment">//转场动画配置</span></div><div class="line">          timing(position, &#123;</div><div class="line">            ...transitionSpec,</div><div class="line">            toValue: nextProps.navigation.state.index,</div><div class="line">          &#125;),</div><div class="line">        ]</div><div class="line">      : [];</div><div class="line"></div><div class="line">  <span class="comment">// update scenes and play the transition</span></div><div class="line">  <span class="keyword">this</span>._isTransitionRunning = <span class="literal">true</span>;</div><div class="line">  <span class="keyword">this</span>.setState(nextState, () =&gt; &#123;</div><div class="line">    nextProps.onTransitionStart &amp;&amp;</div><div class="line">      nextProps.onTransitionStart(</div><div class="line">        <span class="keyword">this</span>._transitionProps,</div><div class="line">        <span class="keyword">this</span>._prevTransitionProps</div><div class="line">      );</div><div class="line">    Animated.parallel(animations).start(<span class="keyword">this</span>._onTransitionEnd);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过 <code>componentWillReceivePoprs</code> 来判断当前 index 是否改变，如果改变，则执行一次动画</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>React-Navigation 的 push/pop 动画，本质上是利用 index的变化，映射到 translationX 来实现的</li>
<li>动画的配置、视图的渲染由 CardStackTransitioner 来实现</li>
<li>具体的动画执行时机，有 Transitioner 来实现。Transitioner 利用 <code>componentWillReceiveProps</code> 来侦听当前 index 是否变化，从而决定是否要执行转场动画</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mlazy.club/2017/12/15/react-native-animated-principle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mluffy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人小屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/15/react-native-animated-principle/" itemprop="url">react-native animated 动画实现原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-15T19:32:54+08:00">
                2017-12-15
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/12/15/react-native-animated-principle/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2017/12/15/react-native-animated-principle/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          
             <span id="/2017/12/15/react-native-animated-principle/" class="leancloud_visitors" data-flag-title="react-native animated 动画实现原理">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上篇：<a href="/2017/12/15/android-animation-principle/" title="android 动画原理">android 动画原理</a> 说到，要对比 android 本身的动画实现以及 react-native 的动画实现来对比分析。本篇主要分析 react-native 的 Animated 控件是如何实现动画的，包含 Animated 中使用 nativeDriver 的 native 层动画实现方案以及不使用 nativeDriver 的纯 JS 动画实现方案</p>
<p>P.S. 本篇源码分析是基于 react-native-0.47.2 进行解析的</p>
<h1 id="react-native-动画实现原理"><a href="#react-native-动画实现原理" class="headerlink" title="react-native 动画实现原理"></a>react-native 动画实现原理</h1><p>react-native 的动画也有两种方案，一种是纯 JS 方案，仅在 JS 层通过 <code>requestAnimationFrame</code> 来实现定时渲染，以此来实现动画。<br>另一种是 native 方案，在 js 层配置好视图（ AnimatedNode ）与数据（ AnimatedValue ）的绑定，再把配置信息以及动画信息传递给 native 层，由 native 层来实现动画，而 native 层则利用与原生Animator 相似的方案来执行动画。稍微有些区别的是，Animator 是直接针对 view 的属性进行更新，而 native 方案是通过更新 node 来实现的，native 方案几乎和 Animator 等价，区别是在于native 方案中间需要 findNode 之类的操作找到最终需要操作的 view，他们之间的性能差距取决于 react-native 对于布局的更新处理机制。<br>值得注意的是，虽然 native 方案利用了 Choreographer 来实现定时器，但如果系统版本不支持，则其使用自定义的 Handler 来实现，时间是17ms，而原生的 Choreographer，在不支持 VSYNC 的设备中，自定义的 handler 的间隔是10ms，因此在低版本（api &lt; 16, android 3.0以下）的设备上，react-native 的动画在 android 上可能不会很流畅。</p>
<p>建议先阅读<a href="http://www.alloyteam.com/2016/01/reactnative-animated/" target="_blank" rel="external">react-native animated 动画原理</a>，以此来对动画是如何实现的有个基本的认知，因为核心思路都是一致的，不同的只是在具体的环境中，如何对模块进行划分，模块之间如何通讯协作。</p>
<h2 id="纯-JS-的动画实现"><a href="#纯-JS-的动画实现" class="headerlink" title="纯 JS 的动画实现"></a>纯 JS 的动画实现</h2><p>动画的入口很多，比如 AnimatedComponent，或者手动 start 一个 animation，这里我们通过手动的 start animator 来分析整个流程，核心流程都是一致的，不同的入口只是在初始化配置的部分有些差异。</p>
<h3 id="js-层流程图"><a href="#js-层流程图" class="headerlink" title="js 层流程图"></a>js 层流程图</h3><p>先来核心的调用流程，了解其中涉及的模块。</p>
<p><img src="/images/react-native-animated-principle/1DC392BFD58B05CE38DEE4B2F20343B4.jpg" alt="ReactNative 动画流程__Animated 动画流程__AnimatedValue 流程_3.jpg"></p>
<p>在执行动画流程里，包含纯 js 流程（上半部分）和 native 流程（下半部分），这里我们只需要先关注上半部分的 js流程即可。</p>
<p>核心的通讯流程包含3个部分</p>
<ul>
<li>TimingAnimation: 执行动画的具体类，包括实现动画的周期，循环等等</li>
<li>AnimatedImplementation：Animated 的实现类。</li>
<li>AnimatedValue：动画数值的映射类，负责动画数值的更新，以及视图的更新。</li>
</ul>
<p>先由 AnimatedImplmentation 触发动画的开始，接着由 AnimatedValue 触发 TimingAnimation 开始执行动画，TimingAnimation 通过<code>requestAnimationFrame</code>来触发 <code>_onUpdate</code> 方法，<code>_onUpdate</code> 方法本质上是一个 delegate，由 AnimatedValue 来实现，相当于 TimingAnimation 触发动画渲染后，把渲染这个动作委托给 AnimatedValue 来实现，最终 AnimatedValue 通过 <code>_flush</code> 方法进行更新。<code>_flush</code>方法是通过 setNativeProps 的方式，直接操作 dom 进行view 的更新。</p>
<h2 id="Native-方案实现"><a href="#Native-方案实现" class="headerlink" title="Native 方案实现"></a>Native 方案实现</h2><p>Native 方案中，与 JS 方案不同的是，TimingAnimation 不控制动画的渲染频率了，而是从 AnimatedValue 中获取对应的 TAG（在 react-native 中，每一个 view 都有一个唯一的 tag 与之对应，和 android 里的 id 是一个道理），通过<code>startAnimatingNode</code>方法，把 animationConfig 和 tag 传给 <code>NativeAnimatedHelper</code>，由 <code>NativeAnimatedHelper</code> 调用 native 层的 <code>NativeAnimatedModule</code>，由 <code>NativeAnimatedModule</code> 在 native 层实现动画。</p>
<h3 id="native-层流程图"><a href="#native-层流程图" class="headerlink" title="native 层流程图"></a>native 层流程图</h3><p><img src="/images/react-native-animated-principle/50718B4E2D7D2CA7828B0CCA001E729D.jpg" alt="ReactNative 动画流程__Animated 动画流程__NativeAnimated 流程_4.jpg"><br>和原生方案类似，都是通过注册 frameCallback，在每一帧心跳到来时，执行视图的更新。</p>
<p>核心的通讯流程包含4个部分</p>
<ul>
<li>NativeAnimatedModule：对 js 层的接口，负责接收 js 层的 animate 信息，把信息添加到 operation 队列中，等待下一次frame 心跳触发。该模块同时负责实现循环心跳的侦听</li>
<li>ReactChoreographer：android 的 Choreographer 的一个封装，3.0版本以下使用自己的 handler 实现，间隔是17ms</li>
<li>NativeAnimatedNodesManager：负责遍历所有 AnimatedNode，通过 AnimationDriver 获取当前帧需要更新的值，然后调用 AnimatedNode 的 update 方法更新 Node</li>
<li>AnimatedNode：类似 Animator 中的 ValueAnimator，绑定 view 和 value，value 变更时更新 view</li>
</ul>
<h4 id="NativeAnimatedModule"><a href="#NativeAnimatedModule" class="headerlink" title="NativeAnimatedModule"></a>NativeAnimatedModule</h4><p><code>NativeAnimatedModule</code>有两个职责，一个是作为对 js 的接口，另一个是负责侦听心跳，执行队列中的操作。</p>
<p>以<code>startAnimatingNode</code>为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ReactMethod</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startAnimatingNode</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">int</span> animationId,</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">int</span> animatedNodeTag,</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">final</span> ReadableMap animationConfig,</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">final</span> Callback endCallback)</span> </span>&#123;</div><div class="line">  mOperations.add(<span class="keyword">new</span> UIThreadOperation() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(NativeAnimatedNodesManager animatedNodesManager)</span> </span>&#123;</div><div class="line">      animatedNodesManager.startAnimatingNode(</div><div class="line">        animationId,</div><div class="line">        animatedNodeTag,</div><div class="line">        animationConfig,</div><div class="line">        endCallback);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>NativeAnimatedModule</code> 在收到 js 请求后，并不立即执行对应的方法，而是封装为一 个<code>UIThreadOperation</code>，放到 <code>mOperations</code> 的队列里，等待 <code>ReactChoreagrapher</code> 的心跳触发。</p>
<p>该模块是通过在 callback 中进行递归调用实现的心跳侦听机制，代码调用流程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//1. 利用 LifeCircleEventlistener，在 HostActivity resume时 enqueueFrameCallback</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onHostResume</span><span class="params">()</span> </span>&#123;</div><div class="line">  enqueueFrameCallback();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//2. 向 ReactChoreographer postFameCallback，侦听下一个心跳</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueueFrameCallback</span><span class="params">()</span> </span>&#123;</div><div class="line">  Assertions.assertNotNull(mReactChoreographer).postFrameCallback(</div><div class="line">    ReactChoreographer.CallbackType.NATIVE_ANIMATED_MODULE,</div><div class="line">    mAnimatedFrameCallback);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//3. 在 AnimatedFrameCallback 的最后，直接postFrameCallback，通过递归实现循环侦听。Facebook 也觉得这样不好，但是他还没在这一块做优化</span></div><div class="line">  mAnimatedFrameCallback = <span class="keyword">new</span> GuardedFrameCallback(reactContext) &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFrameGuarded</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</div><div class="line">      <span class="comment">//3.1 lazy load NativeAnimatedNodeManager</span></div><div class="line">      <span class="keyword">if</span> (mNodesManager == <span class="keyword">null</span>) &#123;</div><div class="line">        UIManagerModule uiManager = getReactApplicationContext()</div><div class="line">          .getNativeModule(UIManagerModule.class);</div><div class="line">        mNodesManager = <span class="keyword">new</span> NativeAnimatedNodesManager(uiManager);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">//3.2 把 mReadyOperations 放到局部变量然后置空，这里是为了保证这一次 frameCallback 不会有其他 operation 添加进来，保证线程安全。因为这个 callback 是在主线程中执行的，js 接口是在 native ModuleThread 执行的</span></div><div class="line">      ArrayList&lt;UIThreadOperation&gt; operations;</div><div class="line">      <span class="keyword">synchronized</span> (mOperationsCopyLock) &#123;</div><div class="line">        operations = mReadyOperations;</div><div class="line">        mReadyOperations = <span class="keyword">null</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (operations != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = operations.size(); i &lt; size; i++) &#123;</div><div class="line">          <span class="comment">//3.3 在这里执行刚才 startAnimatingNode 的方法，实际上调用了 mNodeManager 的startAnimatingNode 方法</span></div><div class="line">          operations.get(i).execute(mNodesManager);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">//3.4 调用了 mNodeManager 的 startAnimatingNode 方法后，这里的值变为 true，因此最终会执行 mNodeManager 的 runUpdates 方法来执行动画更新</span></div><div class="line">      <span class="keyword">if</span> (mNodesManager.hasActiveAnimations()) &#123;</div><div class="line">        mNodesManager.runUpdates(frameTimeNanos);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// <span class="doctag">TODO:</span> Would be great to avoid adding this callback in case there are no active animations</span></div><div class="line">      <span class="comment">// and no outstanding tasks on the operations queue. Apparently frame callbacks can only</span></div><div class="line">      <span class="comment">// be posted from the UI thread and therefore we cannot schedule them directly from</span></div><div class="line">      <span class="comment">// @ReactMethod methods</span></div><div class="line">      <span class="comment">//3.5 再次post callback，递归实现循环心跳</span></div><div class="line">      Assertions.assertNotNull(mReactChoreographer).postFrameCallback(</div><div class="line">        ReactChoreographer.CallbackType.NATIVE_ANIMATED_MODULE,</div><div class="line">        mAnimatedFrameCallback);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div></pre></td></tr></table></figure>
<h4 id="ReactChoreographer"><a href="#ReactChoreographer" class="headerlink" title="ReactChoreographer"></a>ReactChoreographer</h4><p>ReactChoreographer 代码比较简单，它实际上是一个 proxy，真正的实现是 ChoreographerCompat</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ReactChoreographer.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">ReactChoreographer</span><span class="params">()</span> </span>&#123;</div><div class="line">  mChoreographer = ChoreographerCompat.getInstance();</div><div class="line">  mReactChoreographerDispatcher = <span class="keyword">new</span> ReactChoreographerDispatcher();</div><div class="line">  mCallbackQueues = <span class="keyword">new</span> ArrayDeque[CallbackType.values().length];</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mCallbackQueues.length; i++) &#123;</div><div class="line">    mCallbackQueues[i] = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//ChoreographerCompat.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">ChoreographerCompat</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (IS_JELLYBEAN_OR_HIGHER) &#123;</div><div class="line">    mChoreographer = getChoreographer();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    mHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="NativeAnimatedNodesManager"><a href="#NativeAnimatedNodesManager" class="headerlink" title="NativeAnimatedNodesManager"></a>NativeAnimatedNodesManager</h4><p>由 NativeAnimatedModule 的 frameCallback 可以看到，核心的代码便是 <code>startAnimatingNode</code>和<code>runUpdates</code></p>
<p>在 NativeAnimatedNodesManager 中，有两个 map，一个是 mUpdateNodes，这个是用于存储刚创建的 AnimatedNode 以及手动更新 animatedValue 的操作，mActiveAnimations用于存储正在执行的动画<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1. 在 nativeAnimatedModule 的 callback 中，startAnimatingNode,实际上是构造了一个 AnimatedNode，然后放到 mActiveAnimations 的 map 中</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startAnimatingNode</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">  <span class="keyword">int</span> animationId,</span></span></div><div class="line"><span class="function"><span class="params">  <span class="keyword">int</span> animatedNodeTag,</span></span></div><div class="line"><span class="function"><span class="params">  ReadableMap animationConfig,</span></span></div><div class="line"><span class="function"><span class="params">  Callback endCallback)</span> </span>&#123;</div><div class="line">  AnimatedNode node = mAnimatedNodes.get(animatedNodeTag);</div><div class="line">  <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> JSApplicationIllegalArgumentException(<span class="string">"Animated node with tag "</span> + animatedNodeTag +</div><div class="line">      <span class="string">" does not exists"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (!(node <span class="keyword">instanceof</span> ValueAnimatedNode)) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> JSApplicationIllegalArgumentException(<span class="string">"Animated node should be of type "</span> +</div><div class="line">      ValueAnimatedNode.class.getName());</div><div class="line">  &#125;</div><div class="line">  String type = animationConfig.getString(<span class="string">"type"</span>);</div><div class="line">  <span class="keyword">final</span> AnimationDriver animation;</div><div class="line">  <span class="keyword">if</span> (<span class="string">"frames"</span>.equals(type)) &#123;</div><div class="line">    animation = <span class="keyword">new</span> FrameBasedAnimationDriver(animationConfig);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"spring"</span>.equals(type)) &#123;</div><div class="line">    animation = <span class="keyword">new</span> SpringAnimation(animationConfig);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"decay"</span>.equals(type)) &#123;</div><div class="line">    animation = <span class="keyword">new</span> DecayAnimation(animationConfig);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> JSApplicationIllegalArgumentException(<span class="string">"Unsupported animation type: "</span> + type);</div><div class="line">  &#125;</div><div class="line">  animation.mId = animationId;</div><div class="line">  animation.mEndCallback = endCallback;</div><div class="line">  animation.mAnimatedValue = (ValueAnimatedNode) node;</div><div class="line">  mActiveAnimations.put(animationId, animation);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//2.遍历 mActiveAnimations，放到 mRunUpdateNodeList 中，然后执行 updateNodes 方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runUpdates</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</div><div class="line">  UiThreadUtil.assertOnUiThread();</div><div class="line">  <span class="keyword">boolean</span> hasFinishedAnimations = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="comment">//2.1 先保证 Node 的创建、人为的更新</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mUpdatedNodes.size(); i++) &#123;</div><div class="line">    AnimatedNode node = mUpdatedNodes.valueAt(i);</div><div class="line">    mRunUpdateNodeList.add(node);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Clean mUpdatedNodes queue</span></div><div class="line">  mUpdatedNodes.clear();</div><div class="line"></div><div class="line">  <span class="comment">//2.2 取得当前帧的动画值，放到更新队列里</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mActiveAnimations.size(); i++) &#123;</div><div class="line">    <span class="comment">//这个 AnimationDriver 是一个abstract class，具体的实现类是SpringAnimation 等，具体是哪个实现类要看在 js 里的动画配置，使用的是哪个类型的Animated</span></div><div class="line">    AnimationDriver animation = mActiveAnimations.valueAt(i);</div><div class="line">    <span class="comment">//通过 currentValue、toValue、时间函数、当前时间，计算下一个mAnimatedValue</span></div><div class="line">    animation.runAnimationStep(frameTimeNanos);</div><div class="line">    AnimatedNode valueNode = animation.mAnimatedValue;</div><div class="line">    mRunUpdateNodeList.add(valueNode);</div><div class="line">    <span class="keyword">if</span> (animation.mHasFinished) &#123;</div><div class="line">      hasFinishedAnimations = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//2.3 遍历 mRunUpdateNodeList，更新里边所有的 Node</span></div><div class="line">  updateNodes(mRunUpdateNodeList);</div><div class="line">  mRunUpdateNodeList.clear();</div><div class="line"></div><div class="line">  <span class="comment">// Cleanup finished animations. Iterate over the array of animations and override ones that has</span></div><div class="line">  <span class="comment">// finished, then resize `mActiveAnimations`.</span></div><div class="line">  <span class="comment">// 2.4 如果有动画结束了，找到对应结束的动画，回调 callback</span></div><div class="line">  <span class="keyword">if</span> (hasFinishedAnimations) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mActiveAnimations.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">      AnimationDriver animation = mActiveAnimations.valueAt(i);</div><div class="line">      <span class="keyword">if</span> (animation.mHasFinished) &#123;</div><div class="line">        WritableMap endCallbackResponse = Arguments.createMap();</div><div class="line">        endCallbackResponse.putBoolean(<span class="string">"finished"</span>, <span class="keyword">true</span>);</div><div class="line">        animation.mEndCallback.invoke(endCallbackResponse);</div><div class="line">        mActiveAnimations.removeAt(i);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//3. 执行 AnimatedNode 的更新。nodes 里实际上是一个无向图，通过 BFS（广度优先）的方式进行遍历 遍历这个图，对每个节点进行更新。nodes 的元素属于头结点，AnimatedNode.mchildren 属于子节点。核心思想就是先更新头结点，再更新子节点，最后再次更新头结点，最后一步是确保子节点对父节点的影响也更新了。</span></div><div class="line"><span class="comment">// 比如 nodes 有3个节点，n1，n2，n3，每个节点有一个子节点，n1的子节点n11，n2的子节点n22，n3的子节点n33，那么更新顺序就是 n1-&gt;n2-&gt;n3-&gt;n11-&gt;n22-&gt;n33-&gt;n1-&gt;n2-&gt;n3</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateNodes</span><span class="params">(List&lt;AnimatedNode&gt; nodes)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> activeNodesCount = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> updatedNodesCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="comment">// STEP 1.</span></div><div class="line">  <span class="comment">// BFS over graph of nodes. Update `mIncomingNodes` attribute for each node during that BFS.</span></div><div class="line">  <span class="comment">// Store number of visited nodes in `activeNodesCount`. We "execute" active animations as a part</span></div><div class="line">  <span class="comment">// of this step.</span></div><div class="line"></div><div class="line">  <span class="comment">//BFSColor 相当于标记当前遍历时的类型，主要是用于标记 node 是否已经被遍历过了（visited）。</span></div><div class="line">  mAnimatedGraphBFSColor++; <span class="comment">/* use new color */</span></div><div class="line">  <span class="keyword">if</span> (mAnimatedGraphBFSColor == AnimatedNode.INITIAL_BFS_COLOR) &#123;</div><div class="line">    <span class="comment">// value "0" is used as an initial color for a new node, using it in BFS may cause some nodes</span></div><div class="line">    <span class="comment">// to be skipped.</span></div><div class="line">    mAnimatedGraphBFSColor++;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//3.1 以 BFS 遍历整个图，计算所有的 node 个数（activeNodesCount），并给所有子节点标记 mActiveIncomingNode = 1</span></div><div class="line"></div><div class="line">  Queue&lt;AnimatedNode&gt; nodesQueue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line">  <span class="keyword">for</span> (AnimatedNode node : nodes) &#123;</div><div class="line">    <span class="keyword">if</span> (node.mBFSColor != mAnimatedGraphBFSColor) &#123;</div><div class="line">      node.mBFSColor = mAnimatedGraphBFSColor;</div><div class="line">      activeNodesCount++;</div><div class="line">      nodesQueue.add(node);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (!nodesQueue.isEmpty()) &#123;</div><div class="line">    AnimatedNode nextNode = nodesQueue.poll();</div><div class="line">    <span class="keyword">if</span> (nextNode.mChildren != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nextNode.mChildren.size(); i++) &#123;</div><div class="line">        AnimatedNode child = nextNode.mChildren.get(i);</div><div class="line">        child.mActiveIncomingNodes++;</div><div class="line">        <span class="keyword">if</span> (child.mBFSColor != mAnimatedGraphBFSColor) &#123;</div><div class="line">          child.mBFSColor = mAnimatedGraphBFSColor;</div><div class="line">          activeNodesCount++;</div><div class="line">          nodesQueue.add(child);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//3.2 以 BFS 遍历整个图，对访问到的每个 node 进行更新</span></div><div class="line">  <span class="comment">// STEP 2</span></div><div class="line">  <span class="comment">// BFS over the graph of active nodes in topological order -&gt; visit node only when all its</span></div><div class="line">  <span class="comment">// "predecessors" in the graph have already been visited. It is important to visit nodes in that</span></div><div class="line">  <span class="comment">// order as they may often use values of their predecessors in order to calculate "next state"</span></div><div class="line">  <span class="comment">// of their own. We start by determining the starting set of nodes by looking for nodes with</span></div><div class="line">  <span class="comment">// `mActiveIncomingNodes = 0` (those can only be the ones that we start BFS in the previous</span></div><div class="line">  <span class="comment">// step). We store number of visited nodes in this step in `updatedNodesCount`</span></div><div class="line"></div><div class="line">  mAnimatedGraphBFSColor++;</div><div class="line">  <span class="keyword">if</span> (mAnimatedGraphBFSColor == AnimatedNode.INITIAL_BFS_COLOR) &#123;</div><div class="line">    <span class="comment">// see reasoning for this check a few lines above</span></div><div class="line">    mAnimatedGraphBFSColor++;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// find nodes with zero "incoming nodes", those can be either nodes from `mUpdatedNodes` or</span></div><div class="line">  <span class="comment">// ones connected to active animations</span></div><div class="line">  <span class="comment">//遍历所有 node，找到所有头节点，把头节点添加到队列尾部。这里的目的是为了让所有子节点更新完毕后，再次更新头节点，因为有可能头节点会因为子节点的变动而有新的改变</span></div><div class="line">  <span class="keyword">for</span> (AnimatedNode node : nodes) &#123;</div><div class="line">    <span class="keyword">if</span> (node.mActiveIncomingNodes == <span class="number">0</span> &amp;&amp; node.mBFSColor != mAnimatedGraphBFSColor) &#123;</div><div class="line">      node.mBFSColor = mAnimatedGraphBFSColor;</div><div class="line">      updatedNodesCount++;</div><div class="line">      nodesQueue.add(node);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//BFS 的遍历顺序更新所有节点。</span></div><div class="line">  <span class="comment">// Run main "update" loop</span></div><div class="line">  <span class="keyword">while</span> (!nodesQueue.isEmpty()) &#123;</div><div class="line">    AnimatedNode nextNode = nodesQueue.poll();</div><div class="line">    nextNode.update();</div><div class="line">    <span class="keyword">if</span> (nextNode <span class="keyword">instanceof</span> PropsAnimatedNode) &#123;</div><div class="line">      <span class="comment">// Send property updates to native view manager</span></div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">//如果是 PropsAnimatedNode，通过 updateView 直接更新对应的参数</span></div><div class="line">        ((PropsAnimatedNode) nextNode).updateView(mUIImplementation);</div><div class="line">      &#125; <span class="keyword">catch</span> (IllegalViewOperationException e) &#123;</div><div class="line">          <span class="comment">// An exception is thrown if the view hasn't been created yet. This can happen because views are</span></div><div class="line">          <span class="comment">// created in batches. If this particular view didn't make it into a batch yet, the view won't</span></div><div class="line">          <span class="comment">// exist and an exception will be thrown when attempting to start an animation on it.</span></div><div class="line">          <span class="comment">//</span></div><div class="line">          <span class="comment">// Eat the exception rather than crashing. The impact is that we may drop one or more frames of the</span></div><div class="line">          <span class="comment">// animation.</span></div><div class="line">          FLog.e(ReactConstants.TAG, <span class="string">"Native animation workaround, frame lost as result of race condition"</span>, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (nextNode <span class="keyword">instanceof</span> ValueAnimatedNode) &#123;</div><div class="line">      <span class="comment">//把值回调给 js 层</span></div><div class="line">      <span class="comment">// Potentially send events to JS when the node's value is updated</span></div><div class="line">      ((ValueAnimatedNode) nextNode).onValueUpdate();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (nextNode.mChildren != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nextNode.mChildren.size(); i++) &#123;</div><div class="line">        AnimatedNode child = nextNode.mChildren.get(i);</div><div class="line">        child.mActiveIncomingNodes--;</div><div class="line">        <span class="comment">//没有遍历过的子节点，才添加到 nodeQueue 进行更新。这里是为了避免上一步，再次更新头节点时，又把子节点重新更新一遍</span></div><div class="line">        <span class="keyword">if</span> (child.mBFSColor != mAnimatedGraphBFSColor &amp;&amp; child.mActiveIncomingNodes == <span class="number">0</span>) &#123;</div><div class="line">          child.mBFSColor = mAnimatedGraphBFSColor;</div><div class="line">          updatedNodesCount++;</div><div class="line">          nodesQueue.add(child);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Verify that we've visited *all* active nodes. Throw otherwise as this would mean there is a</span></div><div class="line">  <span class="comment">// cycle in animated node graph. We also take advantage of the fact that all active nodes are</span></div><div class="line">  <span class="comment">// visited in the step above so that all the nodes properties `mActiveIncomingNodes` are set to</span></div><div class="line">  <span class="comment">// zero</span></div><div class="line">  <span class="keyword">if</span> (activeNodesCount != updatedNodesCount) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Looks like animated nodes graph has cycles, there are "</span></div><div class="line">      + activeNodesCount + <span class="string">" but toposort visited only "</span> + updatedNodesCount);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="AnimatedNode"><a href="#AnimatedNode" class="headerlink" title="AnimatedNode"></a>AnimatedNode</h4><p>从上边 <code>updateNodes</code> 的源码，我们可以看到，最终是调用 PropsAnimatedNode 的 updateView 来更新的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//PropsAnimatedNode.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">updateView</span><span class="params">(UIImplementation uiImplementation)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (mConnectedViewTag == -<span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Node has not been attached to a view"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//1. 根据不同的 AnimatedNode，生成需要更新的 props</span></div><div class="line">  JavaOnlyMap propsMap = <span class="keyword">new</span> JavaOnlyMap();</div><div class="line">  <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : mPropMapping.entrySet()) &#123;</div><div class="line">    <span class="meta">@Nullable</span> AnimatedNode node = mNativeAnimatedNodesManager.getNodeById(entry.getValue());</div><div class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Mapped property node does not exists"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node <span class="keyword">instanceof</span> StyleAnimatedNode) &#123;</div><div class="line">      ((StyleAnimatedNode) node).collectViewUpdates(propsMap);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node <span class="keyword">instanceof</span> ValueAnimatedNode) &#123;</div><div class="line">      propsMap.putDouble(entry.getKey(), ((ValueAnimatedNode) node).getValue());</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported type of node used in property node "</span> +</div><div class="line">          node.getClass());</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// <span class="doctag">TODO:</span> Reuse propsMap and stylesDiffMap objects - note that in subsequent animation steps</span></div><div class="line">  <span class="comment">// for a given node most of the time we will be creating the same set of props (just with</span></div><div class="line">  <span class="comment">// different values). We can take advantage on that and optimize the way we allocate property</span></div><div class="line">  <span class="comment">// maps (we also know that updating view props doesn't retain a reference to the styles object).</span></div><div class="line">  <span class="comment">//2. 执行 view 的更新</span></div><div class="line">  uiImplementation.synchronouslyUpdateViewOnUIThread(</div><div class="line">    mConnectedViewTag,</div><div class="line">    <span class="keyword">new</span> ReactStylesDiffMap(propsMap));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而在 UIImplementation 中，最终是调用了 NativeViewHierarchyManager.updateProperty 方法来更新 view 的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//UIImplementation.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synchronouslyUpdateViewOnUIThread</span><span class="params">(<span class="keyword">int</span> tag, ReactStylesDiffMap props)</span> </span>&#123;</div><div class="line">  UiThreadUtil.assertOnUiThread();</div><div class="line">  mOperationsQueue.getNativeViewHierarchyManager().updateProperties(tag, props);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 NativeViewHierachyManager 中，通过 tag 找到对应的 view manager，然后通过 setter，调用对应的方法。比如以 transform 为例，最终会调用到 BaseViewManager 中的 setTransform 方法。至于 ViewManager 如果通过 setter 代理实现的，后续再另开文章剖析里边的设计思路。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//NativeViewHierarchyManager.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">updateProperties</span><span class="params">(<span class="keyword">int</span> tag, ReactStylesDiffMap props)</span> </span>&#123;</div><div class="line">  UiThreadUtil.assertOnUiThread();</div><div class="line"></div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    ViewManager viewManager = resolveViewManager(tag);</div><div class="line">    View viewToUpdate = resolveView(tag);</div><div class="line">    viewManager.updateProperties(viewToUpdate, props);</div><div class="line">  &#125; <span class="keyword">catch</span> (IllegalViewOperationException e) &#123;</div><div class="line">    Log.e(TAG, <span class="string">"Unable to update properties for view tag "</span> + tag, e);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//BaseViewManager.java</span></div><div class="line"><span class="meta">@ReactProp</span>(name = PROP_TRANSFORM)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTransform</span><span class="params">(T view, ReadableArray matrix)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (matrix == <span class="keyword">null</span>) &#123;</div><div class="line">    resetTransformProperty(view);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    setTransformProperty(view, matrix);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>react-native 提供了在 js 层的纯动画实现，利用 requestAnimationFrame 来作为计时器，每个计时周期计算对应的值并更新相应的视图。</li>
<li>react-native 在 native 层使用了 Choreographer 作为计时器实现 nativeDriver，在 js 层把 animation 信息传到 native 层，由 native 层在主线程中更新 view，避免 js 层执行耗时任务导致动画卡顿。如果低于3.0版本，则使用自定义的 Handler，间隔为16ms 作为计时器。</li>
<li>react-native 的动画实现，其核心思想和 animator 是相似的，利用显示心跳，周期性的更新动画 View 的值，性能上的差距就在于view 的查找，style 到 view property 的转化上，和react-native 的布局机制相关</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.alloyteam.com/2016/01/reactnative-animated/" target="_blank" rel="external">react-native animated 动画原理</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mlazy.club/2017/12/15/android-animation-principle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mluffy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人小屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/15/android-animation-principle/" itemprop="url">android 动画原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-15T19:10:58+08:00">
                2017-12-15
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/12/15/android-animation-principle/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2017/12/15/android-animation-principle/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          
             <span id="/2017/12/15/android-animation-principle/" class="leancloud_visitors" data-flag-title="android 动画原理">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一篇：<a href="/2017/12/15/react-native-animation-performance-tool-systrace/" title="react-native 下，Android动画性能分析工具-systrace">react-native 下，Android动画性能分析工具-systrace</a> 中，为了定位 react-native 项目中部分 android 机型动画效果不流畅问题，提到最终定位的结果是因为<code>画面不连续</code>导致的，实际上分析的过程并没有那么简单。我们通过<code>systrace</code>对比 demo 项目（RN实现及 native 实现），分析排查出动画不流畅不是因为丢帧，CPU 负债问题引起的，那么只能是 react-native 的动画实现有问题，为了定位问题点，需要对比 android 的动画实现及 react-native 的动画实现，通过对比双方实现的差一点来定位问题可能出现的位置。</p>
<p>因此，本篇主要是针对 android 的实现原理（api-26）进行解析。</p>
<h1 id="Android-动画原理"><a href="#Android-动画原理" class="headerlink" title="Android 动画原理"></a>Android 动画原理</h1><p>Android 的动画实现目前有两种，一种是古老的 Animation （3.0之前）方式，另一种是 Animator</p>
<p>Animation 是在 draw 方法中被使用的，那么看看 draw 方法里具体做了些什么事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//android-25源码，animation 实现方案</span></div><div class="line"><span class="comment">//View.java</span></div><div class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">draw</span><span class="params">(Canvas canvs, ViewGroup parent, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</div><div class="line">        <span class="comment">//...其他处理</span></div><div class="line"></div><div class="line">        <span class="keyword">final</span> Animation a = getAnimation();</div><div class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</div><div class="line">            more = applyLegacyAnimation(parent, drawingTime, a, scalingRequired);</div><div class="line">            concatMatrix = a.willChangeTransformationMatrix();</div><div class="line">            <span class="keyword">if</span> (concatMatrix) &#123;</div><div class="line">                mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;</div><div class="line">            &#125;</div><div class="line">            transformToApply = parent.getChildTransformation();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//...没有动画时的处理</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//...其他处理</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">applyLegacyAnimation</span><span class="params">(ViewGroup parent, <span class="keyword">long</span> drawingTime,</span></span></div><div class="line"><span class="function"><span class="params">            Animation a, <span class="keyword">boolean</span> scalingRequired)</span> </span>&#123;</div><div class="line">        Transformation invalidationTransform;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> flags = parent.mGroupFlags;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> initialized = a.isInitialized();</div><div class="line">        <span class="keyword">if</span> (!initialized) &#123;</div><div class="line">            <span class="comment">//初始化渲染区域，开始执行动画</span></div><div class="line">            a.initialize(mRight - mLeft, mBottom - mTop, parent.getWidth(), parent.getHeight());</div><div class="line">            a.initializeInvalidateRegion(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop);</div><div class="line">            <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span>) a.setListenerHandler(mAttachInfo.mHandler);</div><div class="line">            onAnimationStart();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> Transformation t = parent.getChildTransformation();</div><div class="line">        <span class="comment">//通过 getTransformation 来更新 t，具体如何更新的和 animation 的子类相关，最终调用的是 applyTransformation</span></div><div class="line">        <span class="keyword">boolean</span> more = a.getTransformation(drawingTime, t, <span class="number">1f</span>);</div><div class="line">        <span class="comment">//兼容代码，scalingRequired 是 mAttachInfo 里的，用来标识应用是否处于 compatible mode</span></div><div class="line">        <span class="keyword">if</span> (scalingRequired &amp;&amp; mAttachInfo.mApplicationScale != <span class="number">1f</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (parent.mInvalidationTransformation == <span class="keyword">null</span>) &#123;</div><div class="line">                parent.mInvalidationTransformation = <span class="keyword">new</span> Transformation();</div><div class="line">            &#125;</div><div class="line">            invalidationTransform = parent.mInvalidationTransformation;</div><div class="line">            a.getTransformation(drawingTime, invalidationTransform, <span class="number">1f</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            invalidationTransform = t;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (more) &#123;</div><div class="line">            <span class="keyword">if</span> (!a.willChangeBounds()) &#123;</div><div class="line">                <span class="comment">//大小没有改变时的渲染区域设定</span></div><div class="line">                <span class="keyword">if</span> ((flags &amp; (ViewGroup.FLAG_OPTIMIZE_INVALIDATE | ViewGroup.FLAG_ANIMATION_DONE)) ==</div><div class="line">                        ViewGroup.FLAG_OPTIMIZE_INVALIDATE) &#123;</div><div class="line">                    parent.mGroupFlags |= ViewGroup.FLAG_INVALIDATE_REQUIRED;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((flags &amp; ViewGroup.FLAG_INVALIDATE_REQUIRED) == <span class="number">0</span>) &#123;</div><div class="line">                    <span class="comment">// The child need to draw an animation, potentially offscreen, so</span></div><div class="line">                    <span class="comment">// make sure we do not cancel invalidate requests</span></div><div class="line">                    parent.mPrivateFlags |= PFLAG_DRAW_ANIMATION;</div><div class="line">                    parent.invalidate(mLeft, mTop, mRight, mBottom);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//大小改变后需要渲染的区域设定</span></div><div class="line">                <span class="keyword">if</span> (parent.mInvalidateRegion == <span class="keyword">null</span>) &#123;</div><div class="line">                    parent.mInvalidateRegion = <span class="keyword">new</span> RectF();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">final</span> RectF region = parent.mInvalidateRegion;</div><div class="line">                a.getInvalidateRegion(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop, region,</div><div class="line">                        invalidationTransform);</div><div class="line"></div><div class="line">                <span class="comment">// The child need to draw an animation, potentially offscreen, so</span></div><div class="line">                <span class="comment">// make sure we do not cancel invalidate requests</span></div><div class="line">                parent.mPrivateFlags |= PFLAG_DRAW_ANIMATION;</div><div class="line"></div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> left = mLeft + (<span class="keyword">int</span>) region.left;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> top = mTop + (<span class="keyword">int</span>) region.top;</div><div class="line">                parent.invalidate(left, top, left + (<span class="keyword">int</span>) (region.width() + .<span class="number">5f</span>),</div><div class="line">                        top + (<span class="keyword">int</span>) (region.height() + .<span class="number">5f</span>));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> more;</div><div class="line">    &#125;</div><div class="line">`</div></pre></td></tr></table></figure>
<p>Animator 是在具体的子类实现动画的更新的，比如 ValueAnimator 的源码，核心的更新代码在<code>doAnimationFrame</code>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ValueAnimator.java  Animator方案</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doAnimationFrame</span><span class="params">(<span class="keyword">long</span> frameTime)</span> </span>&#123;</div><div class="line">        AnimationHandler handler = AnimationHandler.getInstance();</div><div class="line">        <span class="comment">//确认是否已经结束动画了</span></div><div class="line">        <span class="keyword">if</span> (mLastFrameTime == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// First frame</span></div><div class="line">            handler.addOneShotCommitCallback(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">if</span> (mStartDelay &gt; <span class="number">0</span>) &#123;</div><div class="line">                startAnimation();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (mSeekFraction &lt; <span class="number">0</span>) &#123;</div><div class="line">                mStartTime = frameTime;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">long</span> seekTime = (<span class="keyword">long</span>) (getScaledDuration() * mSeekFraction);</div><div class="line">                mStartTime = frameTime - seekTime;</div><div class="line">                mSeekFraction = -<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            mStartTimeCommitted = <span class="keyword">false</span>; <span class="comment">// allow start time to be compensated for jank</span></div><div class="line">        &#125;</div><div class="line">        mLastFrameTime = frameTime;</div><div class="line">        <span class="keyword">if</span> (mPaused) &#123;</div><div class="line">            mPauseTime = frameTime;</div><div class="line">            handler.removeCallback(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mResumed) &#123;</div><div class="line">            mResumed = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">if</span> (mPauseTime &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// Offset by the duration that the animation was paused</span></div><div class="line">                mStartTime += (frameTime - mPauseTime);</div><div class="line">                mStartTimeCommitted = <span class="keyword">false</span>; <span class="comment">// allow start time to be compensated for jank</span></div><div class="line">            &#125;</div><div class="line">            handler.addOneShotCommitCallback(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// The frame time might be before the start time during the first frame of</span></div><div class="line">        <span class="comment">// an animation.  The "current time" must always be on or after the start</span></div><div class="line">        <span class="comment">// time to avoid animating frames at negative time intervals.  In practice, this</span></div><div class="line">        <span class="comment">// is very rare and only happens when seeking backwards.</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> currentTime = Math.max(frameTime, mStartTime);</div><div class="line">        <span class="comment">//根据时间计算最新的 animated 的值，然后通过 listener 回调 onAnimationUpdate</span></div><div class="line">        <span class="keyword">boolean</span> finished = animateBasedOnTime(currentTime);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (finished) &#123;</div><div class="line">            endAnimation();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>上述代码只展现了单一帧的渲染过程，那么整一个动画是如何渲染的呢？肯定是有个地方每16ms  触发一次<code>draw</code>或者是<code>doAnimationFrame</code>方法，让他刷新界面，而这个16ms 的定时器，就是由 Choreographer 来实现的，他实际上是通过接收<code>display subsystem</code>的<code>timing pluses</code>来实现定时器功能的。当然如果系统不支持，则使用 handler 来实现定时器，handler 定时器的时间为10ms，设定时间比16ms 短是为了防止等待时间过长导致丢帧，因为定时器并不是完全准时的。</p>
<p>Choreographer 只是一个定时器，定时器的注册还是放在 view 本身或者 AnimationHandler。</p>
<p>Choregrapher 的 postCallback 经过各种处理后（比如入栈，出栈等操作），最终会调用 doFrame 方法，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">  doFrame(<span class="keyword">long</span> , <span class="keyword">int</span> ) &#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = System.nanoTime();</div><div class="line">        <span class="comment">//获取 callbackqueue 中与当前事件最近的操作来处理，即跳帧。理想情况下，queue 中应该只会有一个元素，当主线程比较卡，一个渲染周期内积累了太多事件，就会导致 callback 多</span></div><div class="line">        callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(</div><div class="line">              now / TimeUtils.NANOS_PER_MS);</div><div class="line">      <span class="keyword">if</span> (callbacks == <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">          mCallbacksRunning = <span class="keyword">true</span>;</div><div class="line">      <span class="comment">//...一些帧信息等处理，丢帧的 log 就是在这部分抛出的</span></div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">          Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"Choreographer#doFrame"</span>);</div><div class="line">          AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);</div><div class="line"></div><div class="line">          mFrameInfo.markInputHandlingStart();</div><div class="line">          <span class="comment">//先处理输入事件</span></div><div class="line">          doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</div><div class="line"></div><div class="line">          mFrameInfo.markAnimationsStart();</div><div class="line">          <span class="comment">//再处理动画</span></div><div class="line">          doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</div><div class="line"></div><div class="line">          mFrameInfo.markPerformTraversalsStart();</div><div class="line">          <span class="comment">//最后处理view 的布局和绘制</span></div><div class="line">          doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</div><div class="line"></div><div class="line">          <span class="comment">//处理完成</span></div><div class="line">          doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</div><div class="line">      &#125; <span class="keyword">finally</span> &#123;</div><div class="line">          AnimationUtils.unlockAnimationClock();</div><div class="line">          Trace.traceEnd(Trace.TRACE_TAG_VIEW);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="comment">//CallbackQueue.java</span></div><div class="line"> <span class="function"><span class="keyword">public</span> CallbackRecord <span class="title">extractDueCallbacksLocked</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</div><div class="line">          CallbackRecord callbacks = mHead;</div><div class="line">          <span class="keyword">if</span> (callbacks == <span class="keyword">null</span> || callbacks.dueTime &gt; now) &#123;</div><div class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          CallbackRecord last = callbacks;</div><div class="line">          CallbackRecord next = last.next;</div><div class="line">          <span class="keyword">while</span> (next != <span class="keyword">null</span>) &#123;</div><div class="line">              <span class="keyword">if</span> (next.dueTime &gt; now) &#123;</div><div class="line">                  last.next = <span class="keyword">null</span>;</div><div class="line">                  <span class="keyword">break</span>;</div><div class="line">              &#125;</div><div class="line">              last = next;</div><div class="line">              next = next.next;</div><div class="line">          &#125;</div><div class="line">          mHead = next;</div><div class="line">          <span class="keyword">return</span> callbacks;</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<p>弄明白 Choreographer 的机制后，再看 Animator 的实现就方便了，Animator 的动画，最终是通过 AnimationHandler 来进行处理的，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//AnimationHandler.java</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Choreographer.FrameCallback mFrameCallback = <span class="keyword">new</span> Choreographer.FrameCallback() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</div><div class="line">            doAnimationFrame(getProvider().getFrameTime());</div><div class="line">            <span class="keyword">if</span> (mAnimationCallbacks.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">                getProvider().postFrameCallback(<span class="keyword">this</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAnimationFrame</span><span class="params">(<span class="keyword">long</span> frameTime)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> size = mAnimationCallbacks.size();</div><div class="line">        <span class="keyword">long</span> currentTime = SystemClock.uptimeMillis();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">            <span class="keyword">final</span> AnimationFrameCallback callback = mAnimationCallbacks.get(i);</div><div class="line">            <span class="keyword">if</span> (callback == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//从动画的延迟列表里找 callback，如果没有，说明已经开始了，如果有并且开始时间小于 currentTime，也开始执行（相当于动画开始）</span></div><div class="line">            <span class="keyword">if</span> (isCallbackDue(callback, currentTime)) &#123;</div><div class="line">                callback.doAnimationFrame(frameTime);</div><div class="line">                <span class="keyword">if</span> (mCommitCallbacks.contains(callback)) &#123;</div><div class="line">                    getProvider().postCommitCallback(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                            commitAnimationFrame(callback, getProvider().getFrameTime());</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//把一些callback 为 null 的项清空掉，removeCallbacks 时，是把对应 index 下的 callback 置空，这是为了保证线程安全</span></div><div class="line">        cleanUpList();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeCallback</span><span class="params">(AnimationFrameCallback callback)</span> </span>&#123;</div><div class="line">        mCommitCallbacks.remove(callback);</div><div class="line">        mDelayedCallbackStartTime.remove(callback);</div><div class="line">        <span class="keyword">int</span> id = mAnimationCallbacks.indexOf(callback);</div><div class="line">        <span class="keyword">if</span> (id &gt;= <span class="number">0</span>) &#123;</div><div class="line">            mAnimationCallbacks.set(id, <span class="keyword">null</span>);</div><div class="line">            mListDirty = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>古老的 Animation 方式没有利用 CALLBACK_ANIMATION 这个类型，而是使用递归的方式来实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ViewRootImpl.java</span></div><div class="line">    <span class="comment">//任何 view 的 invalidate 最终都会调用到这个类的这个方法中，再通过 Choreographer 的 postCallback，在下一帧中进行重绘</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!mTraversalScheduled) &#123;</div><div class="line">            mTraversalScheduled = <span class="keyword">true</span>;</div><div class="line">            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</div><div class="line">            <span class="comment">//这里用的是布局类型，说明古老的 animation 方式，是通过实时刷新ViewTree 来实现的。</span></div><div class="line">            mChoreographer.postCallback(</div><div class="line">                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</div><div class="line">            <span class="keyword">if</span> (!mUnbufferedInputDispatch) &#123;</div><div class="line">                scheduleConsumeBatchedInput();</div><div class="line">            &#125;</div><div class="line">            notifyRendererOfFramePending();</div><div class="line">            pokeDrawLockIfNeeded();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><h3 id="Animation-动画"><a href="#Animation-动画" class="headerlink" title="Animation 动画"></a>Animation 动画</h3><p>view 渲染流程：<br><img src="/images/android-animation-principle/E396D831AAEB46950785E4F0991D9088.jpg" alt="IMAGE"></p>
<p>Animation 动画流程：<br><img src="/images/android-animation-principle/72AFDF08B0CE617A43B14281DDEADABD.jpg" alt="IMAGE"></p>
<p>Animator 动画流程：<br><img src="/images/android-animation-principle/BC368855FA78E690CD9DA1243A49A7E5.jpg" alt="IMAGE"></p>
<p><a href="/images/android-animation-principle/AA68573C5A5880D945D2F78F15EAE992.mdj">流程图源文件.mdj</a></p>
<h2 id="关键帧动画（keyframe-animatin"><a href="#关键帧动画（keyframe-animatin" class="headerlink" title="关键帧动画（keyframe animatin)"></a>关键帧动画（keyframe animatin)</h2><p>通过设定关键帧，由系统自动补全中间过程得以实现，中间的补充过程是用特定的插值方法计算得到，至于怎么算的，有时间再研究</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>动画的本质是在极短的时间内，渲染连续的画面，通过实现错觉让人感觉画面是“动”的，能够骗过人眼的频率是60fps，即每秒60帧，平均16ms 渲染一帧</li>
<li>view或者 ValueAnimator 中主要处理单帧画面的渲染，而至于渲染的时机，通过 postCallback 的方式，把触发时机交给 Choreographer 来实现</li>
<li>Choreophraher 通过侦听<code>display subsystem</code>的显示心跳来实现计时器，为了兼容，其内部也支持了通过 handler 实现的计时器，其计时周期是10ms</li>
<li>Choreophraher 心跳触发后，在 doFrame 中进行处理，把对应的 callback 拿出来执行，callback 分为三类，按照输入-&gt;动画-&gt;布局的顺序来处理事件</li>
<li>在单个帧的处理中，如果相同类型的时间出现多次，只取小于当前时间，并且离当前时间最近的事件来处理，即通常意义的跳帧。如果出现跳帧的操作，展现出来的就是丢帧，最终的结果就是看起来卡了下</li>
<li>所以丢帧可能会是两种原因，一个是 doFrame 的时间过长，另一个是主线程执行了比较重的任务，导致线程处理不过来</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.cnblogs.com/kross/p/4087780.html" target="_blank" rel="external">Android动画原理分析</a><br><a href="https://juejin.im/entry/57abeac5a341310060dbd7fd" target="_blank" rel="external">自定义 View-invalidate 传递与绘制流程分析</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mlazy.club/2017/12/15/react-native-animation-performance-tool-systrace/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mluffy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人小屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/15/react-native-animation-performance-tool-systrace/" itemprop="url">react-native 下，Android动画性能分析工具-systrace</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-15T19:08:24+08:00">
                2017-12-15
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/12/15/react-native-animation-performance-tool-systrace/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2017/12/15/react-native-animation-performance-tool-systrace/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          
             <span id="/2017/12/15/react-native-animation-performance-tool-systrace/" class="leancloud_visitors" data-flag-title="react-native 下，Android动画性能分析工具-systrace">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在项目中发现 react-native 的项目在实现转场动画的过程中，部分国产 android 机型出现转场时有不流畅的感觉，因此需要对动画过程进行分析，定位问题。本篇文章是定位问题过程衍生出来的第一篇文章。这一系列文章，会涉及到</p>
<ol>
<li><a href="/2017/12/15/react-native-animation-performance-tool-systrace/" title="react-native 下，Android动画性能分析工具-systrace">react-native 下，Android动画性能分析工具-systrace</a></li>
<li><a href="/2017/12/15/android-animation-principle/" title="android 动画原理">android 动画原理</a></li>
<li><a href="/2017/12/15/react-native-animated-principle/" title="react-native animated 动画实现原理">react-native animated 动画实现原理</a></li>
<li><a href="/2017/12/15/react-navigation-animation-principle/" title="react-navigation 动画实现原理">react-navigation 动画实现原理</a></li>
<li><a href="/2017/12/15/react-native-animation-anlaysis-summary/" title="react-native 动画性能分析总结">react-native 动画性能分析总结</a>
</li>
</ol>
<h1 id="systrace"><a href="#systrace" class="headerlink" title="systrace"></a>systrace</h1><p>官方文档的 <a href="https://facebook.github.io/react-native/docs/performance.html" target="_blank" rel="external">performance</a> 里，提到了不少分析工具，在定位的过程中，更多使用的是 android 提供的 systrace 方法，其使用说明在 <a href="https://facebook.github.io/react-native/docs/performance.html#Profiling" target="_blank" rel="external">performance</a> 的 <code>profiling</code> 章节中也有提到</p>
<h2 id="systrace-的使用方法"><a href="#systrace-的使用方法" class="headerlink" title="systrace 的使用方法"></a>systrace 的使用方法</h2><p>systrace 本质上是通过记录关键方法的调用记录进行统计分析。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ &lt;path_to_android_sdk&gt;/platform-tools/systrace/systrace.py --time=10 -o trace.html <span class="built_in">sched</span> gfx view -a &lt;your_package_name&gt;</div></pre></td></tr></table></figure>
<p>几个参数的含义：</p>
<ul>
<li><code>time</code>：数据记录收集的时长</li>
<li><code>sched</code>，<code>gfx</code>，<code>view</code>都是分析指标，这三个属于分析过程中需要关注到的几个指标。<code>sched</code>是提供集每一核 cpu 具体在处理的事情，<code>gfx</code>提供图形化的信息，比如按照每一帧来给时间划分区域，<code>view</code>则是提供视图的计算、布局和渲染耗时</li>
<li>-a <package_name>用于指定收集特定应用的数据</package_name></li>
<li>-o <file.html> 用于指定分析结果的输出位置，输出结果最好用 chrome 打开，其他浏览器不保证兼容性</file.html></li>
</ul>
<h2 id="阅读分析结果"><a href="#阅读分析结果" class="headerlink" title="阅读分析结果"></a>阅读分析结果</h2><p>在 chrome 打开文件后，可以在右上角的<code>View Options</code>里，打开 Hightlight VSync，用于标记显示系统（display subsystem）渲染每一帧的时间点。</p>
<p>一个测试结果如下：<br><img src="/images/react-native-animation-performance-tool-systrace/CE7AF2EB29354FF79D54A3E05F310D01.jpg" alt="IMAGE"><br><a href="/images/react-native-animation-performance-tool-systrace/268FACA41EBCD174731B1A95B7C68AA7.zip">测试结果源文件</a></p>
<p>左侧是进程以及进程下正在执行的线程（并不是所有线程，而是在记录时活跃的线程）。中间的图形则是渲染的分析结果，F 表示视图开始渲染的时间点，即 view 执行<code>performTraversals</code>时的时间点。F 标记为绿色，说明视图渲染的时间不超过一帧，不是绿色，说明已经有丢帧出现。这时就可以查看丢帧严重的地方，看看是哪个部分占用耗时。</p>
<p><img src="/images/react-native-animation-performance-tool-systrace/3871F6AC03A57304753B84964C56E564.jpg" alt="IMAGE"><br>比如上图红色的 frame，可以看到大部分是在 performTraversals 耗时较多，说明视图的渲染比较耗时。虽然说是在渲染视图时耗时，但是并不一定完全是因为 view 太过复杂引起的，实际上，在上述例子中，这个界面只是简单的几个按钮，view 并不复杂，这时候需要同步分析 cpu 中线程的执行情况，看看是否是因为 CPU 负载过高，导致任务等待。点击 DrawFrame，我们可以看到执行时间实际只有13ms（CPU Duration），但是等待 cpu 资源达到了20ms（Wall Duration - CPU Duration），这就 与应用的环境、系统的环境有关系了。<br><img src="/images/react-native-animation-performance-tool-systrace/CBE4145B3B4BF25025077BF9909556BF.jpg" alt="IMAGE"></p>
<h2 id="有关丢帧"><a href="#有关丢帧" class="headerlink" title="有关丢帧"></a>有关丢帧</h2><p>在上节分析结果，我们说到 F 标记为黄色或者红色时，说明有丢帧出现，但从实际体验上看，只是黄色的丢帧并没有令人感觉到不流畅，或者说短时间的动画，让人感受不到那细微的差异。因为从本质上说，30FPS（人眼能够感知的最低动画频率是24FPS） 的动画也是让人感受不到异常的，当然这要具体情况具体分析，不同场景下，对帧率的要求也是不同的（比如射击游戏对帧率的要求就比较高，不然会让人有眩晕感）。总的来说，我们不能单纯的以 profile 的结果来判定动画的性能，需要结合实际情况进行分析，profile 只是一个辅助定位的手段。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>[performance]（<a href="https://facebook.github.io/react-native/docs/performance.html）章节中，提到了很多性能分析的方法，定位动画问题最常用到的是" target="_blank" rel="external">https://facebook.github.io/react-native/docs/performance.html）章节中，提到了很多性能分析的方法，定位动画问题最常用到的是</a> systrace</li>
<li>利用 systrace，我们可以得到每一帧中视图的渲染情况、线程的执行情况及 CPU 的负载情况，综合上述的几个指标，可以分析定位可能影响动画性能的地方</li>
<li>丢帧并不一定会影响最终的展现效果，手机一般的帧率是60FPS，远大于人眼能够感知的最低帧率（24FPS），因此单纯靠分析结果去判定动画性能是不靠谱的。某些丢帧的部分可能是影响不大的地方，对最终的动画效果并不能产生决定性的影响。我们应该把 profile 的结果作为一个分析参数，最终还要综合其他因素进行考量</li>
</ol>
<h1 id="有个坑"><a href="#有个坑" class="headerlink" title="有个坑"></a>有个坑</h1><p>虽然有了如此多的分析工具，但是这些工具本质上是在分析动画的渲染频率，并没有对中间过程的动画进行分析。动画，本质上是一组<code>连续的</code>画面，按照<code>一定频率</code>播放的结果，这些工具主要是在验证动画是否是按照<code>一定频率</code>进行渲染，而在本次分析的结果中，发现，实际上发现是因为画面<code>不连续</code>导致的。那么这个结果是如何发现的？其看下集：<a href="/2017/12/15/android-animation-principle/" title="android 动画原理">android 动画原理</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mlazy.club/2017/09/21/thought-of-android-performance-anlaysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mluffy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人小屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/21/thought-of-android-performance-anlaysis/" itemprop="url">Android 性能分析（道篇）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-21T19:25:42+08:00">
                2017-09-21
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/09/21/thought-of-android-performance-anlaysis/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2017/09/21/thought-of-android-performance-anlaysis/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          
             <span id="/2017/09/21/thought-of-android-performance-anlaysis/" class="leancloud_visitors" data-flag-title="Android 性能分析（道篇）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近需要对手头上的项目做一个性能优化，要求应用能正常的跑在一个低性能的设备上，碰碰巧这一块是此前没怎么涉及到的，相当于是一个全新的任务。真正做起来的时候绕了不少弯路，回过头在总结的时候才发现，使用的方法和编程都是一个套路，用在不同的场景下得出了不同的名字，本质上仍然是相同的，这也是为什么历史上站在行业顶峰的人，都是一长串的 XX 家作为 title。比如爱因斯坦，数学、物理很厉害，小提琴也有不小的造诣。再如达芬奇虽然以艺术功底闻名于世，其机械、医学能力也是相当出彩的。</p>
<p>复杂的事往往都有简单的道理，而简单的道理往往能运用在工作生活的方方面面。</p>
<h1 id="从宏观到微观（至顶向下）的分析方法"><a href="#从宏观到微观（至顶向下）的分析方法" class="headerlink" title="从宏观到微观（至顶向下）的分析方法"></a>从宏观到微观（至顶向下）的分析方法</h1><p>编程世界里，我们倡导设计先行，从需求出发，先进行需求分析，再进行软件设计，最后才开始编码实现。这一套方法论总结起来就是从宏观的角度分析、发现问题，再分解到微观角度去解析问题的本质。</p>
<p>无独有偶，物理、化学也是一个从宏观到微观的过程，先通过宏观了解到事物的表象，再从微观去理解本质。</p>
<p>那么套方法论到性能分析上，就可以逐层分解出几个主题：</p>
<p><strong>确定性能指标</strong><br><strong>寻找分析工具</strong><br><strong>确定分析方法</strong><br><strong>问题修复</strong></p>
<h2 id="确定性能指标"><a href="#确定性能指标" class="headerlink" title="确定性能指标"></a>确定性能指标</h2><p>通过 Google，搜索一些诸如 android 性能分析 性能评估 性能瓶颈 等等关键词，提取出确定性能的几个指标，再结合当前的项目抽取出合适当前项目的指标。</p>
<p>比如本次我总结出来以下几点：</p>
<ul>
<li>OS<ul>
<li>cpu</li>
<li>memory</li>
<li>I/O</li>
</ul>
</li>
<li>App<ul>
<li>业务方法调用耗时<ul>
<li>java</li>
<li>native</li>
</ul>
</li>
<li>UI 布局</li>
</ul>
</li>
</ul>
<p>主要分为了两个角度，一个是系统层面，从操作系统的角度来分析应用的性能，二是应用层面，从应用层的角度去分析性能瓶颈。这两者实际上是有重叠的，但是因为切入的角度不一样，通过对比，可以更容易的发现和解决问题。</p>
<p>另外，在当前的项目中，由于 I/O 操作几乎没有，因此这部分可以不在此次的评估范围内，因此就目前的项目来说，就可以把分析指标定位在以下几个：</p>
<ul>
<li>OS<ul>
<li>cpu</li>
<li>memory</li>
<li>I/O</li>
</ul>
</li>
<li>App<ul>
<li>业务方法调用耗时<ul>
<li>java</li>
<li>native</li>
</ul>
</li>
<li>UI 布局</li>
</ul>
</li>
</ul>
<h2 id="寻找分析工具"><a href="#寻找分析工具" class="headerlink" title="寻找分析工具"></a>寻找分析工具</h2><p>Android 的性能分析工具种类繁多，简书上有一篇收集的挺好的 - <a href="http://www.jianshu.com/p/8b77d394b2a6" target="_blank" rel="external">Android 性能分析工具整理汇总</a>，这里就不再赘述。</p>
<p>那么问题来了，这么多工具，应该选哪一个呢？</p>
<p>前面说到，分析问题的时候，需要使用至顶向下的分析方式，那么需要使用工具解决问题的时候，还能使用这个方法吗？</p>
<p>答案是不能，使用工具、解决问题，这已经是一个顶层的事情，你看网络模型里，application layer 是不是放在上边的？</p>
<p>所以到使用工具，解决问题的领域时，就需要刚好相反的能力，至底向上。我们需要从底部开始，了解事物的本质，才能够从容的选择上层的工具来解决问题。比如你访问 Google 出现 connection reset，如果仅限于了解http 404是网页未找到，这个问题就等于无解了。你得先了解 TCP/IP，了解浏览器访问 google.com 时都做了什么事情，国家防火墙在这个过程又充当了什么角色，这才有底气的通过抓包工具定位问题。</p>
<p>回到性能分析，我的答案是先看<a href="https://developer.android.com/studio/profile/am-cpu.html" target="_blank" rel="external">官方文档</a>，官方文档里提供的工具，相对基础，先了解这些工具如何使用，也就基本掌握指标对应的含义。那么在使用过程中产生的痛点，也就是你对工具的需求了，针对自己的需求，再去找工具，就有的放矢了。</p>
<h2 id="确定分析方法"><a href="#确定分析方法" class="headerlink" title="确定分析方法"></a>确定分析方法</h2><p>上面说到先用官方工具来分析，那么如何分析呢。那些如何看图表，指标的含义在这里不再赘述，后续的文章中会详细说明。在这里只说一点，就是要排出干扰，无论什么领域，在分析问题的时候，都需要遵守单一变量原则，做科学实验如此，解 bug 如此，分析性能也是一样。无论是低端一点的注释方法，还是高级一些的 API mock，都是围绕单一变量原则来进行的。了解这个，那么所使用的方法就不会有太多拘束了。独孤九剑的最高奥义无招胜有招也是一个道理，了解剑招的本质，也就无所谓剑招了。</p>
<h2 id="问题修复"><a href="#问题修复" class="headerlink" title="问题修复"></a>问题修复</h2><p>这里又会回到分析问题，因此继续套用至顶向下的分析方法。定位到对应代码出了问题，要避免单纯的针对问题本身做修复，而是要从宏观的角度来分析问题，多问问自己，这个问题是否设计上的缺陷？语言缺陷？应该如何从根本上去避免此类问题？</p>
<p>题外话，修复问题的时候，不要想着“先这样改吧，以后有时间再做优化”，然后还加个 TODO 以此为证。历史经验证明，这招往往是没有效的，计划赶不上变化，技术一直在持续更新，你现在不优化，跟上节奏，那么会越来越跟不上节奏。另外，需求一直有，今年特别多，你也不大有机会再回来处理这个优先级如此之低的 TODO 了</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上，就是我在分析当前项目性能的过程中领悟到的一些知识。总体来说就是分析问题时，至顶向下来分析，解决问题时，至底向上去解决。前者有利于把问题想透，后者有利于把问题彻底解决。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mlazy.club/2016/10/22/ios-background-mode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mluffy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人小屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/22/ios-background-mode/" itemprop="url">iOS 的后台运行机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-22T20:01:58+08:00">
                2016-10-22
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/10/22/ios-background-mode/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2016/10/22/ios-background-mode/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          
             <span id="/2016/10/22/ios-background-mode/" class="leancloud_visitors" data-flag-title="iOS 的后台运行机制">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>详细的说明可以参考<a href="https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/BackgroundExecution/BackgroundExecution.html#//apple_ref/doc/uid/TP40007072-CH4-SW1" target="_blank" rel="external">Background Execution</a></p>
<p>在APP不支持background mode的前提下，点击home之后，会进入background state，接着经过短短几秒后，会进入suspend state。</p>
<p>iOS提供了一些后台运行的权限申请，用以保证特定场景下的后台执行需求。截止iOS9，所支持的权限如下表：<br><img src="/images/ios-background-mode/1439214114982.png" alt="Alt text"></p>
<p>一般情况下，如果仅需要在进入后台的时候额外做一些操作，则不需要申请这些后台权限，仅需要执行一个long-runing task即可。<br>示例代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (<span class="keyword">void</span>)applicationDidEnterBackground:(<span class="built_in">UIApplication</span> *)application</div><div class="line">&#123;</div><div class="line">    bgTask = [application beginBackgroundTaskWithName:<span class="string">@"MyTask"</span> expirationHandler:^&#123;</div><div class="line">        <span class="comment">// Clean up any unfinished task business by marking where you</span></div><div class="line">        <span class="comment">// stopped or ending the task outright.</span></div><div class="line">        [application endBackgroundTask:bgTask];</div><div class="line">        bgTask = <span class="built_in">UIBackgroundTaskInvalid</span>;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    <span class="comment">// Start the long-running task and return immediately.</span></div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line"></div><div class="line">        <span class="comment">// Do the work associated with the task, preferably in chunks.</span></div><div class="line"></div><div class="line">        [application endBackgroundTask:bgTask];</div><div class="line">        bgTask = <span class="built_in">UIBackgroundTaskInvalid</span>;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>首先需要明确APP的一个生命周期<br><img src="/images/ios-background-mode/1439212569060.png" alt="Alt text"></p>
<h2 id="Activate"><a href="#Activate" class="headerlink" title="Activate"></a>Activate</h2><p>APP处于前台，接受UI的点击事件</p>
<h2 id="InActivate"><a href="#InActivate" class="headerlink" title="InActivate"></a>InActivate</h2><p>APP仍然处于前台，但不接受UI点击事件</p>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>APP处于后台，此时APP完全属于不可见的状态，比如点击home键之后，即进入了background state。此时应用仍然在运行，所有代码均可执行。</p>
<h2 id="suspend"><a href="#suspend" class="headerlink" title="suspend"></a>suspend</h2><p>挂起，此时iOS会存储当前应用的执行状态，接着释放掉对应的资源。</p>
<h1 id="iOS后台运行机制分析"><a href="#iOS后台运行机制分析" class="headerlink" title="iOS后台运行机制分析"></a>iOS后台运行机制分析</h1><p>介绍完基础知识，开始进入正题。先从实践入手，目前使用了CentralManager mode和Location update mode两个后台使用权限。从这两个后台模式碰到的一些现象，来尝试分析iOS是如何完成后台运行的。</p>
<h2 id="Location-update"><a href="#Location-update" class="headerlink" title="Location update"></a>Location update</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>Step1.首先做好后台的配置，先在Xcode的capabilities中勾选对应的选项<br><img src="/images/ios-background-mode/1439454966117.png" alt="Alt text"></p>
<p>Step2.接着在plist中添加NSLocationAlawaysUsageDescription<br><img src="/images/ios-background-mode/1439455184137.png" alt="Alt text"></p>
<p>完成这两步才算完成了后台运行的基础。<br>Step3.接着还需要在代码中调用<code>requestAlwaysAuthorization</code>，才算完成了对后台更新location的申请。</p>
<p>为什么需要做这些配置呢？<br>iOS默认是不支持后台执行的，为的是能够将更多的资源集中在当前运行的应用上。因此需要有step1.运行权限的配置。<br>在iOS7之后，对于location的使用，提供了两种模式<code>Always</code>以及<code>WhenInUse</code>，从命名上也很容易明白，<code>Always</code>即任何情况下都可以使用，而<code>WhenInUse</code>则是在应用开启的时候允许使用。<br>下面一张图会看着比较清晰<br><img src="/images/ios-background-mode/1439455776679.png" alt="Alt text"><br>两者的区别无非是对于Location Monitoring的使用权限。那么这两个东西分别是什么鬼？<br><code>Region monitoring</code>，是对一个进出某一个区域的检测。对应的方法是<code>startMonitoringForRegion:</code>。我们可以使用<code>CLRegion</code>设定一个圆，在位置进出这个圆时，会调用<code>didEnterRegion</code>以及<code>didExitRegion</code>的代理。<br><code>Significant location changes</code>，是苹果为了电量的优化做的定位策略。对应的方法是<code>startMonitoringSignificantLocationChanges</code>。<br>摘抄API的描述文档：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Starts the generation of updates based on significant location changes.</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">If you start this service and your app is subsequently terminated, the system automatically relaunches the app into the background if a new event arrives.</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">Apps can expect a notification as soon as the device moves 500 meters or more from its previous notification. It should not expect notifications more frequently than once every five minutes.</div></pre></td></tr></table></figure>
<p>从以上的描述得到两个重要信息，</p>
<ol>
<li>这个方法可以在app terminate的时候重启app使其进入后台模式</li>
<li>这个方法只有在运动了500米并且已经过了5分钟，才会执行一次定位</li>
</ol>
<p>从这个描述里，我们已经嗅到iOS的后台运行机制，它不仅仅是保持应用在后台执行。</p>
<p>接下来我们做个试验：<br>定义个BMLocationManager</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BMLocationManager</span> : <span class="title">CLLocationManager</span>&lt;<span class="title">CLLocationManagerDelegate</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>在初始化的时候直接执行定位：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BMLocationManager</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ([<span class="built_in">CLLocationManager</span> authorizationStatus] != kCLAuthorizationStatusAuthorizedAlways &amp;&amp; [<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(requestAlwaysAuthorization)]) &#123;</div><div class="line">            [<span class="keyword">self</span> requestAlwaysAuthorization];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">self</span>.distanceFilter = <span class="number">30</span>;</div><div class="line">        <span class="keyword">self</span>.desiredAccuracy = kCLLocationAccuracyBest;</div><div class="line">        <span class="keyword">self</span>.delegate = <span class="keyword">self</span>;</div><div class="line">        <span class="keyword">self</span>.pausesLocationUpdatesAutomatically = <span class="literal">YES</span>;</div><div class="line"></div><div class="line"><span class="comment">//        [self startMonitoringSignificantLocationChanges];</span></div><div class="line">        [<span class="keyword">self</span> startUpdatingLocation];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>didUpdateLocations</code>的代理里加上locationNotification方便查看log。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)locationManager:(<span class="built_in">CLLocationManager</span> *)manager didUpdateLocations:(<span class="built_in">NSArray</span> *)locations</div><div class="line">&#123;</div><div class="line">    <span class="built_in">UILocalNotification</span> *n = [<span class="built_in">UILocalNotification</span> new];</div><div class="line">    n.alertTitle = <span class="string">@"位置"</span>;</div><div class="line">    n.alertBody = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"位置更新：%@"</span>, [<span class="built_in">NSDateFormatter</span> localizedStringFromDate:[<span class="built_in">NSDate</span> date] dateStyle:<span class="built_in">NSDateFormatterNoStyle</span> timeStyle:<span class="built_in">NSDateFormatterShortStyle</span>]];</div><div class="line">    n.soundName = <span class="built_in">UILocalNotificationDefaultSoundName</span>;</div><div class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] scheduleLocalNotification:n];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"location update:%@"</span>, locations);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在模拟器app启动之后，点击home键进入后台，在debug-&gt;location下选择freeway-drive。（注意不要使用使用调试模式，在这个模式下app是不会被系统杀死的，和真实环境会有所出入。）<br>我们会发现，会不停的有location通知，然而挂着足够长的时间（可以跑这个<a href="https://github.com/ddaddy/BackgroundKill" target="_blank" rel="external">应用</a>让系统内存压力杀死其他app），发现通知停了，打开app一看，经历了闪屏，说明应用被杀掉了。<br>因此，在这里可以进行一个猜想，<strong>使用background mode并不能保证应用不会被系统杀死。</strong></p>
<p>那么location update的后台执行到底是怎么实现呢？我们来看看<code>startMonitoringSignificantLocationChanges</code>的方式。<br>既然API文档说在应用被终止时会重启app，并且调用<code>didFinishLaunchWithOptions</code>的代理，那么我们就在appDelegate里加上一个notification来做验证</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//收到位置消息时唤醒app</span></div><div class="line">    <span class="keyword">if</span> (launchOptions[<span class="built_in">UIApplicationLaunchOptionsLocationKey</span>]) &#123;</div><div class="line">        <span class="built_in">UILocalNotification</span> *noti = [<span class="built_in">UILocalNotification</span> new];</div><div class="line">        <span class="keyword">self</span>.strongRef = [BMLocationManager new];</div><div class="line">        noti.alertTitle = <span class="string">@"嘿嘿"</span>;</div><div class="line">        noti.alertBody = <span class="string">@"新的位置来了，app后台启动"</span>;</div><div class="line">        noti.soundName = <span class="built_in">UILocalNotificationDefaultSoundName</span>;</div><div class="line">        [application scheduleLocalNotification:noti];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>更新app，再次启动，接着直接杀死。发现确实调用了appDelegate。那么这个启动过程和一般的启动过程有什么不同呢？我们利用hook，在viewController里增加log，看看其调用过程。<br>log的配置使用了Aspects这个基于AOP的第三方框架。<br>AOP的方式在这类验证性的工作是非常有帮助的，保持了原有代码的整洁性。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (<span class="keyword">void</span>)makeHook</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSArray</span> *selectors = @[<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(init)),</div><div class="line">                           <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(awakeFromNib)),</div><div class="line">                           <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(viewDidLoad)),</div><div class="line">                           <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(viewWillAppear:)),</div><div class="line">                           <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(viewDidAppear:)),</div><div class="line">                           <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(viewWillDisappear:)),</div><div class="line">                           <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(viewDidDisappear:))];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *selectorStr <span class="keyword">in</span> selectors) &#123;</div><div class="line">        [<span class="keyword">self</span> hookClass:[<span class="built_in">UIViewController</span> <span class="keyword">class</span>] forSelector:<span class="built_in">NSSelectorFromString</span>(selectorStr)];</div><div class="line">    &#125;</div><div class="line">    selectors = @[<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(init)),</div><div class="line">                  <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(centralManager:willRestoreState:))];</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *selectorStr <span class="keyword">in</span> selectors) &#123;</div><div class="line">        [<span class="keyword">self</span> hookClass:[BMCentralManager <span class="keyword">class</span>] forSelector:<span class="built_in">NSSelectorFromString</span>(selectorStr)];</div><div class="line">    &#125;</div><div class="line">    selectors = @[<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(init)),</div><div class="line">                  <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(locationManager:didUpdateLocations:))];</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *selectorStr <span class="keyword">in</span> selectors) &#123;</div><div class="line">        [<span class="keyword">self</span> hookClass:[BMLocationManager <span class="keyword">class</span>] forSelector:<span class="built_in">NSSelectorFromString</span>(selectorStr)];</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span> hookClass:[<span class="built_in">UIWindow</span> <span class="keyword">class</span>] forSelector:<span class="keyword">@selector</span>(makeKeyAndVisible)];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)hookClass:(Class)aCass forSelector:(SEL)selecotr</div><div class="line">&#123;</div><div class="line">    [aCass aspect_hookSelector:selecotr withOptions:AspectPositionBefore usingBlock:^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@ call %@"</span>, [aspectInfo instance], <span class="built_in">NSStringFromSelector</span>(selecotr));</div><div class="line">    &#125;error:<span class="literal">nil</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来再次执行相同的步骤，看看log都输出了些什么？<br>发现一个viewController的完整生命周期都输出了。说明在后台启动的时候，并没有走什么特殊通道，而是按照正常的流程一直到等待UI输入的步骤。因此我们的app如果需要实现类似的后台运行模式，那么app delegate的设计就需要考虑到后台运行的情况了。</p>
<p>接下来再看，应用后台启动之后，我们手动打开app，又发生了什么事？<br>app又调用了闪屏，查看log，发现又重新来了一次启动流程。查看application的地址，发现不是同一个地址，说明手动开启app之后，系统把后台启动的应用给释放掉了。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>在location mode的后台执行模式下，应用并不会常驻在后台，而是与普通应用相同，随时会被killed。<br>想要达到类似常驻后台的效果，需要使用<code>startMonitoringSignificantLocationChanges</code>方法，在更新location时，系统会重启应用，使其处于后台模式。<br>应用启动时，与正常启动直到等待UI输入的流程无异。</p>
<h1 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h1><h2 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h2><p>在调试蓝牙后台时，需要验证是否真的唤醒了APP，但是调试模式下没办法进入suspend的状态，而双击home健手动杀掉进程，也同样不会唤醒APP，此时连蓝牙也会立即结束。因此需要进入suspend状态时，可以使用<br><code>kill(getpid(), SIGKILL)</code>方法模拟系统因为内存压力等原因结束进程的方式</p>
<h2 id="APNS"><a href="#APNS" class="headerlink" title="APNS"></a>APNS</h2><p>APNS需要在content-available为true，并且开启remote-notification的时候才会支持后台模式</p>
<p>当iOS收到一条push消息时，如果payload里包含content-available = true，那么会发生下面的事情</p>
<ul>
<li>如果app处于suspended状态，那么系统会把app置为background状态</li>
<li>如果app是是通过app switcher的方式被用户杀掉了，则不会启动app</li>
</ul>
<h2 id="关于后台启动"><a href="#关于后台启动" class="headerlink" title="关于后台启动"></a>关于后台启动</h2><p>后台启动根据不同的模式也会有不同的区别，一般情况下，只有应用处于suspended状态下的时候，才能够启动为background，对于force quit的应用，是不会生效的。目前来说，唯一例外的只有iOS 8之后的location模式会启动应用<br><img src="/images/ios-background-mode/1477103337238.png" alt="Alt text"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mlazy.club/2014/12/02/git-getting-start/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mluffy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="懒人小屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/12/02/git-getting-start/" itemprop="url">git 入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-12-02T20:18:57+08:00">
                2014-12-02
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2014/12/02/git-getting-start/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2014/12/02/git-getting-start/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          
             <span id="/2014/12/02/git-getting-start/" class="leancloud_visitors" data-flag-title="git 入门">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>每个人都有自己独特的学习技巧。于我来说，学习任何东西，都是先知其用法，再从基础开始，先懂其形，再观其意。这样做的好处就是能够非常快速的先踏入你所学习的领域，并将所得快速的纳入到自己现有的领域中来。这在工作中会非常受用，毕竟一个项目周期内，很难会给你充裕的时间从头到尾的了解新的知识。但是如此有一个很大的缺点，让人很容易浮躁，认为这一门学问很简单，很快就能掌握，到头来踩下无数的坑，每天去擦自己的屁股，于是才有了这篇文章。<br>在把自己的所得写成文章，必然需要把模糊的地方弄明白。慢慢的，不清晰的地方变清晰，对于这份知识的应用也越来越得心应手，终于，在文章结尾之时，这份知识才慢慢沉淀为自己的一部分，人也变得沉稳。这才是这篇文章最初的目的。</p>
<h1 id="源起"><a href="#源起" class="headerlink" title="源起"></a>源起</h1><p>同生活中的许多伟大事件一样，Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。到 2002 年，整个项目组开始启用分布式版本控制系统 BitKeeper 来管理和维护代码。</p>
<p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds ）不得不吸取教训，只有开发一套属于自己的版本控制系统才不至于重蹈覆辙。他们对新的系统制订了若干目标：</p>
<ul>
<li>速度</li>
<li>简单的设计</li>
<li>对非线性开发模式的强力支持（允许上千个并行开发的分支）</li>
<li>完全分布式</li>
<li>有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</li>
</ul>
<p>自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。它的速度飞快，极其适合管理大项目，它还有着令人难以置信的非线性分支管理系统，可以应付各种复杂的项目开发需求。</p>
<p>教科书里说：人和动物的区别就在于人类会使用工具。纵观伟大的产品的历史，都是为了提高工作效率而催生出来的产物。<br>在这个缺乏创新，control+c，control+v大行其道的时代，从身边的小事做起，致力于提高每一个细节的质量，也许一项为的产品就这么不经意间就诞生了。</p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>基础篇其实是我在学习git时遇到的疑问，并非传统的git基础。</p>
<h2 id="git特性"><a href="#git特性" class="headerlink" title="git特性"></a>git特性</h2><p>学习一门知识，最先需要了解的就是他的特点在哪里，这是我们能够快速评估他是否符合我们需求的一个方法。</p>
<h3 id="直接快照记录，而非差异比较"><a href="#直接快照记录，而非差异比较" class="headerlink" title="直接快照记录，而非差异比较"></a>直接快照记录，而非差异比较</h3><p>传统的VCS(如CVS,Subversion,Perforce,Bazaar)都是在各个版本中记录各个文件的具体差异，而git是保存每次更新时的文件快照。如此做法有什么好处呢？我们在分支处再说明</p>
<h3 id="时刻保持数据完整性"><a href="#时刻保持数据完整性" class="headerlink" title="时刻保持数据完整性"></a>时刻保持数据完整性</h3><p>如之前所说，git直接保存快照记录，那么他是如何判断文件是否更改的呢？<br>我们来看一看他的索引算法：<br>1.保存之前对所有数据进行checksum，并以结果作为数据的唯一标识和索引<br>2.使用SHA-1算法，通过文件内容和目录结构进行计算，得到一个SHA-1哈希值，作为指纹字符串。由40个16进制数组成（如：0e79d26c3c0abc43c135e4a33d2a4a94171d0da4）<br>3.所有保存在git数据库中的文件都是通过哈希值进行索引<br>通过他的索引算法，我们就清楚了为什么git的差异比较是如何实现的。所以git不会放过任何一个修改，即时是加了一个空格，文件的文件名，后缀，last modified属性被修改，git都会认为文件已经被修改。</p>
<h3 id="多数操作仅是添加数据"><a href="#多数操作仅是添加数据" class="headerlink" title="多数操作仅是添加数据"></a>多数操作仅是添加数据</h3><p>任何一种不可逆的操作，比如删除，都会使回退，或者重现历史版本变得困难重重。想象一下把计算机上的文件删除，而不是放入回收站，想要恢复就必须下载专业的恢复软件。常用的git操作都是只是简单的添加至数据库，然后保存快照。即时是git reset –hard的操作都是如此。这样在回退版本的时候就异常的简单。<br>我们来看一下git reflog的记录：<br>``</p>
<h2 id="四种文件状态"><a href="#四种文件状态" class="headerlink" title="四种文件状态"></a>四种文件状态</h2><h3 id="committed"><a href="#committed" class="headerlink" title="committed"></a>committed</h3><p>commit状态标识文件已经被快照记录，可以在版本库中回溯了</p>
<h3 id="staged"><a href="#staged" class="headerlink" title="staged"></a>staged</h3><p>已经被git add标记的文件，使用commit命令时会将处于这个状态的文件加入快照中。相当于预提交，通常我们称为暂存区。</p>
<h3 id="modified"><a href="#modified" class="headerlink" title="modified"></a>modified</h3><p>在最近的一个commit中存在的文件，当被修改时会处于modified状态。已经处于staged状态的文件，如果再次被修改，会同时出现在staged和modified状态。这个状态我们称为git的工作区</p>
<h3 id="untracked"><a href="#untracked" class="headerlink" title="untracked"></a>untracked</h3><p>在最近的一个commit中不存在的文件，处于没有被git追踪的状态，此文件git是不会去checksum的</p>
<h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><p>branch（分支）被称为git的必杀技。<br>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。在很多版本控制系统中，这是个昂贵的过程，常常需要创建一个源代码目录的完整副本，对大型项目来说会花费很长时间。<br>git的快照方式很好的支持了branch。新建一个branch，其实仅仅是在当前的commit号上创建了一个新的别名。今后在当前branch的操作中，就与在主分支一样的操作方式。所以每个branch都是相对独立的。从算法效率的角度来看，git的算法是通过牺牲空间来换取了时间。</p>
<h2 id="分支的操作"><a href="#分支的操作" class="headerlink" title="分支的操作"></a>分支的操作</h2><p>1.branch<br>~创建，查看，删除分支~<br>2.checkout<br>~切换，创建分支~<br>3.merge<br>~合并分支~<br>4.rebase<br>~衍合分支~<br>5.cherry-pick<br>~合并一/多个commit~</p>
<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>每个git项目，在其根目录下边都会有一个.git文件，里边存储着所有版本信息。下面我们就通过git的目录结构来研究他的实现机制。<br>一个典型的git目录结构如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ ls</div><div class="line">HEAD			保存当前分支最新的commit id</div><div class="line">branches/		分支信息，在新版本中已废弃</div><div class="line">config			当前git项目的配置信息</div><div class="line">description		仅供gitweb使用，具体用法还没有去了解</div><div class="line">hooks/			保存客户端或服务器的钩子脚本</div><div class="line">index			文件保存了暂存区的信息</div><div class="line">info/			包含了一份不存在.gitignore文件中管理的忽略模式的全局可执行文件</div><div class="line">objects/		目录存储所有数据内容</div><div class="line">refs/			目录存储指向数据（分支）的提交对象的指针</div></pre></td></tr></table></figure></p>
<p>refs中的信息如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$cd refs</div><div class="line">$ls</div><div class="line">heads/			保存本地的分支所指向的最新commit</div><div class="line">remote/			远程仓库的分支所指向的最新commit</div><div class="line">tags/			每个tag对应的commit</div></pre></td></tr></table></figure></p>
<p>我们把git的版本控制想象成对一个单链表的管理。链表中的每一个节点就是每个版本的快照指针（即一个commit）,所有的结点有且只有一个指针，指向其上一个commit。这就是为什么git中只保留HEAD，而没有一个tail的原因。<br>那么以上的文件其实就是一个指针，指向了链表中的某处。<br>链表中的每一个结点都可以延伸出多个结点（对应了不同的分支）<br>以第一个commit作为头节点，那么HEAD就是指向了当前正在操作的分支的一个尾节点的tail pointer<br>refs中的文件就是保存了一些比较特殊的结点，比如某个分支的HEAD结点（heads），某个结点的别名（tags），镜像链表的所有HEAD结点（remote）<br>所以每个git操作都可以认为是对链表的操作。每个结点都保存在.git/objects中，只有在某个时刻，git会运行git gc操作去回收一部分没有被引用的结点。<br>因此理论上，不管做了什么操作（除了删除.git这种脑残操作），只要还保存着commit信息，那么就能够回到任意状态。</p>
<h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><h2 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h2><p>个人感觉，git还是通过命令行去使用更有感觉，但是分支的状态，提交的更改在原始的git下操作是比较复杂的，因此GUI工具还是必不可少。<br>1.在Mac下，通常使用的GUI有source tree，通常是查看git的一个分支状态，以及一些commit的修改信息。<br>2.gitk是一个轻量级的git状态查看工具，还支持查看commit的修改项，通常情况下是满足了平时的业务需求。但是缺点就是没有Retina版本的gitk，Mac党用起来相当难受。</p>
<h2 id="diff-tool"><a href="#diff-tool" class="headerlink" title="diff tool"></a>diff tool</h2><p>原生的diff方法只能简单查看哪些地方被修改，可操控性，可读性都不是那么好，因此我们还是需要配合一个工具来对比修改。<br>meld是比较常用的difftool。安装方式<a href="http://jonathandean.com/2010/09/installing-meld-diff-tool-on-os-x-snow-leopard-using-fink/" target="_blank" rel="external">请点击这里</a></p>
<h2 id="命令别名"><a href="#命令别名" class="headerlink" title="命令别名"></a>命令别名</h2><p>在<code>~/.gitconfig</code>文件下，保存着git的全局配置信息，我们可以在这个文件中添加alias来达到为操作制定别名的效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[alias]</div><div class="line">        ck = checkout</div><div class="line">        st = status</div><div class="line">        ba = branch -av</div><div class="line">        ct = commit</div></pre></td></tr></table></figure></p>
<p>在文件末尾添加以上操作后，git st就可以查看git当前的状态，git ba就能够看到所有分支的详细信息，快去开始你高效工作的第一步吧：）</p>
<h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p>伟大的开源，伟大的分享！<br>有大神写了一个git练习教程，图文并茂，对理解git非常有帮助。<a href="http://pcottle.github.io/learnGitBranching/" target="_blank" rel="external">传送门</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.png"
               alt="mluffy" />
          <p class="site-author-name" itemprop="name">mluffy</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/luhui" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mluffy</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Gemini
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	

		<script type="text/javascript">
		_hcwp = window._hcwp || [];

		_hcwp.push({widget:"Bloggerstream", widget_id: 99034, selector:".hc-comment-count", label: "{\%COUNT%\}" });

		

		(function() {
		if("HC_LOAD_INIT" in window)return;
		HC_LOAD_INIT = true;
		var lang = (navigator.language || navigator.systemLanguage || navigator.userLanguage || "en").substr(0, 2).toLowerCase();
		var hcc = document.createElement("script"); hcc.type = "text/javascript"; hcc.async = true;
		hcc.src = ("https:" == document.location.protocol ? "https" : "http")+"://w.hypercomments.com/widget/hc/99034/"+lang+"/widget.js";
		var s = document.getElementsByTagName("script")[0];
		s.parentNode.insertBefore(hcc, s.nextSibling);
		})();
		</script>

	










  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.2"></script>



  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("f8tImvggaaabjWNL6cKiB9NE-gzGzoHsz", "CCF7eatYpKomzwcayI4AAgNV");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
